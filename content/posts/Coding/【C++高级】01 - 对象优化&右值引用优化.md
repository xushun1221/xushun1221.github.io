---
title: 【C++高级】01 - 对象优化&右值引用优化
date: 2022-09-08
tags: [C++]
categories: [Coding]
---

## 对象使用中调用了哪些函数？

### 构造、拷贝、赋值相关

```C++
#include <iostream>
using namespace std;

class Test {
public:
    Test(int a = 10) : _ma(a) { cout << "Test(int)" << endl; }
    ~Test() { cout << "~Test()" << endl; }
    Test(const Test& t) : _ma(t._ma) { cout << "Test(const Test&)" << endl; }
    Test& operator=(const Test& t) {
        _ma = t._ma;
        cout << "operator=(cosnt Test&)" << endl;
        return *this;
    }
private:
    int _ma;
};

int main() {
    Test t1;            // 默认构造
    Test t2(t1);        // 拷贝构造
    Test t3 = t1;       // 拷贝构造 不是赋值重载
    Test t4 = Test(20); // 普通构造 相当于 Test t4(20);
/* #1
    输出：
    Test(int)
    Test(const Test&)
    Test(const Test&)
    Test(int)

    Test(20); 意为显示生成一个临时对象
    临时对象的生存周期 仅为当前的语句 出语句后就析构
    那么 朴素的想法是 Test t4 = Test(20);
        1. 首先调用构造生成一个临时对象 Test(int)
        2. 然后调用拷贝构造生成对象t4 Test(const Test&)
        3. 最后出语句调用临时对象的析构 ~Test()
    但是事实并非如此 测试结果表明
    Test t4 = Test(20); 该语句仅调用了普通的构造函数 Test(int)

    这是C++ 编译器提供的优化
    当我们使用临时对象生成一个新对象时 C++编译器会优化这一过程
    不会构造临时对象并调用拷贝构造 而是直接构造新对象
*/
    cout << "-----------------" << endl;

    t4 = t2;        // 赋值重载
    t4 = Test(30);  // 赋值重载  
/* #2
    输出：
    operator=(cosnt Test&)
    Test(int)
    operator=(cosnt Test&)
    ~Test()

    该语句一定会产生临时对象 
    因为t4已经存在了 而非需要构造
    需要先后调用 1.临时对象构造 2.赋值重载 3.临时对象析构
*/
    cout << "-----------------" << endl;

    t4 = (Test)30; // 赋值重载  显式Test <- int 构造函数Test(int) 
    t4 = 30;       // 赋值重载  隐式Test <- int 构造函数Test(int) 
/* #3
    输出： 
    Test(int)
    operator=(cosnt Test&)
    ~Test()
    Test(int)
    operator=(cosnt Test&)
    ~Test()

    当其他类型想要转换为某个类类型时
    编译器会检查该类是否有合适的构造函数
    例如 这里Test类有带有int参数的构造函数 Test(int)
    所以 t4 = (Test)30; t4 = 30; 中的显式和隐式类型转换都可以成功
    由于 t4 对象已经存在 所以需要构造临时对象
        1.构造函数 生成临时对象 2.调用赋值重载 3.在离开语句时 临时对象析构
*/
    cout << "-----------------" << endl;

    // Test* p = &Test(40);     // 错误写法 对象指针不能指向一个临时变量
    const Test& ref = Test(50); // 正确写法 const对象引用 可以指向一个临时变量 (必须使用const引用才能指向临时对象 普通引用不行）
/* #4
    输出：
    Test(int)

    从之前的分析可以知道 临时变量的生存周期就是这条语句 出语句后就会析构
    所以 我们不能用一个指针指向临时变量
    但是 可以用一个const引用指向临时变量
    这是为什么呢？
        临时变量没有名字 出了语句后无法再使用它 所以出语句后就析构
        但是 引用相当于给这块内存（对象）又赋了一个名字
        那么出了语句后 仍然可以使用该对象
        这个临时对象的生命周期 就变成了引用对象的生命周期
*/
    cout << "-----------------" << endl;
/*
    输出：
    ~Test()
    ~Test()
    ~Test()
    ~Test()
    ~Test()
*/
    return 0;
}
```
