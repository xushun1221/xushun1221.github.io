---
title: 【C++基础】06 - 继承与多态
date: 2022-08-20
tags: [C++, STL]
categories: [Coding]
---

## 继承的本质和原理

继承的本质：代码的复用

类和类之间的关系：  
1. 组合：a part of
2. 继承：a kind of

三种继承方式下，派生类对基类成员的访问限定情况：

|继承方式|基类的访问限定|派生类的访问限定(Y/N)|外部的访问限定(Y/N)|
|---|---|---|---|
|public|public|public(Y)|Y|
||protected|protected(Y)|N|
||private|不可见的(N)|N|
|protected|public|protected(Y)|N|
||protected|protected(Y)|N|
||private|不可见的(N)|N|
|private|public|private(Y)|N|
||protected|private(Y)|N|
||private|不可见的(N)|N|

- 公有继承（public）下
  - 基类的public和protected成员在派生类中还是public和protected成员；
  - 基类的private成员在派生类中不可见。
- 保护继承（protected）下
  - 基类的public和protected成员在派生类中都为protected；
  - 基类的private成员在派生类中不可见。
- 私有继承（private）下
  - 基类public和protected成员在派生类中都为private；
  - 基类的private成员在派生类中不可见。

总结：  
- 派生类对基类成员的访问权限，不会超过继承方式；
- 外部只能访问对象的public成员；
- 继承结构中，派生类可以从基类继承来private成员，但是不可直接访问；
- protected和private成员的区别？
  - 在基类中定义的成员，想被派生类访问，但不想被外部访问，就在基类中将其限定为protected；
  - 如果不想成员被派生类和外部访问，就在基类中将其定义为private。

其他注意点：  
- 如果某个类继承自某个派生类，它的访问限定情况由它的直接基类决定；
- 默认的继承方式，由派生类的定义方式决定
  - 使用class定义，默认继承方式为private（class定义类，内部成员的默认限定符也是private）
  - 使用struct定义，默认继承方式为public（struct定义类，内部成员的默认限定符也是public）

## 派生类的构造、析构过程

派生类可以从基类继承所有的成员（变量和方法），除了构造函数和析构函数。

- 派生类的构造和析构函数，负责初始化和清理派生类部分的成员；
- 派生类从基类继承来的成员，由基类的构造和析构函数负责；
- 派生类通过调用基类的构造函数来初始化基类部分的成员；
- 基类的析构函数无需手动调用。

派生类对象的构造和析构过程如下：  
1. 派生类调用基类的构造函数，初始化从基类继承来的成员；
2. 调用派生类自己的构造函数，初始化自己特有的成员；
3. ...派生类对象作用域到期...
4. 调用派生类的析构函数，释放派生类成员占用的资源；
5. 调用基类的析构函数，释放派生类内存中，从基类继承来的成员占用的资源。

示例：　　
```C++
#include <iostream>
class Base {
public:
    Base(int data) : a(data) { std::cout << "Base() &a:" << &a << std::endl; }
    ~Base() { std::cout << "~Base()" << std::endl; }
protected:
    int a;
};
class Derive : public Base {
public:
    // Derive(int data) : a(data), b(data) {} 错误写法 不能在构造函数中给基类成员初始化
    Derive(int data) : Base(data), b(data) { std::cout << "Derive() &b:" << &b << std::endl; }
    ~Derive() { std::cout << "~Derive()" << std::endl; }
private:
    int b;
};
int main() {
    Derive test(10);
    return 0;
}
/* 输出
xushun@xushun-virtual-machine:~/cppmiddle$ ./a.out 
Base() &a:0x7ffcf2a82310
Derive() &b:0x7ffcf2a82314
~Derive()
~Base()
*/
```


## 重载、隐藏、覆盖

这一节讲重载和隐藏，覆盖的内容在下一节虚函数中。

### 重载和隐藏
先说结论：  
- 重载关系：一组函数重载的前提是，它们在**同一个作用域中**，且**函数名相同**，参数列表不同。这里的作用域说的是在同一个类中。
- 隐藏关系（作用域的隐藏）：在继承结构中，派生类的成员，会把基类的同名成员隐藏。

示例：  
```C++
#include <iostream>
class Base {
public:
    Base(int data = 10) : a(data) {}
    void show() { std::cout << "Base::show()" << std::endl; }
    void show(int) { std::cout << "Base::show(int)" << std::endl; }
protected:
    int a;
};
class Derive : public Base {
public:
    Derive(int data = 10) : Base(data), b(data) {}
    void show() { std::cout << "Derive::show()" << std::endl; } // #1
    void show(int) { std::cout << "Derive::show(int)" << std::endl; } // #2
private:
    int b;
};

int main() {
    Derive test;
    test.show();
    test.show(0);
    test.Base::show();
    test.Base::show(0);
    return 0;
}
```
观察上面的代码。

存在两个重载关系：  
1. `Base::show()`和`Base::show(int)`是重载关系，它们同属于`Base::`，函数名相同，参数列表不同；
2. `Derive::show()`和`Derive::show(int)`是重载关系，它们同属于`Derive::`，函数名相同，参数列表不同；

注释掉`#1#2`两行，输出为：  
```console
Base::show()
Base::show(int)
Base::show()
Base::show(int)
```
`Derive::`中没有`show()`和`show(int)`，所以从`Base::`中寻找。

只注释掉`#2`，无法通过编译，输出为：  
```console
inherit.cpp: In function ‘int main()’:
inherit.cpp:22:16: error: no matching function for call to ‘Derive::show(int)’
     test.show(0);
                ^
inherit.cpp:13:10: note: candidate: ‘void Derive::show()’
     void show() { std::cout << "Derive::show()" << std::endl; } // #1
          ^~~~
inherit.cpp:13:10: note:   candidate expects 0 arguments, 1 provided
```
错误提示说明，`Derive::show()`隐藏掉了`Base::show()`和`Base::show(int)`，所以`test.show(int)`时不会在`Base::`中寻找，同时注释掉了`#2`，所以找不到该函数的定义。如果只注释掉`#1`，情况相同，`Derive::show(int)`会隐藏`Derive::`中同名的两个函数（参数列表不同也会被隐藏）。

不注释代码，输出：  
```console
Derive::show()
Derive::show(int)
Base::show()
Base::show(int)
```
不指定作用域的话，优先使用派生类作用域中的成员，隐藏了基类的成员，如果在派生类中没有，才会取寻找基类中继承的成员。如果要使用基类被派生类隐藏的成员，需要使用作用域运算符`Base::`指定。

### 基类和派生类的转换、指针（引用）
> 我们把继承结构说成从上（基类）到下（派生类）的结构。

结论：  
在继承结构中进行上下类型的转换（基类 <->派生类），默认只支持从下到上的转换（基类 <- 派生类）

示例：  
```C++
#include <iostream>
class Base {
public:
    Base(int data = 10) : a(data) {}
protected:
    int a;
};
class Derive : public Base {
public:
    Derive(int data = 10) : Base(data), b(data) {}
private:
    int b;
};

int main() {
    Base b;
    Derive d;
    // 基类对象 <- 派生类对象  从下到上 Y
    b = d;
    // 派生类对象 <- 基类对象  从上到下 N
    //d = b;
    // 基类指针（引用） <- 派生类指针  从下到上 Y
    Base* pb = &d;
    // 派生类指针（引用） <- 基类指针  从下到上 N
    //Derive* pd = &b;
    // 派生类指针不能指向一个基类对象 
    // 因为派生类的内存空间大于基类 派生类指针指向基类对象
    // 会造成内存的非法访问
    Derive* pd = (Derive*)&b; // 这样很危险!
    return 0;
}
```



## 虚函数、静态绑定、动态绑定、覆盖

静态绑定是**编译时期**的函数调用，调用的是普通函数。  
动态绑定是**运行时期**的函数调用，且调用的一定是**虚函数**。

### 静态绑定

示例1：  
```C++
#include <iostream>
#include <typeinfo>
class Base {
public:
    Base(int data = 10) : a(data) {}
    void show() { std::cout << "Base::show()" << std::endl; }
    void show(int) { std::cout << "Base::show(int)" << std::endl; }
protected:
    int a;
};
class Derive : public Base {
public:
    Derive(int data = 10) : Base(data), b(data) {}
    void show() { std::cout << "Derive::show()" << std::endl; }
private:
    int b;
};
int main() {
    Derive d(50);
    Base* pb = &d;
    // 静态（编译阶段）绑定（函数调用）
    pb->show(); // 静态绑定 call Base::show()
    pb->show(0); // 静态绑定 call Base::show(int)
    std::cout << sizeof(Base) << std::endl;
    std::cout << sizeof(Derive) << std::endl;
    std::cout << typeid(pb).name() << std::endl;
    std::cout << typeid(*pb).name() << std::endl;
    return 0;
}
/* 输出
xushun@xushun-virtual-machine:~/cppmiddle$ ./a.out 
Base::show()
Base::show(int)
4
8
P4Base
4Base
*/
```
在上面的代码中，我们使用了`Base*`指针指向一个`Derive`对象，用指针调用函数，编译器就会在`Base::`作用域中寻找函数，如果发现不是虚函数，那么直接调用它（`call`）。这也称**静态绑定**，是在编译阶段进行的函数调用。

再看内存大小，`Base`对象中只有一个`int`成员变量，所以为4字节，`Derive`对象中有从基类继承来的一个`int`和自己的一个`int`，所以8字节。

再看类型，虽然`Base*`类型指针指向的是`Derive`对象，但`*pb`仍被编译器认定为`Base`类型。

### 虚函数、动态绑定、覆盖

示例2：  
```C++
#include <iostream>
#include <typeinfo>
class Base {
public:
    Base(int data = 10) : a(data) {}
    // 定义为虚函数
    virtual void show() { std::cout << "Base::show()" << std::endl; }
    virtual void show(int) { std::cout << "Base::show(int)" << std::endl; }
protected:
    int a;
};
class Derive : public Base {
public:
    Derive(int data = 10) : Base(data), b(data) {}
    // 返回值、函数名、参数列表 都和基类中的虚函数相同
    // 自动定义为虚函数
    void show() { std::cout << "Derive::show()" << std::endl; } // 这是一个虚函数 虽然没用virtual修饰
    // 它覆盖了 Base::show()
private:
    int b;
};
int main() {
    Derive d(50);
    Base* pb = &d;
    pb->show(); // 动态（运行阶段）绑定
    /* 动态绑定 对应的汇编如下
        mov eax, dword ptr[pb]  // 将 d 虚函数指针 放入 eax
        mov ecx, dword ptr[eax] // 将 虚函数指针 指向的函数地址Derive::show() 放入 ecx
        call ecx // 调用虚函数
    */
    pb->show(0); // 动态绑定
    std::cout << sizeof(Base) << std::endl;
    std::cout << sizeof(Derive) << std::endl;
    std::cout << typeid(pb).name() << std::endl;  // pb 还是 Base*
    std::cout << typeid(*pb).name() << std::endl; // *pb 就变为 Derive
    // 如果Base没有虚函数 *pb 就会被识别为编译时期的类型 就是 Base
    // 如果Base有虚函数 *pb 就会被识别为运行时期的类型 就是 RTTI类型 Derive
    return 0;
}
/* 输出
xushun@xushun-virtual-machine:~/cppmiddle$ ./a.out 
Derive::show()
Base::show(int)
16
16
P4Base
6Derive
*/
```

#### vftable虚函数表、RTTI、vptr虚函数指针

当类中定义了虚函数，那么在**编译阶段**，编译器会为这个类类型产生一个**唯一**的**vftable虚函数表**，虚函数表中主要存储的内容是**RTTI指针（Run-Time Type information）**和**虚函数的地址**，RTTI指针可以理解为一个指向类型字符串常量的指针。当程序运行时，每一张虚函数表都会加载到内存的`.rodata`只读数据段中。

`Base`类的vftable虚函数表：（可以使用`g++ -fdump-lang-class virtual.cpp`命令查看类的内存布局）

|地址偏移|内容|
|---|---|
|0|0|
|8|`&RTTI` (指向`"Base"`)|
|16|`&Base::show()` (虚函数的地址)|
|24|`&Base::show(int)`|


当类中定义了虚函数，那么由该类实例化的对象，其内存起始位置会多存储一个**vptr虚函数指针**，指向该类对应的vftable虚函数表的虚函数地址起始位置，例如`Base`类对象的虚函数指针，指向`Base`类虚函数表偏移16位置。多个对象的虚函数指针，指向**同一个**虚函数表。

一个`Base`对象的内存结构：

|地址偏移|内容|
|---|---|
|0|`vptr`（指向`Base`虚函数表偏移16位置）|
|8|`int a`|
|12-16|内存对齐|

这里也可以看出，一个类的虚函数的个数，不影响实例化对象的内存大小，影响的是虚函数表的大小。

#### 虚函数的覆盖

如果基类有虚函数，派生类当然会继承基类的虚函数，那么也有虚函数表。如果一个派生类中的方法，和基类继承来的某个方法，**返回值、函数名、参数列表都相同**，而且基类的方法是virtual虚函数，那么派生类的这个方法，编译器会自动处理为虚函数（编译阶段），并且会将派生类的虚函数表中，原来的基类的虚函数，替换为派生类的对应虚函数。这个动作就叫做虚函数的**覆盖**（重写）。

`Derive`类的虚函数表：

|地址偏移|内容|
|---|---|
|0|0|
|8|`&RTTI`（指向`"Derive"`）|
|16|`&Derive::show()` (`&Base::show()`被覆盖了)|
|24|`&Base::show(int)` (没有重写)|


一个`Derive`对象的内存结构：

|地址偏移|内容|
|---|---|
|0|`vptr`（指向`Derive`虚函数表偏移16位置）|
|8|`int Base::a`|
|12|`int Derive::b`|


#### 动态绑定

参考上面的示例2，当编译到`pb->show();`时，因为`pb`是`Base*`类型的指针，所以进入`Base::`作用域查看，发现`show()`是virtual虚函数，就进行**动态绑定**。过程是：通过`pb`指向的`Derive`对象`d`的虚函数指针`vptr`找到，`Derive`的虚函数表，获得`show()`虚函数的地址（因为`Base::show()`被`Derive::show()`覆盖，所以得到了`Derive::show()`的地址），然后`call`这个地址。

当编译到`pb->show(0);`时，进入`Base::`作用域查看，发现`show(int)`是虚函数，进行动态绑定，在`Derive`虚函数表中找到`show(int)`的地址（没有重写这个函数，所以还是得到了`Base::show()`的地址），`call`之。

动态的含义是，**运行时**进行动态绑定，只有在程序运行时，才会通过虚函数表找到函数，而静态绑定，是在**编译时**就能确定调用的函数。


> 为什么动态绑定要在运行时确定要调用的函数呢？  
> 答：因为，调用虚函数的基类指针，不一定在编译时就能确定指向的对象类型。需要通过对象的vptr虚函数指针，确定对象的类型，并调用正确的虚函数。  
> 例如下面的代码，在编译时期，你能看出`pb`调用的是哪个函数吗？  
> ```C++
> Base* pb = nullptr;
> std::string type;
> std::cin >> type;
> if (type == "Base") {
>   pb = new Base();
> } else {
>   pb = new Derive();
> }
> pb->show();
> ```

其实**绑定**就是确定对象指针应该调用的函数的过程。调用的函数是普通函数，就进行静态绑定，而调用虚函数就进行动态绑定。


## 虚析构函数
