---
title: 【MySQL】23 - 意向锁、死锁、锁的优化建议
date: 2022-11-11
tags: [datebase, MySQL]
categories: [DateBase]
---


## InnoDB表级锁

InnoDB支持行锁，但是不一定每次都会使用行锁，行锁依赖于索引项，如果没有索引，还是使用表锁。

在绝大部分情况下都应该使用行锁，因为事务和行锁往往是选择InnoDB的理由，但个别情况下也使用表级锁。

1. 事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间等待和锁冲突；
2. 事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。

`LOCK TABLE user READ;` 读锁
`LOCK TABLE user WRITE;` 写锁

`COMMIT/ROLLBACK;` 事务提交或回滚
`UNLOCK TABLES;` 本身自带提交事务，释放线程占用的所有表锁


## 表级锁的效率问题

最基本的，要获取一张表的共享锁S或排他锁X，最起码要确定  
1. 这张表没有被其他事务获取过排他锁X；
2. 这张表中的数据没有被其他业务获取过排他锁X（行锁）。

问题来了，如果想要获取一张表的S或X锁，但是表中某些行被其他事务获取了锁，需要对整表进行扫描才能知道那些行被获取了锁，是否可以加锁，效率很低！

这个效率问题就由意向锁来解决。



## 意向共享锁、意向排他锁

意向锁是**表级别**的锁。

- 意向共享锁（IS锁）：事务计划给记录加行共享锁，事务在给一行记录加共享锁前，必须**先取得该表的IS锁**。
- 意向排他锁（IX锁）：事务计划给记录加行排他锁，事务在给一行记录加排他锁前，必须**先取得该表的IX锁**。


表锁的兼容性：

||X|IX|S|IS|
|---|---|---|---|---|
|X|conflict|conflict|conflict|conflict|
|IX|conflict|兼容|conflict|兼容|
|S|conflict|conflict|兼容|兼容|
|IS|conflict|兼容|兼容|兼容|

1. 意向锁是由InnoDB获取行锁之前自行获取的
2. 意向锁之间都是兼容的，不会冲突
3. 意向锁存在的意义是为了，更高效的获取表锁
4. 意向锁是表级锁，协调表锁和行锁的共存关系。主要目的是显示事务正在锁定某行或试图锁定某行。



## 解决获取表锁的效率问题

使用意向锁，如果要获取表的锁时，不需要再检查表中的哪些行被获取了锁（X或S），直接看意向锁（IX或IS）的状态即可。



## 死锁

MyISAM 表锁是 deadlock free 的， 这是因为 MyISAM 总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。

但在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，即锁的粒度比较小，这就决定了在 InnoDB 中发生死锁是可能的。

死锁问题一般都是我们自己的应用造成的，和多线程编程的死锁情况相似，大部分都是由于我们多个线程在获取多个锁资源的时候，**获取的顺序不同**而导致的死锁问题。

因此我们应用在对数据库的多个表做更新的时候，不同的代码段，应对这些表**按相同的顺序进行更新操作**，以防止锁冲突导致死锁问题。


> mysql server 在遇到死锁问题时，不会被阻塞住，因为它可以检测到 deadlock，它会导致其中一个事务的回滚。




## 锁的优化建议


1. 尽量使用较低的隔离级别
2. 设计合理的索引并尽量使用索引访问数据，使加锁更加准确，减少锁冲突的机会提高并发能力
3. 选择合理的事务大小，小事务发生锁冲突的概率小
4. 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会
5. 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响
6. 不要申请超过实际需要的锁级别
7. 除非必须，查询时不要显示加锁 
