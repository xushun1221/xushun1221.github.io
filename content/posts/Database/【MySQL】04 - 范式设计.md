---
title: 【MySQL】04 - 范式设计
date: 2022-10-13
tags: [datebase, MySQL]
categories: [DateBase]
---

## 关系型数据库范式设计

范式设计使用简洁的表述，描述了在数据库设计时需要遵循的一些原则。

使用数据库范式可以带来许多好处，最重要的有三点：  
1. 减少数据冗余（最主要的好处，其他两点由此附带的）
2. 消除异常（插入异常、更新异常、删除异常）
3. 让数据组织更加和谐

> 数据库范式不是越高越好，范式越高，意味着表越多，多表联合查询的几率就变大，SQL的效率就低了。

## 第一范式 1NF

> 每一列都要保持原子特性（不能再拆分）。

列都是基本的数据项，不能够再进行分割，否则需要设计成一对多的实体关系。如下图，应该将地址字段分为更详细的三个字段，不能使用另一张表，这样通过单表查询就能找到想要的数据。

![](/post_images/posts/Database/MySQL/第一范式.jpg "第一范式")

注意，不符合第一范式的不能称作关系型数据库。

## 第二范式 2NF

> 属性完全依赖于主键 - 主要针对联合主键。

非主属性完全依赖于主关键字（非主属性应该完全依赖联合主键的每一个字段），如果不是完全依赖主键，应该拆分为新的实体，设计为一对多的实体关系。

例如这个选课表，`selectcourse(学号,姓名,年龄,课程名称,成绩,学分)`，`(学号,课程名称)`是联合主键。

姓名、年龄和课程名称无关，学分之和课程名称有关，和学号无关。不满足第二范式，分析：  
- 不同学生可以选择相同的课程，而课程的学分不会因为选课人的不同而改变，使用上面的表设计，必然导致学分存储冗余；
- 同一个学生可以选多个课程，而学生的姓名和年龄是不会变的，那么姓名和年龄也存在冗余。

学生和课程之间的关系，应该为多对多。所以，我们使用学生表（学号，姓名，年龄）、课程表（课程id，课程名，学分）、选课表（学号，课程id，成绩），这三张表来实现。

另一个例子，如下图，人员姓名、住址等信息不依赖于联合主键中的部门名称，所以部门的相关信息应该拆分出来。

![](/post_images/posts/Database/MySQL/第二范式.jpg "第二范式")


## 第三范式

> 属性不依赖于其他非主属性。

一个数据库表中不能包含已经再其他表中包含的非主关键字信息。

例如，学生关系表`student(学号,姓名,年龄,所在学院,学院地点,学院电话)`，学号是主键。

学院地点、学院电话并不依赖于主键学号，而是依赖于所在学院，所以该表不满足第三范式。应该将学院专门设计为一张表，学生和学院是一对多的关系。

另一个例子，如下图，员工的工作描述，并不依赖于员工号，而是依赖于员工的工作职位job，所以不满足第三范式，需要将job单独使用一张表，员工表中存job即可。

![](/post_images/posts/Database/MySQL/第三范式.jpg "第三范式")

> 注意，这里的冗余并不一定需要被杜绝，符合第三范式意味着要使用多表，在多表查询时导致性能降低，有时可能会允许一定的冗余存在，以提高查询效率。


> 一般的关系型数据库满足第三范式即可，更高级的范式可能导致性能损耗高于范式带来的收益，需要仔细衡量。


## BC范式

> 每个表中只有一个候选键。

简单的说，BC范式时第三范式基础上的一种特殊情况，即每个表中只有一个候选键（表中每行的值都不相同，称为候选键），也就是说，BC范式要求表中，除主键外，不能有其他属性是候选键。

如下图，noNF表中，每个员工的email都是唯一的，不可能两个人有相同的email，所以不符合BC范式，需要将email拆分到另一张表。

![](/post_images/posts/Database/MySQL/BC范式.jpg "BC范式")



## 第四范式

> 消除表中的多值依赖。

简单来说，就是是消除表中的多值依赖，也就是说可以减少维护数据一致性的工作。

如下图，noNF表中skill这个字段，有的人是`java,mysql`，有的人是`java,MySQL`，这样数据就不一致了，解决方法是将多值属性放入一个新表。

![](/post_images/posts/Database/MySQL/第四范式.jpg "第四范式")

这里的skill表是这样：

|skill|employeeID|
|---|---|
|C++|1020|
|MySQL|1020|
|C++|2010|
|JAVA|2010|
|GOlang|1020|


## 总结

不难看出，应用的范式越高，表越多，也会带来一些问题：  
1. 查询时需要连接多个表，增加了SQL查询的复杂度
2. 查询时需要连接多个表，降低了数据库查询性能

因此，范式不是越高越好，应该视情况而定。第三范式已经很大程度上减少了数据冗余，并且基本预防了数据插入异常、更新异常和删除异常了。