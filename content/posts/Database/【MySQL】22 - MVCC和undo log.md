---
title: 【MySQL】22 - MVCC和undo log
date: 2022-11-10
tags: [datebase, MySQL]
categories: [DateBase]
---

## 已提交读和可重复读的实现原理

之前几篇已经分析了未提交读和串行化的实现原理，未提交读相当于没有做任何的并发控制，串行化完全使用共享锁、排他锁、间隙锁等，数据安全性、一致性最高，但是并发度最低。

对于其他两个隔离级别：已提交读、可重复读，它们的底层实现依赖于：**MVCC（Multi-Version Concurrency Control）多版本并发控制机制**。

MVCC提供的最重要的功能是，**快照读**，一种并发读取方式。（就像在某个时刻，对数据拍了张照片，不管数据怎么变，访问的都是照片里的数据一样）

实际上，InnoDB提供了两种读取操作，一种是之前提到的**锁定读**，读取数据之前，需要使用共享锁或排他锁锁定数据，另一种**非锁定读**，就是MVCC提供的快照读。

快照读方法依赖的底层技术是：**undo log 回滚日志**。



## undo log 简述

undo log：回滚日志，保存了事务发生之前的数据的一个版本，用于事务执行时的回滚操作，同时也是实现多版本并发控制（MVCC）下快照读操作的关键技术。

undo log 示意图：

![](/post_images/posts/Database/MySQL/undolog.jpg "undo log")

- `DB_TRX_ID`：事务id
- `DB_ROLL_PTR`：回滚指针，指向数据的上一个版本（在undo log中的）
- `DB_ROW_ID`：InnoDB中，如果没有给表定义主键，它会用该字段作为默认主键

如果要在某张表中修改某一行的数据，首先会将原始数据加入undo log中，修改该行的`DB_TRX_ID`和`DB_ROLL_PTR`指向undo log中的原始数据节点。再次修改时，会将当前行加入undo log，同样修改指针，此时就形成了一个三个节点的链表。

如果要插入一行新数据，首先会在undo log中生成一个空节点，然后当前行的指针，指向该空节点。


## MVCC 快照读

MVCC是多版本并发控制（Multi-Version Concurrency Control，简称MVCC），是MySQL中基于乐观锁理论实现隔离级别的方式，用于实现已提交读和可重复读隔离级别的实现，也经常称为多版本数据库。MVCC机制会生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本（系统版本号和事务版本号）。

MVCC中的读操作可以分为两类：  
1. 快照读（snapshot read）（非锁定读），读的是记录的可见版本，不用加锁，如select；
2. 当前读（current read）（锁定读），读取的是记录的最新版本，并且当前读返回的记录。如insert、delete、update、select...lock in share mode、for update。


快照内容读取原则：  
1. 版本未提交，无法生成快照
2. 版本已提交，但是在快照创建后提交的，无法读取
3. 版本已提交，但是在快照创建前提交的，可以读取
4. 当前事务内自己的更新，可以读到



## 已提交读  解决脏读

脏读，简单说就是一个事务对数据的修改尚未提交时，另一个事务读取了这个事务未提交的修改，而未提交修改可能rollback，导致一致性错误。

在已提交读隔离级别下，脏读被解决了，原理简述如下：  
在已提交读级别下，对数据的读取，使用的是**非锁定读**，没有对数据进行加锁（S、X锁），而是使用MVCC提供的**快照读**。事务**每一次select**时，都会对被查询的数据生成快照，生成数据快照的前提，就是数据的状态必须时**committed已提交的**。其他事务对数据的修改在未提交状态下，不会被生成快照，快照使用的仍是已提交的老数据。

### 无法解决  不可重复读

已提交读级别下，可以阻止未提交状态数据的脏读，但是仍然会出现不可重复读的现象。原因是，每一次select都会重新产生一次数据快照。其他事务更新并提交后的数据，可以实时反馈到当前事务的select结果中。

### 无法解决  幻读

原因和不可重复读相同，每次select都会重新生成快照，其他事务插入或删除的数据（已提交），当然可以反馈到当前事务的查询结果中。


## 可重复读  解决脏读、不可重复读

解决脏读的原因同样是，使用快照读。

在可重复读级别下，解决不可重复读现象的原理：  
可重复读级别下，当前事务**第一次select**产生数据快照，而且**只产生一次**数据快照。在此过程中，其他事务虽然更新了数据（无论是否提交），当前事务依然在第一次select产生的数据快照上进行select查询。所以看不到其他事务对数据的更新。


## 可重复读  部分解决幻读

在可重复读级别下，幻读的现象有两种情况：  
1. 在当前事务中，进行select查询时，其他事务插入或删除的数据记录不会反馈到当前事务查询结果中；
2. 在另一个事务中添加了一个数据记录（提交了），如果在当前事务中，使用update更新了刚刚添加的记录，再次select查询时，就会将其查询到。产生幻读了。

所以我们说，可重复读级别**部分**解决了幻读问题。

仅select不会幻读的原因：  
当前事务如果仅进行select，使用**快照读**，它查询的是第一次select时生成的数据快照，自然不会看到其他事务添加的记录。

update更新了其他事务插入的数据，为什么会幻读？原因如下：  
当前事务使用update进行更新时，用的是**当前读**来查询记录！而不是在快照上匹配。所以当前事务，可以更新其他事务插入的记录。在当前事务进行select查询时，它不仅能看见快照上的记录，**还能看见自己进行过更新的记录**（事务快照读的原则），所以更新后进行查询时，就可以看到其他事务插入的记录。这也是幻读的情况。

当前事务是怎么看到自己的更新呢？因为`DB_TRX_ID`事务号记录了进行更新的事务。