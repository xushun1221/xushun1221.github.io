<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>【C++高级】01 - 对象优化&右值引用优化 | XuShun's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="XuShun的个人博客，记录学习和生活。"><link rel=prev href=https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo01-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-muduo/><link rel=canonical href=https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A701-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="【C++高级】01 - 对象优化&右值引用优化"><meta name=twitter:description content="对象使用中调用了哪些函数？（构造、析构、拷贝、赋值） 对象函数调用过程 - 示例1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【C\x2b\x2b高级】01 - 对象优化\x26右值引用优化","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xushun1221.github.io\/2022\/c-%E9%AB%98%E7%BA%A701-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96\/"},"image":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"C\x2b\x2b","wordcount":3376,"url":"https:\/\/xushun1221.github.io\/2022\/c-%E9%AB%98%E7%BA%A701-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96\/","datePublished":"2022-09-08T00:00:00\x2b00:00","dateModified":"2022-09-08T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xushun","logo":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">【C++高级】01 - 对象优化&右值引用优化</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2022-09-08>2022-09-08</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 3376 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://xushun1221.github.io/categories/coding/>Coding</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#对象使用中调用了哪些函数构造析构拷贝赋值>对象使用中调用了哪些函数？（构造、析构、拷贝、赋值）</a><ul><li><a href=#对象函数调用过程---示例1>对象函数调用过程 - 示例1</a></li><li><a href=#对象函数调用过程---示例2>对象函数调用过程 - 示例2</a></li></ul></li><li><a href=#函数调用过程中对象背后调用的方法太多>函数调用过程中对象背后调用的方法太多！</a></li><li><a href=#三条对象优化的规则>三条对象优化的规则</a></li><li><a href=#mystring-存在的问题>MyString 存在的问题</a></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#对象使用中调用了哪些函数构造析构拷贝赋值>对象使用中调用了哪些函数？（构造、析构、拷贝、赋值）</a><ul><li><a href=#对象函数调用过程---示例1>对象函数调用过程 - 示例1</a></li><li><a href=#对象函数调用过程---示例2>对象函数调用过程 - 示例2</a></li></ul></li><li><a href=#函数调用过程中对象背后调用的方法太多>函数调用过程中对象背后调用的方法太多！</a></li><li><a href=#三条对象优化的规则>三条对象优化的规则</a></li><li><a href=#mystring-存在的问题>MyString 存在的问题</a></li></ul></nav></div></details></div><div class=post-content><a class=post-dummy-target id=对象使用中调用了哪些函数构造析构拷贝赋值></a><h2>对象使用中调用了哪些函数？（构造、析构、拷贝、赋值）</h2><a class=post-dummy-target id=对象函数调用过程---示例1></a><h3>对象函数调用过程 - 示例1</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-C++ data-lang=C++><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>

<span class=k>class</span> <span class=nc>Test</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>Test</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>)</span> <span class=o>:</span> <span class=n>_ma</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Test(int)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
    <span class=o>~</span><span class=n>Test</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>~Test()</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
    <span class=n>Test</span><span class=p>(</span><span class=k>const</span> <span class=n>Test</span><span class=o>&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=o>:</span> <span class=n>_ma</span><span class=p>(</span><span class=n>t</span><span class=p>.</span><span class=n>_ma</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Test(const Test&amp;)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
    <span class=n>Test</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Test</span><span class=o>&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>_ma</span> <span class=o>=</span> <span class=n>t</span><span class=p>.</span><span class=n>_ma</span><span class=p>;</span>
        <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>operator=(cosnt Test&amp;)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
    <span class=p>}</span>
<span class=k>private</span><span class=o>:</span>
    <span class=kt>int</span> <span class=n>_ma</span><span class=p>;</span>
<span class=p>}</span><span class=p>;</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>Test</span> <span class=n>t1</span><span class=p>;</span>            <span class=c1>// 默认构造
</span><span class=c1></span>    <span class=n>Test</span> <span class=n>t2</span><span class=p>(</span><span class=n>t1</span><span class=p>)</span><span class=p>;</span>        <span class=c1>// 拷贝构造
</span><span class=c1></span>    <span class=n>Test</span> <span class=n>t3</span> <span class=o>=</span> <span class=n>t1</span><span class=p>;</span>       <span class=c1>// 拷贝构造 不是赋值重载
</span><span class=c1></span>    <span class=n>Test</span> <span class=n>t4</span> <span class=o>=</span> <span class=n>Test</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 普通构造 相当于 Test t4(20);
</span><span class=c1></span><span class=cm>/* #1
</span><span class=cm>    输出：
</span><span class=cm>    Test(int)
</span><span class=cm>    Test(const Test&amp;)
</span><span class=cm>    Test(const Test&amp;)
</span><span class=cm>    Test(int)
</span><span class=cm>
</span><span class=cm>    Test(20); 意为显示生成一个临时对象
</span><span class=cm>    临时对象的生存周期 仅为当前的语句 出语句后就析构
</span><span class=cm>    那么 朴素的想法是 Test t4 = Test(20);
</span><span class=cm>        1. 首先调用构造生成一个临时对象 Test(int)
</span><span class=cm>        2. 然后调用拷贝构造生成对象t4 Test(const Test&amp;)
</span><span class=cm>        3. 最后出语句调用临时对象的析构 ~Test()
</span><span class=cm>    但是事实并非如此 测试结果表明
</span><span class=cm>    Test t4 = Test(20); 该语句仅调用了普通的构造函数 Test(int)
</span><span class=cm>
</span><span class=cm>    这是C++ 编译器提供的优化
</span><span class=cm>    当我们使用临时对象生成一个新对象时 C++编译器会优化这一过程
</span><span class=cm>    不会构造临时对象并调用拷贝构造 而是直接构造新对象
</span><span class=cm>*/</span>
    <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>-----------------</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>

    <span class=n>t4</span> <span class=o>=</span> <span class=n>t2</span><span class=p>;</span>        <span class=c1>// 赋值重载
</span><span class=c1></span>    <span class=n>t4</span> <span class=o>=</span> <span class=n>Test</span><span class=p>(</span><span class=mi>30</span><span class=p>)</span><span class=p>;</span>  <span class=c1>// 赋值重载  
</span><span class=c1></span><span class=cm>/* #2
</span><span class=cm>    输出：
</span><span class=cm>    operator=(cosnt Test&amp;)
</span><span class=cm>    Test(int)
</span><span class=cm>    operator=(cosnt Test&amp;)
</span><span class=cm>    ~Test()
</span><span class=cm>
</span><span class=cm>    该语句一定会产生临时对象 
</span><span class=cm>    因为t4已经存在了 而非需要构造
</span><span class=cm>    需要先后调用 1.临时对象构造 2.赋值重载 3.临时对象析构
</span><span class=cm>*/</span>
    <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>-----------------</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>

    <span class=n>t4</span> <span class=o>=</span> <span class=p>(</span><span class=n>Test</span><span class=p>)</span><span class=mi>30</span><span class=p>;</span> <span class=c1>// 赋值重载  显式Test &lt;- int 构造函数Test(int) 
</span><span class=c1></span>    <span class=n>t4</span> <span class=o>=</span> <span class=mi>30</span><span class=p>;</span>       <span class=c1>// 赋值重载  隐式Test &lt;- int 构造函数Test(int) 
</span><span class=c1></span><span class=cm>/* #3
</span><span class=cm>    输出： 
</span><span class=cm>    Test(int)
</span><span class=cm>    operator=(cosnt Test&amp;)
</span><span class=cm>    ~Test()
</span><span class=cm>    Test(int)
</span><span class=cm>    operator=(cosnt Test&amp;)
</span><span class=cm>    ~Test()
</span><span class=cm>
</span><span class=cm>    当其他类型想要转换为某个类类型时
</span><span class=cm>    编译器会检查该类是否有合适的构造函数
</span><span class=cm>    例如 这里Test类有带有int参数的构造函数 Test(int)
</span><span class=cm>    所以 t4 = (Test)30; t4 = 30; 中的显式和隐式类型转换都可以成功
</span><span class=cm>    由于 t4 对象已经存在 所以需要构造临时对象
</span><span class=cm>        1.构造函数 生成临时对象 2.调用赋值重载 3.在离开语句时 临时对象析构
</span><span class=cm>*/</span>
    <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>-----------------</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>

    <span class=c1>// Test* p = &amp;Test(40);     // 错误写法 对象指针不能指向一个临时变量
</span><span class=c1></span>    <span class=k>const</span> <span class=n>Test</span><span class=o>&amp;</span> <span class=n>ref</span> <span class=o>=</span> <span class=n>Test</span><span class=p>(</span><span class=mi>50</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 正确写法 const对象引用 可以指向一个临时变量 (必须使用const引用才能指向临时对象 普通引用不行）
</span><span class=c1></span><span class=cm>/* #4
</span><span class=cm>    输出：
</span><span class=cm>    Test(int)
</span><span class=cm>
</span><span class=cm>    从之前的分析可以知道 临时变量的生存周期就是这条语句 出语句后就会析构
</span><span class=cm>    所以 我们不能用一个指针指向临时变量
</span><span class=cm>    但是 可以用一个const引用指向临时变量
</span><span class=cm>    这是为什么呢？
</span><span class=cm>        临时变量没有名字 出了语句后无法再使用它 所以出语句后就析构
</span><span class=cm>        但是 引用相当于给这块内存（对象）又赋了一个名字
</span><span class=cm>        那么出了语句后 仍然可以使用该对象
</span><span class=cm>        这个临时对象的生命周期 就变成了引用对象的生命周期
</span><span class=cm>*/</span>
    <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>-----------------</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>
<span class=cm>/*
</span><span class=cm>    输出：
</span><span class=cm>    ~Test()
</span><span class=cm>    ~Test()
</span><span class=cm>    ~Test()
</span><span class=cm>    ~Test()
</span><span class=cm>    ~Test()
</span><span class=cm>*/</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=对象函数调用过程---示例2></a><h3>对象函数调用过程 - 示例2</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-C++ data-lang=C++><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>

<span class=k>class</span> <span class=nc>Test</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>Test</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>5</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>5</span><span class=p>)</span> <span class=o>:</span> <span class=n>_ma</span><span class=p>(</span><span class=n>a</span><span class=p>)</span><span class=p>,</span> <span class=n>_mb</span><span class=p>(</span><span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Test(int, int)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
    <span class=cm>/* Test()    Test(int)    Test(int, int)    这三种都可以*/</span>
    <span class=o>~</span><span class=n>Test</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>~Test()</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
    <span class=n>Test</span><span class=p>(</span><span class=k>const</span> <span class=n>Test</span><span class=o>&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=o>:</span> <span class=n>_ma</span><span class=p>(</span><span class=n>t</span><span class=p>.</span><span class=n>_ma</span><span class=p>)</span><span class=p>,</span> <span class=n>_mb</span><span class=p>(</span><span class=n>t</span><span class=p>.</span><span class=n>_mb</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Test(const Test&amp;)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
    <span class=n>Test</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Test</span><span class=o>&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>_ma</span> <span class=o>=</span> <span class=n>t</span><span class=p>.</span><span class=n>_ma</span><span class=p>;</span>
        <span class=n>_mb</span> <span class=o>=</span> <span class=n>t</span><span class=p>.</span><span class=n>_mb</span><span class=p>;</span>
        <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>operator=(const Test&amp;)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
    <span class=p>}</span>
<span class=k>private</span><span class=o>:</span>
    <span class=kt>int</span> <span class=n>_ma</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>_mb</span><span class=p>;</span>
<span class=p>}</span><span class=p>;</span>

<span class=n>Test</span> <span class=nf>t1</span> <span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span><span class=p>;</span> <span class=c1>// #1 普通构造 Test(int, int)
</span><span class=c1></span><span class=cm>/* 
</span><span class=cm>    程序运行时 全局变量先进行构造
</span><span class=cm>    全局变量在main函数之前就要进行构造
</span><span class=cm>*/</span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>

    <span class=n>Test</span> <span class=n>t2</span><span class=p>(</span><span class=mi>20</span><span class=p>,</span> <span class=mi>20</span><span class=p>)</span><span class=p>;</span>     <span class=c1>// #3 普通构造 Test(int, int)
</span><span class=c1></span>    <span class=n>Test</span> <span class=n>t3</span> <span class=o>=</span> <span class=n>t2</span><span class=p>;</span>        <span class=c1>// #4 拷贝构造 Test(const Test&amp;)
</span><span class=c1></span>    <span class=k>static</span> <span class=n>Test</span> <span class=n>t4</span> <span class=o>=</span> <span class=n>Test</span><span class=p>(</span><span class=mi>30</span><span class=p>,</span> <span class=mi>30</span><span class=p>)</span><span class=p>;</span>  <span class=c1>// #5 普通构造 相当于 static Test t4(30, 30);
</span><span class=c1></span>    <span class=cm>/*
</span><span class=cm>        上面说过 临时对象拷贝构造新对象会被优化为直接构造新对象
</span><span class=cm>        static 修饰的变量 在程序开始时就在数据段分配了内存
</span><span class=cm>        直到运行到该语句时 才会进行对象构造
</span><span class=cm>        数据段上的对象 在程序运行结束后才析构
</span><span class=cm>    */</span>
    <span class=n>t2</span> <span class=o>=</span> <span class=n>Test</span><span class=p>(</span><span class=mi>40</span><span class=p>,</span> <span class=mi>40</span><span class=p>)</span><span class=p>;</span>      <span class=c1>// #6 赋值重载 生成了临时对象 Test(int, int) operator=(const Test&amp;) ~Test()
</span><span class=c1></span>    <span class=n>t2</span> <span class=o>=</span> <span class=p>(</span><span class=n>Test</span><span class=p>)</span><span class=p>(</span><span class=mi>50</span><span class=p>,</span> <span class=mi>50</span><span class=p>)</span><span class=p>;</span>    <span class=c1>// #7 赋值重载 生成了临时对象 Test(int) operator=(const Test&amp;) ~Test()
</span><span class=c1></span>    <span class=cm>/* 
</span><span class=cm>        t2 = (Test)(50, 50); 等号右边有两个部分
</span><span class=cm>        (50, 50) 是一个逗号表达式 逗号表达式的值是表达式中最后一个表达式的值 这里就是50
</span><span class=cm>        (Test) 是强制类型转换
</span><span class=cm>        所以该语句相当于 t2 = (Test)50; 将50转换为 Test 类型的对象
</span><span class=cm>        编译器可以找到这样的构造函数 Test(int)
</span><span class=cm>    */</span>
    <span class=n>t2</span> <span class=o>=</span> <span class=mi>60</span><span class=p>;</span> <span class=c1>// #8 赋值重载 生成了临时对象 Test(int) operator=(const Test&amp;) ~Test()
</span><span class=c1></span>    <span class=cm>/* 和 #7 一样 */</span>
    <span class=n>Test</span><span class=o>*</span> <span class=n>p1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Test</span><span class=p>(</span><span class=mi>70</span><span class=p>,</span> <span class=mi>70</span><span class=p>)</span><span class=p>;</span>    <span class=c1>// #9 Test(int, int)
</span><span class=c1></span>    <span class=cm>/*
</span><span class=cm>        new 构造的是堆上对象 不是临时对象
</span><span class=cm>        堆上对象 只有在delete时 才会析构
</span><span class=cm>    */</span>
    <span class=n>Test</span><span class=o>*</span> <span class=n>p2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Test</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=p>;</span>         <span class=c1>// #10 堆上对象数组 Test() Test()
</span><span class=c1></span>    <span class=cm>/* 数组中每个对象都要构造 */</span>
    <span class=c1>// Test* p3 = &amp;Test(80, 90);    // #11 错误写法 
</span><span class=c1></span>    <span class=cm>/* 指针不能指向临时对象 */</span>
    <span class=k>const</span> <span class=n>Test</span><span class=o>&amp;</span> <span class=n>p4</span> <span class=o>=</span> <span class=n>Test</span><span class=p>(</span><span class=mi>90</span><span class=p>,</span> <span class=mi>90</span><span class=p>)</span><span class=p>;</span>  <span class=c1>// #12 Test(int, int)
</span><span class=c1></span>    <span class=cm>/* const引用指向的临时对象 语句结束后不会立即析构 */</span>
    <span class=k>delete</span> <span class=n>p1</span><span class=p>;</span>   <span class=c1>// #13 ~Test()
</span><span class=c1></span>    <span class=k>delete</span><span class=p>[</span><span class=p>]</span> <span class=n>p2</span><span class=p>;</span> <span class=c1>// #14 ~Test() ~Test()
</span><span class=c1></span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
<span class=n>Test</span> <span class=nf>t5</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span><span class=p>;</span> <span class=c1>// #2 普通构造 Test(int, int)
</span><span class=c1></span><span class=cm>/* 虽然写在main后面 但仍然先于main进行构造 */</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=函数调用过程中对象背后调用的方法太多></a><h2>函数调用过程中对象背后调用的方法太多！</h2><p>示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-C++ data-lang=C++><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>

<span class=k>class</span> <span class=nc>Test</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>Test</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>)</span> <span class=o>:</span> <span class=n>_ma</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Test(int)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
    <span class=o>~</span><span class=n>Test</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>~Test()</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
    <span class=n>Test</span><span class=p>(</span><span class=k>const</span> <span class=n>Test</span><span class=o>&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=o>:</span> <span class=n>_ma</span><span class=p>(</span><span class=n>t</span><span class=p>.</span><span class=n>_ma</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Test(const Test&amp;)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span><span class=p>}</span>
    <span class=n>Test</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Test</span><span class=o>&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span> 
        <span class=n>_ma</span> <span class=o>=</span> <span class=n>t</span><span class=p>.</span><span class=n>_ma</span><span class=p>;</span> 
        <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>operator=(const Test&amp;)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=kt>int</span> <span class=nf>getData</span><span class=p>(</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>_ma</span><span class=p>;</span> <span class=p>}</span>
<span class=k>private</span><span class=o>:</span>
    <span class=kt>int</span> <span class=n>_ma</span><span class=p>;</span>
<span class=p>}</span><span class=p>;</span>

<span class=n>Test</span> <span class=nf>getObject</span><span class=p>(</span><span class=n>Test</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>   <span class=c1>// #3 拷贝构造 Test(const Test&amp;)
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>val</span> <span class=o>=</span> <span class=n>t</span><span class=p>.</span><span class=n>getData</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=n>Test</span> <span class=n>tmp</span><span class=p>(</span><span class=n>val</span><span class=p>)</span><span class=p>;</span>  <span class=c1>// #4 Test(int)
</span><span class=c1></span>    <span class=k>return</span> <span class=n>tmp</span><span class=p>;</span>  <span class=c1>// 函数返回的对象也需要仔细分析
</span><span class=c1></span>    <span class=cm>/*
</span><span class=cm>        tmp 是在 getObject 函数栈帧上的一个对象 （局部的对象）
</span><span class=cm>        getObject 函数执行完成后 tmp 对象就被析构了
</span><span class=cm>        它不能被直接带回到 main 函数中
</span><span class=cm>
</span><span class=cm>        这里的做法是：
</span><span class=cm>            #5 Test(const Test&amp;)
</span><span class=cm>            在 main 函数栈帧中构造一个临时对象 （通过对 tmp 对象的拷贝构造）
</span><span class=cm>
</span><span class=cm>        返回的对象构造完成后 还要把 getObject 函数栈帧中的对象进行析构
</span><span class=cm>        #6 ~Test() tmp 析构
</span><span class=cm>        #7 ~Test() 形参 t 析构
</span><span class=cm>
</span><span class=cm>        至此 getObject 函数执行完成
</span><span class=cm>    */</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>

    <span class=n>Test</span> <span class=n>t1</span><span class=p>;</span>  <span class=c1>// #1 Test(int)
</span><span class=c1></span>    <span class=n>Test</span> <span class=n>t2</span><span class=p>;</span>  <span class=c1>// #2 Test(int)
</span><span class=c1></span>    <span class=n>t2</span> <span class=o>=</span> <span class=n>getObject</span><span class=p>(</span><span class=n>t1</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 函数调用过程需要仔细分析
</span><span class=c1></span>    <span class=cm>/*
</span><span class=cm>        1. 对象实参传递给形参的过程是 *初始化* 的过程
</span><span class=cm>            t1 是一个已经存在的对象而 形参是正在构造的对象 
</span><span class=cm>            所以这是一个构造过程 需要调用拷贝构造函数进行构造
</span><span class=cm>        2. getObject 函数执行完成后
</span><span class=cm>            main 函数栈帧中就构造了函数返回的临时对象
</span><span class=cm>            然后使用该临时对象 给 t2 赋值
</span><span class=cm>            #8 operator=(const Test&amp;)
</span><span class=cm>        3. 赋值完成后 该语句结束 临时对象也要被析构
</span><span class=cm>            #9 ~Test()
</span><span class=cm>    */</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=c1>// #10 ~Test() t2 析构
</span><span class=c1></span>    <span class=c1>// #11 ~Test() t1 析构
</span><span class=c1></span><span class=p>}</span>

<span class=cm>/*
</span><span class=cm>我的g++编译器输出的结果是这样的
</span><span class=cm>和上面的分析有一个地方不一样
</span><span class=cm>可能编译器进行了优化
</span><span class=cm>
</span><span class=cm>xushun@xushun-virtual-machine:~/cppadvanced$ g++ objtest3.cpp &amp;&amp; ./a.out
</span><span class=cm>Test(int)
</span><span class=cm>Test(int)
</span><span class=cm>Test(const Test&amp;)
</span><span class=cm>Test(int)
</span><span class=cm>operator=(const Test&amp;)   [这里没有在main函数栈帧上构造临时对象 而是直接将tmp对象赋值给t2]
</span><span class=cm>~Test()
</span><span class=cm>~Test()
</span><span class=cm>~Test()
</span><span class=cm>~Test()
</span><span class=cm>*/</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=三条对象优化的规则></a><h2>三条对象优化的规则</h2><ol><li>函数参数传递过程中，对象应该<strong>按引用传递</strong>，不要按值传递；</li><li>函数返回对象的时候，应该<strong>返回一个临时对象</strong>，不要返回一个定义过的对象；</li><li>接收返回值是对象的函数调用的时候，应该<strong>按初始化的方式接收</strong>，不要按赋值的方式接收。</li></ol><p>注意，下面这句话非常重要！</p><blockquote><p>用临时对象，拷贝构造一个新对象时，编译器会跳过构造临时对象的过程，直接构造新对象。</p></blockquote><p>示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-C++ data-lang=C++><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>

<span class=k>class</span> <span class=nc>Test</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>Test</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>)</span> <span class=o>:</span> <span class=n>_ma</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Test(int)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
    <span class=o>~</span><span class=n>Test</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>~Test()</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
    <span class=n>Test</span><span class=p>(</span><span class=k>const</span> <span class=n>Test</span><span class=o>&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=o>:</span> <span class=n>_ma</span><span class=p>(</span><span class=n>t</span><span class=p>.</span><span class=n>_ma</span><span class=p>)</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>Test(const Test&amp;)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span><span class=p>}</span>
    <span class=n>Test</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Test</span><span class=o>&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span> 
        <span class=n>_ma</span> <span class=o>=</span> <span class=n>t</span><span class=p>.</span><span class=n>_ma</span><span class=p>;</span> 
        <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>operator=(const Test&amp;)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=kt>int</span> <span class=nf>getData</span><span class=p>(</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>_ma</span><span class=p>;</span> <span class=p>}</span>
<span class=k>private</span><span class=o>:</span>
    <span class=kt>int</span> <span class=n>_ma</span><span class=p>;</span>
<span class=p>}</span><span class=p>;</span>

<span class=c1>// Test getObject(Test t) {
</span><span class=c1></span><span class=n>Test</span> <span class=nf>getObject</span><span class=p>(</span><span class=n>Test</span><span class=o>&amp;</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>   <span class=c1>// 函数传参 对象应*按引用传递*
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>val</span> <span class=o>=</span> <span class=n>t</span><span class=p>.</span><span class=n>getData</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=cm>/* Test tmp(val);
</span><span class=cm>    return tmp; */</span>
    <span class=k>return</span> <span class=n>Test</span><span class=p>(</span><span class=n>val</span><span class=p>)</span><span class=p>;</span>
    <span class=cm>/*
</span><span class=cm>        原来返回一个定义过的对象 需要在 main 函数栈帧中构造一个临时对象
</span><span class=cm>        并由要返回的对象进行拷贝构造
</span><span class=cm>
</span><span class=cm>        现在返回的是一个临时对象
</span><span class=cm>        我们要 *用临时对象拷贝构造一个新对象（在main栈帧中的临时对象）*
</span><span class=cm>        编译器会跳过构造临时对象的过程 而直接构造新对象
</span><span class=cm>
</span><span class=cm>        这里没有生成临时对象 也自然不需要进行析构
</span><span class=cm>        形参 t 按引用传递 也不需要进行析构
</span><span class=cm>    */</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>

    <span class=n>Test</span> <span class=n>t1</span><span class=p>;</span>    <span class=c1>// #1 Test(int)
</span><span class=c1></span>    <span class=cm>/* Test t2;
</span><span class=cm>    t2 = getObject(t1); */</span>
    <span class=n>Test</span> <span class=n>t2</span> <span class=o>=</span> <span class=n>getObject</span><span class=p>(</span><span class=n>t1</span><span class=p>)</span><span class=p>;</span>  <span class=c1>// 应该按初始化的方式接收函数返回的对象
</span><span class=c1></span>    <span class=cm>/*
</span><span class=cm>        1. t1 按引用传递 不需要进行拷贝构造
</span><span class=cm>        2. 原来用给一个已经定义的对象赋值的方式接收 函数返回的对象时
</span><span class=cm>            需要在 main 的栈帧中 构造一个临时对象 再进行赋值
</span><span class=cm>            现在 我们使用 初始化方式 接收 返回的对象
</span><span class=cm>            由于*用 main 栈帧中新构造的临时对象 构造一个新对象（t2）*
</span><span class=cm>            编译器会跳过 构造临时对象的过程（不会在 main 栈帧中构造临时对象）
</span><span class=cm>            而是从 return Test(val); 语句处 直接构造 t2 对象
</span><span class=cm>            （实际上 在函数实参压栈时 t2 的地址也作为参数进行压栈了 这样 getObject 函数才能直接构造 t2 对象）
</span><span class=cm>    */</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=c1>// #3 ~Test()  t2
</span><span class=c1></span>    <span class=c1>// #4 ~Test()  t1
</span><span class=c1></span><span class=p>}</span>

<span class=cm>/* 输出
</span><span class=cm>从程序输出可以看出 程序调用的函数大幅减少了 性能得到了很好的优化
</span><span class=cm>
</span><span class=cm>xushun@xushun-virtual-machine:~/cppadvanced$ g++ objtest4.cpp &amp;&amp; ./a.out
</span><span class=cm>Test(int)
</span><span class=cm>Test(int)
</span><span class=cm>~Test()
</span><span class=cm>~Test()
</span><span class=cm>*/</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=mystring-存在的问题></a><h2>MyString 存在的问题</h2><p>分析<code>MyString</code>类的实现，分析内存使用效率问题。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-C++ data-lang=C++><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;cstring&gt;</span><span class=cp>
</span><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>

<span class=k>class</span> <span class=nc>MyString</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>MyString</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>MyString(const char*)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>str</span> <span class=o>!</span><span class=o>=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>_mptr</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>strlen</span><span class=p>(</span><span class=n>str</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span><span class=p>;</span>
            <span class=n>strcpy</span><span class=p>(</span><span class=n>_mptr</span><span class=p>,</span> <span class=n>str</span><span class=p>)</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>_mptr</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=p>;</span>
            <span class=n>_mptr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=sa></span><span class=sc>&#39;</span><span class=sc>\0</span><span class=sc>&#39;</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=o>~</span><span class=n>MyString</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>~MyString()</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=k>delete</span><span class=p>[</span><span class=p>]</span> <span class=n>_mptr</span><span class=p>;</span>
        <span class=n>_mptr</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>MyString</span><span class=p>(</span><span class=k>const</span> <span class=n>MyString</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>MyString(const MyString&amp;)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=n>_mptr</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>strlen</span><span class=p>(</span><span class=n>str</span><span class=p>.</span><span class=n>_mptr</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span><span class=p>;</span>
        <span class=n>strcpy</span><span class=p>(</span><span class=n>_mptr</span><span class=p>,</span> <span class=n>str</span><span class=p>.</span><span class=n>_mptr</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>MyString</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>MyString</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>operator(const MyString&amp;)</span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>str</span> <span class=o>=</span><span class=o>=</span> <span class=k>this</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>delete</span><span class=p>[</span><span class=p>]</span> <span class=n>_mptr</span><span class=p>;</span>
        <span class=n>_mptr</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>strlen</span><span class=p>(</span><span class=n>str</span><span class=p>.</span><span class=n>_mptr</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span><span class=p>;</span>
        <span class=n>strcpy</span><span class=p>(</span><span class=n>_mptr</span><span class=p>,</span> <span class=n>str</span><span class=p>.</span><span class=n>_mptr</span><span class=p>)</span><span class=p>;</span>
        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=nf>c_str</span><span class=p>(</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>_mptr</span><span class=p>;</span> <span class=p>}</span>
<span class=k>private</span><span class=o>:</span>
    <span class=kt>char</span><span class=o>*</span> <span class=n>_mptr</span><span class=p>;</span>
<span class=p>}</span><span class=p>;</span>

<span class=n>MyString</span> <span class=nf>GetString</span><span class=p>(</span><span class=n>MyString</span><span class=o>&amp;</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>pstr</span> <span class=o>=</span> <span class=n>str</span><span class=p>.</span><span class=n>c_str</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=n>MyString</span> <span class=n>tmpStr</span><span class=p>(</span><span class=n>pstr</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>tmpStr</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>

    <span class=n>MyString</span> <span class=n>str1</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>aaaaaaaaaaaaaaa</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=n>MyString</span> <span class=n>str2</span><span class=p>;</span>
    <span class=n>str2</span> <span class=o>=</span> <span class=n>GetString</span><span class=p>(</span><span class=n>str1</span><span class=p>)</span><span class=p>;</span>
    <span class=n>cout</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>str2</span><span class=p>.</span><span class=n>c_str</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>endl</span><span class=p>;</span>

    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>xushun</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2022-09-08</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fxushun1221.github.io%2f2022%2fc-%25E9%25AB%2598%25E7%25BA%25A701-%25E5%25AF%25B9%25E8%25B1%25A1%25E4%25BC%2598%25E5%258C%2596%25E5%258F%25B3%25E5%2580%25BC%25E5%25BC%2595%25E7%2594%25A8%25E4%25BC%2598%25E5%258C%2596%2f&text=%e3%80%90C%2b%2b%e9%ab%98%e7%ba%a7%e3%80%9101%20-%20%e5%af%b9%e8%b1%a1%e4%bc%98%e5%8c%96%26%e5%8f%b3%e5%80%bc%e5%bc%95%e7%94%a8%e4%bc%98%e5%8c%96&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fxushun1221.github.io%2f2022%2fc-%25E9%25AB%2598%25E7%25BA%25A701-%25E5%25AF%25B9%25E8%25B1%25A1%25E4%25BC%2598%25E5%258C%2596%25E5%258F%25B3%25E5%2580%25BC%25E5%25BC%2595%25E7%2594%25A8%25E4%25BC%2598%25E5%258C%2596%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fxushun1221.github.io%2f2022%2fc-%25E9%25AB%2598%25E7%25BA%25A701-%25E5%25AF%25B9%25E8%25B1%25A1%25E4%25BC%2598%25E5%258C%2596%25E5%258F%25B3%25E5%2580%25BC%25E5%25BC%2595%25E7%2594%25A8%25E4%25BC%2598%25E5%258C%2596%2f&title=%e3%80%90C%2b%2b%e9%ab%98%e7%ba%a7%e3%80%9101%20-%20%e5%af%b9%e8%b1%a1%e4%bc%98%e5%8c%96%26%e5%8f%b3%e5%80%bc%e5%bc%95%e7%94%a8%e4%bc%98%e5%8c%96" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://xushun1221.github.io/tags/c++/><i class="fas fa-tag fa-fw"></i>&nbsp;C++</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://xushun1221.github.io>Home</a></span></section></div><div class=post-nav><a href=https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo01-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-muduo/ class=prev rel=prev title="【重写muduo】01 - 安装和使用 muduo"><i class="fas fa-angle-left fa-fw"></i>【重写muduo】01 - 安装和使用 muduo</a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xushun1221.github.io/about/ target=_blank>xushun</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>