# 【算法】哈希函数与哈希表


## 哈希函数
简单了解几个哈希函数的特征：
1. **输入域**：无穷，输出域：有穷
2. **确定性**：对于同一个哈希函数，相同的输入必然会有相同的输出
3. **哈希碰撞**：由于输出域是有限的，在很小的概率下，不同的输入也会有相同的输出
4. **离散性**：对于两个非常相似的输入，哈希函数值也会相差非常大
5. **均匀性**：对于一批输入，哈希函数可以几乎均匀的将其离散到整个输出域上

>对于一批输入，如果其能够在哈希函数`h()`的输出域上均匀分布，那么对其输出进行模运算`mod m`，也能均匀的在`0 ~ m-1`上分布。

### 题目：内存限制下的频率统计
题目描述：现在有一个大文件，文件中有约40亿个32位uint数据，只给1GiB内存，如何统计出现次数最多的数。  
思路：
1. 如果使用哈希表来统计，一条哈希表记录要占用8Byte（key-int-4B，value-int-4B），1GiB内存最多能容纳：$1024*1024*1024/8=134,217,728$条（约1亿条）记录。最差情况下，文件中的数据全部不同，用哈希表统计，需要320亿字节的空间，远远超出内存的限制。该方法不行。
2. 使用哈希运算和模运算进行分类统计的方法：
   1. 对于文件中的所有数，对其计算哈希值，并进行`mod 100`运算，这样就将40亿数据映射到`0 ~ 99`范围上。将40亿数据按`0 ~ 99`分配到100个小文件中；
   2. 根据哈希函数的均匀性可知，这100个小文件中，含有不同种uint的数量几乎相同，根据确定性可知，相同的uint一定会出现在同一个文件中。
   3. 现在对这100个小文件分别使用哈希表，每个哈希表最多需要占用3.2亿字节空间（约300MiB），可以在1GiB内存中统计。
   4. 统计得到100出现次数最大的数，再从这100中选出最大的即可。

-----

## 哈希表的实现
简要实现原理：
1. 使用拉链法来避免哈希碰撞：使用一个数组来标记相同哈希值的元素的指针，数组地址就是元素经过哈希函数和模运算的结果，碰撞的元素用指针链到其他元素的后面；
2. 初始：数组大小为`n`，最大碰撞数为`c`（每条链表最多串几个）；
3. 访问：元素进行哈希和模运算得到数组地址，在链表中遍历得到元素。
4. 插入：
   1. 如果当前要插入位置的链表长度小于`c`，链到链表上即可。
   2. 如果当前插入位置的链表长度大于`c`，由于哈希函数的均匀性可知，其他位置的链表长度也基本上超过了`c`，再继续链下去，会让遍历链表时间增加，访问时间复杂度变高。此时要进行扩容：将数组长度翻倍，将哈希表中的元素重新分配到新的链表上，由于哈希函数的均匀性，扩容后每条链表的长度基本为`c / 2`。

扩容的代价：  
1. 扩容次数，元素数量为`N`，不妨设数组大小初始值为`n = 2`，每个链表长度最大值为`c = 2`，（最差情况），那么需要扩容的次数为：$logN$ （N: 2 -> 4 -> 8 -> ....），实际扩容次数远远小于这个复杂度（也是这个级别）
2. 
