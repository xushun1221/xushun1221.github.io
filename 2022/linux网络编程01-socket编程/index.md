# 【Linux网络编程】01 - Socket编程


## 网络套接字 socket
Socket本身有插座的意思，在Linux环境下，用于表示**进程间网络通信**的特殊文件类型。本质为内核借助缓冲区形成的伪文件。

既然是文件，那么理所当然的，我们可以使用**文件描述符引用套接字**。与管道类似的，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。

在TCP/IP协议中，**IP地址+TCP或UDP端口号**唯一标识网络通讯中的一个进程。**IP地址+端口号**就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。

- 在网络通信中，套接字一定是成对出现的。
- 一个文件描述符指向一个套接字socket（套接字内部由内核借助两个缓冲区实现），一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。

## 网络字节序
计算机内存中的**多字节数据**，相对于内存地址来说，有两种存储方式：
- 小端法：用于计算机内存，数据的最低有效位对应低地址，数据的最高有效位对应高地址；
- 大端法：用于网络数据流，数据的最低有效位对应高地址，数据的最高有效位对应低地址。

读数据的顺序通常是从内存的低地址到高地址，本地和网络的字节序不同会造成错误。

例如，主机A有这样一个四字节数据`0x12ef34ab`，它在内存中的起始地址是`0x01`，使用小端法存储：

|地址|数据|
|---|---|
|0x04|0x12|
|0x03|0xef|
|0x02|0x34|
|0x01|0xab|

主机A将该四字节数据通过网络发送给主机B，使用大端字节序发送，发送的字节流为`0x12 0xef 0x34 0xab`，因为主机B使用的也是小段法，如果直接将该字节流装入内存（装入顺序从低地址到高地址），会得到`0xab34ef12`，和原始数据不同，需要进行转换。

收到的大端字节序的字节流：

|地址|数据|
|---|---|
|0x04|0xab|
|0x03|0x34|
|0x02|0xef|
|0x01|0x12|

转换为小端字节序，才可以得到原始数据`0x12ef34ab`：

|地址|数据|
|---|---|
|0x04|0x12|
|0x03|0xef|
|0x02|0x34|
|0x01|0xab|

### 网络字节序和主机字节序的转换
为了让相同的C程序在小端计算机和大端计算机中都可以正常运行，应该使用下面的库函数进行网络字节序和主机字节序的转换，以保证程序的可移植性。

```c
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);

uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
```
- `h`：host，主机；
- `n`：net，网络；
- `l`：32位无符号整型；
- `s`：16位无符号整型；
- `htonl`：主机字节序 -> 网络字节序 32位无符号整型，用于IP地址
- `ntohl`：网络字节序 -> 主机字节序 32位无符号整型，用于IP地址
- `htons`：主机字节序 -> 网络字节序 16位无符号整型，用于port端口
- `ntohs`：网络字节序 -> 主机字节序 16位无符号整型，用于port端口


