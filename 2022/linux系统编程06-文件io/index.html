<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>【Linux系统编程】06 - 文件IO | XuShun's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="XuShun的个人博客，记录学习和生活。"><link rel=prev href=https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B04-gdb%E8%B0%83%E8%AF%95%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/><link rel=next href=https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B07-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/><link rel=canonical href=https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B06-%E6%96%87%E4%BB%B6io/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="【Linux系统编程】06 - 文件IO"><meta name=twitter:description content="系统调用和系统函数 系统调用，是由操作系统实现并提供给外部应用程序的编程接口，是应用程序同操作系统之间数据交互的桥梁。 系统函数又是什么？例如，"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【Linux系统编程】06 - 文件IO","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xushun1221.github.io\/2022\/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B06-%E6%96%87%E4%BB%B6io\/"},"image":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"Linux","wordcount":5301,"url":"https:\/\/xushun1221.github.io\/2022\/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B06-%E6%96%87%E4%BB%B6io\/","datePublished":"2022-05-14T00:00:00\x2b00:00","dateModified":"2022-05-14T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xushun","logo":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">【Linux系统编程】06 - 文件IO</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2022-05-14>2022-05-14</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 5301 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://xushun1221.github.io/categories/coding/>Coding</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#系统调用和系统函数>系统调用和系统函数</a></li><li><a href=#open>open</a></li><li><a href=#close>close</a></li><li><a href=#read>read</a></li><li><a href=#write>write</a></li><li><a href=#实现cp程序>实现cp程序</a></li><li><a href=#错误处理函数>错误处理函数</a><ul><li><a href=#errno-和-strerror>errno 和 strerror</a></li><li><a href=#perror-打印错误提示>perror 打印错误提示</a></li></ul></li><li><a href=#系统调用与库函数---预读入和缓输出>系统调用与库函数 - 预读入和缓输出</a><ul><li><a href=#问题>问题</a></li><li><a href=#朴素的猜想>朴素的猜想</a></li><li><a href=#实验>实验</a></li><li><a href=#结果分析>结果分析</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#文件描述符>文件描述符</a></li><li><a href=#阻塞和非阻塞>阻塞和非阻塞</a></li><li><a href=#fcntl>fcntl</a></li><li><a href=#lseek>lseek</a></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#系统调用和系统函数>系统调用和系统函数</a></li><li><a href=#open>open</a></li><li><a href=#close>close</a></li><li><a href=#read>read</a></li><li><a href=#write>write</a></li><li><a href=#实现cp程序>实现cp程序</a></li><li><a href=#错误处理函数>错误处理函数</a><ul><li><a href=#errno-和-strerror>errno 和 strerror</a></li><li><a href=#perror-打印错误提示>perror 打印错误提示</a></li></ul></li><li><a href=#系统调用与库函数---预读入和缓输出>系统调用与库函数 - 预读入和缓输出</a><ul><li><a href=#问题>问题</a></li><li><a href=#朴素的猜想>朴素的猜想</a></li><li><a href=#实验>实验</a></li><li><a href=#结果分析>结果分析</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#文件描述符>文件描述符</a></li><li><a href=#阻塞和非阻塞>阻塞和非阻塞</a></li><li><a href=#fcntl>fcntl</a></li><li><a href=#lseek>lseek</a></li></ul></nav></div></details></div><div class=post-content><a class=post-dummy-target id=系统调用和系统函数></a><h2>系统调用和系统函数</h2><p>系统调用，是由操作系统实现并提供给外部应用程序的编程接口，是应用程序同操作系统之间数据交互的桥梁。</p><p>系统函数又是什么？例如，我们打开<code>open()</code>函数的帮助文档<code>man 2 open</code>，可以看到它是属于第二章的内容，也就是属于系统调用，而如果去阅读Linux内核的源码就会发现，在源码中没有<code>open()</code>函数，而它对应的真正的系统调用函数应该是<code>sys_open()</code>。<code>open()</code>只是<code>sys_open()</code>的一个简单封装，原因在于，系统需要和应用进行交互，但是又不希望被应用直接窥探到，所以进行了浅封装。严谨地来说<code>open()</code>这类函数，应该被称为<strong>系统函数</strong>而非系统调用。</p><p>方便起见，将<code>open()</code>这类系统函数不加区分得称为系统调用。</p><p>看下面这张图可以简单地了解一下，c标准库函数和系统调用之间的关系，如何将<code>Hello World!</code>打印到屏幕上？<br><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=/post_images/posts/Coding/%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9106/%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e7%a4%ba%e6%84%8f%e5%9b%be.jpg alt title=系统调用示意图 class=lazyload><figcaption class=image-caption>系统调用示意图</figcaption></figure></p><a class=post-dummy-target id=open></a><h2>open</h2><p>打开或创建一个文件。</p><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>open</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span><span class=p>;</span>
<span class=kt>int</span> <span class=nf>open</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=n>mode_t</span> <span class=n>mode</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li><code>open</code>函数所需的头文件：<code>sys/types.h</code>和<code>sys/stat.h</code>，可以用<code>unistd.h</code>代替（unix standard）；</li><li>返回值：打开文件获得的文件描述符descriptor（整型），出错返回-1（<code>errno</code>会被设置为相应的值）；</li><li><code>pathname</code>：文件路径；</li><li><code>flag</code>：该参数用来表明以何种模式访问文件；<ul><li>（宏定义在<code>fcntl.h</code>中）</li><li>必须包含下列三种访问模式之一，<code>O_RDONLY只读</code>、<code>O_WRONLY只写</code>、<code>O_RDWR读写</code>；</li><li>其他有关文件创建和文件状态的flag可以以或的形式组合，如<code>O_RDONLY | O_XXXXX</code>;</li></ul></li><li><code>mode</code>：文件访问的权限，在创建文件的时候需要指定它的权限（<code>flag</code>参数指定了<code>O_CREAT</code>），打开已有文件时不需要这个参数，<code>mode_t</code>是八进制的整型，应将<code>0777, 0751</code>这样的数赋值给<code>mode</code>(第一个0表示八进制)。</li></ul><p>常用<code>flag</code>参数：</p><ul><li><code>O_CREAT</code>：创建文件；</li><li><code>O_APPEND</code>：在文件末尾追加；</li><li><code>O_EXCL</code>：确定文件是否存在，如果文件已存在，并使用了<code>O_CREAT</code>则返回-1，文件不存在返回文件描述符；</li><li><code>O_TRUNC</code>：将文件大小截断为0；</li><li><code>O_NONBLOCK</code>：非阻塞</li></ul><p><code>mode</code>计算方式：<code>mode & (~umask)</code>。<br>终端命令<code>umask</code>查看，<code>umask</code>的值为<code>0002</code>，<code>~umask</code>就是<code>0775</code>。</p><p>常见的错误：</p><ul><li>打开的文件不存在；</li><li>以写方式打开只读文件（权限不够）；</li><li>以只写方式打开目录文件；</li><li>当<code>open</code>出错时，程序会自动设置<code>errno</code>，可以通过<code>strerror(errno)</code>来查看<code>errno</code>代表的含义：以写方式打开只读文件为例；<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;errno.h&gt; // 支持errno</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;string.h&gt;// 支持errno代表的含义</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[</span><span class=p>]</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>./testopen.txt</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 是个只读文件
</span><span class=c1></span>    <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>fd = %d, errno = %d : %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=n>errno</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
    <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>fd = -1, errno = 13 : Permission denied
</code></pre></td></tr></table></div></div></li></ul><a class=post-dummy-target id=close></a><h2>close</h2><p>关闭一个文件。</p><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>close</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li>返回值：成功返回<code>0</code>，失败返回<code>-1</code>；</li><li><code>fd</code>：文件描述符。</li></ul><a class=post-dummy-target id=read></a><h2>read</h2><p>从一个文件中读取数据。</p><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=n>ssize_t</span> <span class=nf>read</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>count</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li>返回值：有符号整数；<ul><li>成功读取会返回读到的字节数；</li><li>如果返回<code>0</code>，表示读到文件结尾（或套接字已关闭）；</li><li>如果失败，返回<code>-1</code>并设置<code>errno</code>。</li><li>如果返回<code>-1</code>且<code>errno == EAGAIN 或 EWOULDBLOCK</code>，说明正在读取非阻塞文件且无数据（设备文件或网络文件）；</li><li>如果返回<code>-1</code>且<code>errno == EINTR</code>，说明慢速系统调用被中断了。</li></ul></li><li><code>fd</code>：文件描述符；</li><li><code>buf</code>：缓冲区；</li><li><code>count</code>：缓冲区的大小。</li></ul><a class=post-dummy-target id=write></a><h2>write</h2><p>向一个文件中写数据。</p><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=n>ssize_t</span> <span class=nf>write</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>count</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li>返回值：有符号整数；<ul><li>成功写出，会返回写出的字节数；</li><li>如果返回<code>0</code>，表示没有数据可以写出；</li><li>如果失败，返回<code>-1</code>并设置<code>errno</code>；</li></ul></li><li><code>fd</code>：文件描述符；</li><li><code>buf</code>：从该缓冲区写出；</li><li><code>count</code>：实际要写出的数据大小。</li></ul><a class=post-dummy-target id=实现cp程序></a><h2>实现cp程序</h2><p>使用<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>实现<code>cp</code>程序，<code>my_cp filename1 filename2</code>，将文件1复制到文件2，如果文件2存在则覆盖它，不存在则创建。<br>代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[</span><span class=p>]</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>fd_in</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>)</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>fd_out</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=p>,</span> <span class=n>O_WRONLY</span> <span class=o>|</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_TRUNC</span><span class=p>,</span> <span class=mo>0664</span><span class=p>)</span><span class=p>;</span>
    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>1024</span><span class=p>]</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>read_bytes</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=p>(</span><span class=n>read_bytes</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd_in</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>1024</span><span class=p>)</span><span class=p>)</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>write</span><span class=p>(</span><span class=n>fd_out</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>read_bytes</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>close</span><span class=p>(</span><span class=n>fd_in</span><span class=p>)</span><span class=p>;</span>
    <span class=n>close</span><span class=p>(</span><span class=n>fd_out</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>注意：对于所有的系统调用，都需要去判断和处理返回值。我们可以用上面提到的<code>errno</code>和<code>printf</code>来打印错误提示，更推荐使用<code>perror</code>。</p><a class=post-dummy-target id=错误处理函数></a><h2>错误处理函数</h2><a class=post-dummy-target id=errno-和-strerror></a><h3>errno 和 strerror</h3><p>当出错时，程序会自动设置<code>errno</code>，可以通过<code>strerror(errno)</code>来查看<code>errno</code>代表的含义。</p><a class=post-dummy-target id=perror-打印错误提示></a><h3>perror 打印错误提示</h3><p><code>perror</code>在标准错误中生成一条信息，描述在调用系统函数或库函数遇到的最后一个错误。</p><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=kt>void</span> <span class=nf>perror</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li><code>s</code>：打印<code>s</code>，后跟一个冒号或空格，然后描述<code>errno</code>表示的错误；</li><li><code>s</code>应设置为简单的错误提示语句。</li></ul><p>带错误处理的cp程序：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[</span><span class=p>]</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>fd_in</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>fd_in</span> <span class=o>=</span><span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>argv1 open failed</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span> <span class=c1>// stdio.h
</span><span class=c1></span>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span> <span class=c1>// stdlib.h
</span><span class=c1></span>    <span class=p>}</span>
    <span class=kt>int</span> <span class=n>fd_out</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=p>,</span> <span class=n>O_WRONLY</span> <span class=o>|</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_TRUNC</span><span class=p>,</span> <span class=mo>0664</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>fd_out</span> <span class=o>=</span><span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>argv2 open failed</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>close</span><span class=p>(</span><span class=n>fd_in</span><span class=p>)</span><span class=p>;</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>1024</span><span class=p>]</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>read_bytes</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=p>(</span><span class=n>read_bytes</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd_in</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>1024</span><span class=p>)</span><span class=p>)</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>read_bytes</span> <span class=o>=</span><span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>read error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>write</span><span class=p>(</span><span class=n>fd_out</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>read_bytes</span><span class=p>)</span> <span class=o>=</span><span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>write error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=n>close</span><span class=p>(</span><span class=n>fd_in</span><span class=p>)</span><span class=p>;</span>
    <span class=n>close</span><span class=p>(</span><span class=n>fd_out</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=系统调用与库函数---预读入和缓输出></a><h2>系统调用与库函数 - 预读入和缓输出</h2><a class=post-dummy-target id=问题></a><h3>问题</h3><p>考虑这样一个问题：使用C标准库中的<code>fgetc fputc</code>函数每次读取、写出一个字符，使用系统调用函数<code>read write</code>每次读取、写出一个字符，拷贝相同的文件，谁的效率更高呢？</p><a class=post-dummy-target id=朴素的猜想></a><h3>朴素的猜想</h3><p>一个朴素的想法是：如果<code>fgetc fputc</code>是库函数，无法直接进入内核，如果要对磁盘进行读写，还是需要进行系统调用，使用<code>read write</code>函数。那如果直接使用系统调用，应该会更快？<br><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=/post_images/posts/Coding/%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9106/%e6%9c%b4%e7%b4%a0%e6%83%b3%e6%b3%95.jpg alt title=朴素想法 class=lazyload><figcaption class=image-caption>朴素想法</figcaption></figure></p><a class=post-dummy-target id=实验></a><h3>实验</h3><p>做个实验，用标准C库和系统调用来拷贝同一个大文件（大概4MiB），看看运行时间。<br>标准C库程序：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>FILE</span> <span class=o>*</span><span class=n>fp_in</span><span class=p>,</span> <span class=o>*</span><span class=n>fp_out</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>ch</span><span class=p>;</span>
    <span class=n>fp_in</span> <span class=o>=</span> <span class=n>fopen</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>bigfile.txt</span><span class=s>&#34;</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>r</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 做实验就不写的很严谨了 其实需要判断一下错误
</span><span class=c1></span>    <span class=n>fp_out</span> <span class=o>=</span> <span class=n>fopen</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>bigfile.cp</span><span class=s>&#34;</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>w</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=p>(</span><span class=n>ch</span> <span class=o>=</span> <span class=n>fgetc</span><span class=p>(</span><span class=n>fp_in</span><span class=p>)</span><span class=p>)</span> <span class=o>!</span><span class=o>=</span> <span class=n>EOF</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fputc</span><span class=p>(</span><span class=n>ch</span><span class=p>,</span> <span class=n>fp_out</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>fclose</span><span class=p>(</span><span class=n>fp_in</span><span class=p>)</span><span class=p>;</span>
    <span class=n>fclose</span><span class=p>(</span><span class=n>fp_out</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>系统调用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>fd_in</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>./bigfile.txt</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>)</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>fd_out</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>./bigfile.cp1</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>O_WRONLY</span> <span class=o>|</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_TRUNC</span><span class=p>,</span> <span class=mo>0664</span><span class=p>)</span><span class=p>;</span>
    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>read_bytes</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=p>(</span><span class=n>read_bytes</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd_in</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span><span class=p>)</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>write</span><span class=p>(</span><span class=n>fd_out</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>read_bytes</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>close</span><span class=p>(</span><span class=n>fd_in</span><span class=p>)</span><span class=p>;</span>
    <span class=n>close</span><span class=p>(</span><span class=n>fd_out</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>看一下运行时间：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_fileIO$ time ./fgetcfputc 

real    0m0.046s
user    0m0.029s
sys     0m0.016s
xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_fileIO$ time ./readwrite 

real    0m11.713s
user    0m3.023s
sys     0m8.688s
</code></pre></td></tr></table></div></div><p>可以看到，使用<code>fgetc fputc</code>的方法用时远远低于系统调用方法。<br>使用<code>strace</code>命令来跟踪程序执行过程中的系统调用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_fileIO$ strace ./fgetcfputc 
...
read(3, &#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#34;..., 4096) = 4096
write(4, &#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#34;..., 4096) = 4096
read(3, &#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#34;..., 4096) = 4096
write(4, &#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#34;..., 4096) = 4096
...

xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_fileIO$ strace ./readwrite 
...
read(3, &#34;a&#34;, 1)                         = 1
write(4, &#34;a&#34;, 1)                        = 1
read(3, &#34;a&#34;, 1)                         = 1
write(4, &#34;a&#34;, 1)                        = 1
...
</code></pre></td></tr></table></div></div><p>可以看到，<code>fgetc fputc</code>函数每次调用<code>read write</code>函数时都向内核读取、写入了4096个字节，而不是一个字节。而使用系统调用方法的程序，每次都真的向内核读取、写入了1个字节。</p><a class=post-dummy-target id=结果分析></a><h3>结果分析</h3><p>原因是什么？可以参考这张图。<br><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=/post_images/posts/Coding/%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9106/%e9%a2%84%e8%af%bb%e5%85%a5%e5%92%8c%e7%bc%93%e8%be%93%e5%87%ba.jpg alt title=预读入和缓输出 class=lazyload><figcaption class=image-caption>预读入和缓输出</figcaption></figure></p><p>对于写文件的操作，在内核中存在一个缓冲区（一般大小为4096字节），进行一次<code>write</code>，并不会直接将数据写入硬盘中，而是先将数据存入缓冲区，当缓冲区满之后一次性写入硬盘。（称为<strong>缓输出</strong>）</p><ul><li>对于<code>fputc</code>函数而言，当调用<code>fputc</code>写一个字节时，并不会直接调用<code>write</code>将其写入内核，而是在用户空间也进行了一次缓冲，只有当该缓冲区中的字节数达到4096，才会写入内核；</li><li>对于直接使用系统调用而言，每写一个字节就进入内核一次。</li></ul><p>对于读文件的操作，也会在内核中使用缓冲区，如果向内核请求读取一个字节的数据，内核不会从硬盘中只读一个字节，而是一次读取4096字节，如果用户再次申请后续的数据，就无需再次和硬盘进行交互。</p><ul><li>从strace的结果可以看出，对于<code>fgetc</code>函数而言，读取数据不会只读一个字节，而是从内核一次读取4096个字节存入缓冲区，然后一个一个交付给用户；</li><li>对于直接使用系统调用而言，每读一个字节就进入内核一次。</li></ul><p>从用户空间进入内核空间的操作是非常耗时的，<code>fgetc fputc</code>会使用缓冲区来减少用户空间到内核空间的切换次数；而直接使用系统调用，每读写一个字节就切换一次，时间消耗非常大。</p><a class=post-dummy-target id=总结></a><h3>总结</h3><p><code>read</code>和<code>write</code>函数常常被称为<strong>Unbuffered IO</strong>，也就是无缓冲IO，这里的缓冲是指用户级缓冲，不保证不使用内核缓冲。</p><p>系统调用和库函数各有优劣，即使我们学习了系统调用，在多数时候也要优先使用库函数。</p><p>在有些时候，我们希望尽快地将数据写到硬盘或其他终端设备中，可以考虑使用系统调用。</p><a class=post-dummy-target id=文件描述符></a><h2>文件描述符</h2><p>文件描述符的图示如下：<br><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=/post_images/posts/Coding/%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9106/%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6.jpg alt title=文件描述符 class=lazyload><figcaption class=image-caption>文件描述符</figcaption></figure></p><ul><li>文件描述符这个概念是属于进程的，在PCB进程控制块中，有一个指针指向一个文件描述符表，每一个表项就是一个该进程打开的文件；</li><li>文件描述符（整数）可以理解为一个指针数组的索引（key），数组内容是指向文件结构体（<code>struct file</code>，文件的描述信息）的指针（value）；</li><li>操作系统不想让用户知道该表的具体细节，所以只将索引暴露给用户；</li><li>文件描述符表的前三项（0、1、2），分别对应标准输入、标准输出、标准错误，推荐使用对应的宏（<code>STDIN_FILENO</code>，<code>STDOUT_FILENO</code>，<code>STDERR_FILENO</code>）而非数字012；</li><li>进程打开的其他文件从<code>3</code>号开始，最大为<code>1023</code>号，所以一个进程最多打开1024个文件；</li><li>新打开的文件使用的文件描述符，是表中可用的最小的序号，例如已打开3、4、5、6号，此时关闭3号，下次打开文件的描述符就为3。</li></ul><a class=post-dummy-target id=阻塞和非阻塞></a><h2>阻塞和非阻塞</h2><p>产生阻塞的场景：读设备文件、读网络。（阻塞是设备文件、网络文件的属性，常规文件无阻塞概念）</p><p>终端对应的文件为：<code>/dev/tty</code>，尝试使用这个文件。<br>从标准输入（键盘）读数据，写到标准输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>read_bytes</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 阻塞
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>read STDIO_FILENO</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>exit</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>read_bytes</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>编译运行该程序，发现终端的光标在闪烁，该程序阻塞在了<code>read</code>函数处，随便输入一些字符，回车，阻塞状态结束，<code>read</code>读到了字符，并由<code>write</code>函数回显到终端。这说明<code>/dev/tty</code>这个文件默认就是阻塞的。</p><p>如果一个阻塞文件被读取，没有数据它就会等待数据；而一个非阻塞文件被读取，但是它没有数据，<code>read</code>会直接返回<code>-1</code>，并且<code>errno</code>会被设置为<code>EAGAIN</code>或<code>EWOULDBLOCK</code>，但这种情况不是读取错误，表示正在读取非阻塞文件而没有数据。</p><p><code>/dev/tty</code>可以直接读，说明它已经是打开的状态，如果想要使用非阻塞方式，我们需要重新打开这个文件，并添加<code>O_NONBLOCK</code>flag，设备文件不需要关闭。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>/dev/tty</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span> <span class=o>|</span> <span class=n>O_NONBLOCK</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 非阻塞
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>open /dev/tty</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=kt>int</span> <span class=n>read_bytes</span><span class=p>;</span>
<span class=nl>tryagain</span><span class=p>:</span>
    <span class=n>read_bytes</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>read_bytes</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>!</span><span class=o>=</span> <span class=n>EAGAIN</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>read /dev/tty</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>try again</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>strlen</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>try again</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
            <span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span><span class=p>;</span>
            <span class=k>goto</span> <span class=n>tryagain</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>read_bytes</span><span class=p>)</span><span class=p>;</span>
    <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>编译运行，可以看到每隔2秒，终端就会输出<code>try again</code>提示进行输入，输入一些字符后回车，终端就会回显这些字符并退出。</p><a class=post-dummy-target id=fcntl></a><h2>fcntl</h2><p>获取和设置文件访问模式属性。</p><p>上一部分我们使用重新打开文件的方法来设置文件的访问模式，其实可以不重新打开文件，直接使用<code>fcntl</code>函数进行设置即可。（file control）</p><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>fcntl</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span> <span class=cm>/* arg */</span> <span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li>返回值：<ul><li><code>-1</code>，出错，<code>errno</code>设置；</li><li>成功情况的返回值和操作相关。</li></ul></li><li><code>fd</code>：文件描述符；</li><li><code>cmd</code>：命令；</li><li><code>/*arg*/</code>：根据<code>cmd</code>决定后续的参数。</li></ul><p>重点掌握的命令：</p><ul><li><code>F_GETFL</code>：获取文件的访问模式（get file flags），不需要参数；</li><li><code>F_SETFL</code>：设置文件的访问模式（set file flags），需要一个<code>int flags</code>参数；</li><li>要给文件添加一个访问模式，可以使用<code>F_GETFL</code>获取文件的<code>flags</code>然后或等上需要添加的访问模式flag(bitmap)，再使用<code>F_SETFL</code>进行设置即可。</li></ul><p>示例，非阻塞终端回显：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>flags</span> <span class=o>=</span> <span class=n>fcntl</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>,</span> <span class=n>F_GETFL</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>flags</span> <span class=o>=</span><span class=o>=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>fcntl error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>flags</span> <span class=o>|</span><span class=o>=</span> <span class=n>O_NONBLOCK</span><span class=p>;</span> <span class=c1>// 设置为非阻塞
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>fcntl</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>,</span> <span class=n>F_SETFL</span><span class=p>,</span> <span class=n>flags</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>=</span><span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>fcntl error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=kt>int</span> <span class=n>read_bytes</span><span class=p>;</span>
<span class=nl>tryagain</span><span class=p>:</span>
    <span class=n>read_bytes</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>STDIN_FILENO</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>read_bytes</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>!</span><span class=o>=</span> <span class=n>EAGAIN</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>read /dev/tty</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>try again</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>strlen</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>try again</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
            <span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span><span class=p>;</span>
            <span class=k>goto</span> <span class=n>tryagain</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>read_bytes</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=lseek></a><h2>lseek</h2><p>定位读写文件的偏移值。</p><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=n>off_t</span> <span class=nf>lseek</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=n>off_t</span> <span class=n>offset</span><span class=p>,</span> <span class=kt>int</span> <span class=n>whence</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li>返回值：从文件起始位置开始的偏移长度，出错返回<code>-1</code>，且设置<code>errno</code>；</li><li><code>fd</code>：文件描述符；</li><li><code>offset</code>：偏移量（可正可负）；</li><li><code>whence</code>：偏移的起始位置<ul><li><code>SEEK_SET</code>：起始字节；</li><li><code>SEEK_CUR</code>：当前字节，假如已经读了10个字节，<code>SEEK_CUR == 11</code>;</li><li><code>SEEK_END</code>：末尾后一个字节。</li></ul></li></ul><p><code>lseek</code>应用场景：</p><ul><li>文件的读和写使用的是同一个偏移量；</li><li>使用lseek获取文件大小（并不是非常正规的方式）<code>lseek(fd, 0, SEEK_END);</code>；</li><li>使用lseek拓展文件大小，<code>lseek(fd, 100, SEEK_END);</code>，在文件后追加100个字节，这里还没有真正拓展，如果要使文件正在拓展，必须在lseek之后引起IO操作（在结尾随便写一个字符<code>'\0'</code>即可，这样就追加了101个字节）。</li></ul><p>补充：</p><ul><li><code>od -tcx filename</code>：查看文件的 16 进制表示形式；</li><li><code>od -tcd filename</code>：查看文件的 10 进制表示形式；</li><li>使用<code>truncate</code>函数，直接拓展文件。<code>int ret = truncate("test.txt", 250)</code>，成功返回<code>0</code>，失败返回<code>-1</code>并设置<code>errno</code>;（它不能创建文件，只能拓展现有文件）</li></ul></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>xushun</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2022-05-14</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fxushun1221.github.io%2f2022%2flinux%25E7%25B3%25BB%25E7%25BB%259F%25E7%25BC%2596%25E7%25A8%258B06-%25E6%2596%2587%25E4%25BB%25B6io%2f&text=%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9106%20-%20%e6%96%87%e4%bb%b6IO&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fxushun1221.github.io%2f2022%2flinux%25E7%25B3%25BB%25E7%25BB%259F%25E7%25BC%2596%25E7%25A8%258B06-%25E6%2596%2587%25E4%25BB%25B6io%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fxushun1221.github.io%2f2022%2flinux%25E7%25B3%25BB%25E7%25BB%259F%25E7%25BC%2596%25E7%25A8%258B06-%25E6%2596%2587%25E4%25BB%25B6io%2f&title=%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9106%20-%20%e6%96%87%e4%bb%b6IO" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://xushun1221.github.io/tags/linux/><i class="fas fa-tag fa-fw"></i>&nbsp;Linux</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://xushun1221.github.io>Home</a></span></section></div><div class=post-nav><a href=https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B04-gdb%E8%B0%83%E8%AF%95%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/ class=prev rel=prev title="【Linux系统编程】04 - gdb调试器的使用"><i class="fas fa-angle-left fa-fw"></i>【Linux系统编程】04 - gdb调试器的使用</a>
<a href=https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B07-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/ class=next rel=next title="【Linux系统编程】07 - 文件系统编程">【Linux系统编程】07 - 文件系统编程<i class="fas fa-angle-right fa-fw"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xushun1221.github.io/about/ target=_blank>xushun</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>