<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>【算法】资源限制类的大数据问题 - 技巧总结 | XuShun's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="XuShun的个人博客，记录学习和生活。"><link rel=prev href=https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/><link rel=next href=https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/><link rel=canonical href=https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="【算法】资源限制类的大数据问题 - 技巧总结"><meta name=twitter:description content="资源限制类的大数据问题的解题技巧 哈希函数可以把数据按照种类均匀分流 布隆过滤器用于集合的建立和查询，并可以节省大量空间 一致性哈希解决数据服务器"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【算法】资源限制类的大数据问题 - 技巧总结","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xushun1221.github.io\/2022\/%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93\/"},"image":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"算法与数据结构, C\x2b\x2b","wordcount":3136,"url":"https:\/\/xushun1221.github.io\/2022\/%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93\/","datePublished":"2022-04-22T00:00:00\x2b00:00","dateModified":"2022-04-22T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xushun","logo":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">【算法】资源限制类的大数据问题 - 技巧总结</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2022-04-22>2022-04-22</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 3136 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://xushun1221.github.io/categories/coding/>Coding</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#资源限制类的大数据问题的解题技巧>资源限制类的大数据问题的解题技巧</a></li><li><a href=#题目140亿数字中未出现的数>题目1：40亿数字中未出现的数</a></li><li><a href=#题目2百亿数据中的重复数据和top100数据>题目2：百亿数据中的重复数据和TOP100数据</a></li><li><a href=#题目340亿无符号整数中出现两次的数和中位数>题目3：40亿无符号整数中出现两次的数和中位数</a></li><li><a href=#题目4无序的10g数据文件排序的问题>题目4：无序的10G数据文件排序的问题</a></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#资源限制类的大数据问题的解题技巧>资源限制类的大数据问题的解题技巧</a></li><li><a href=#题目140亿数字中未出现的数>题目1：40亿数字中未出现的数</a></li><li><a href=#题目2百亿数据中的重复数据和top100数据>题目2：百亿数据中的重复数据和TOP100数据</a></li><li><a href=#题目340亿无符号整数中出现两次的数和中位数>题目3：40亿无符号整数中出现两次的数和中位数</a></li><li><a href=#题目4无序的10g数据文件排序的问题>题目4：无序的10G数据文件排序的问题</a></li></ul></nav></div></details></div><div class=post-content><a class=post-dummy-target id=资源限制类的大数据问题的解题技巧></a><h2>资源限制类的大数据问题的解题技巧</h2><ol><li>哈希函数可以把数据按照种类均匀分流</li><li>布隆过滤器用于集合的建立和查询，并可以节省大量空间</li><li>一致性哈希解决数据服务器的负载管理问题</li><li>利用并查集结构做岛屿问题的并行计算</li><li>位图解决某一范围上数字的出现情况，并可以节省大量空间</li><li>利用分段统计思想，并进一步节省大量空间</li><li>利用堆、外排序来做多个处理单元的结果合并</li></ol><p><em>前4个问题在之前的笔记中有过记录</em></p><hr><a class=post-dummy-target id=题目140亿数字中未出现的数></a><h2>题目1：40亿数字中未出现的数</h2><p>题目描述：32位无符号整数的范围是0~4294967295($2^{32}-1$)，现在有一个正好包含40亿个无符号整数的文件，在整个无符号整数的范围中必然存在没出现过的数，最多可以使用1GiB内存，怎么找到所有未出现的数？<br>思路：使用位图bitmap来记录每一个数字是否出现过，位图只需要使用$2^{32}/8$的字节空间，大概500MiB即可。</p><p>进阶问题：内存限制为3KB，怎么找到一个未出现过的数？<br>思路：</p><ol><li>如果3KB内存都用来存储无符号整型（4B），$3KB/4B\approx700$，大概可以存储700个无符号整型，向下取为$2^{9}=512$，申请一个长度为512的无符号整型数组<code>arr</code>（不会超过内存限制）；</li><li>无符号整型的范围是$0\sim2^{32}-1$，一共有$2^{32}种数$，一定可以被512整除。所以把40亿个数分为512份，那么每一份中的数的个数都是一样的（$2^{32}/2^{9}$），第一份中的数据范围是：$0\sim2^{32}/2^{9}-1$，最后一份中的数据范围是：$2^{32}-1-2^{32}/2^{9}\sim2^{32}-1$；</li><li><code>arr[i]</code>表示在$i\times2^{32}/2^{9}\sim\left(i+1\right)\times2^{32}/2^{9}-1$范围上的数字出现的次数；</li><li>遍历统计所有数，由于40亿数据小于$2^{32}$，所以一定有某个<code>arr[i]</code>小于$2^{32}/2^{9}$；</li><li>然后在这个数字个数小于$2^{32}/2^{9}$的范围上（$i\times2^{32}/2^{9}\sim\left(i+1\right)\times2^{32}/2^{9}-1$），再分为512份（每份$2^{32}/2^{9}/2^{9}$个），重新遍历40亿数，只统计在该范围上的数的出现次数；</li><li>重复此过程，直到<code>arr[i]</code>表示的范围为1个数。</li></ol><p><em>（1KB内存限制同理）</em></p><p>再进阶：如果只能使用几个变量来统计，怎么找到一个未出现过的数？
思路：使用两个变量<code>x</code>，<code>y</code>，分别表示$0\sim2^{32}/2-1$和$2^{32}/2\sim2^{32}-1$两个范围上数字出现的次数，那么一定有一个变量小于$2^{32}/2$，再在这个范围上继续找，直到<code>x y</code>表示的范围只有一个数为止。</p><hr><a class=post-dummy-target id=题目2百亿数据中的重复数据和top100数据></a><h2>题目2：百亿数据中的重复数据和TOP100数据</h2><p>问题描述：有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL。<br>思路：</p><ol><li>哈希函数分流，相同的URL一定会进入同一个小文件，在小文件中统计哪些URL重复，再汇总信息；</li><li>布隆过滤器，一边添加数据，一边查询数据是否有重复的，记录重复的URL到一个文件中（存在一定的失误率）。</li></ol><p>进阶问题：某搜索公司一天的用户搜索词汇是海量的（百亿数据量，存放在一个大文件中），请设计一种求出每天热门TOP100词汇的可行方法。<br>思路：使用哈希函数分流的思想，将大文件中的数据，分流到多个小文件中（同样的词汇一定分流到同一个文件中），使用哈希表（key-词汇 value-次数）进行次数统计，得到每个小文件的TOP100词汇，然后再汇总所有小文件的TOP100词汇得到总的TOP100词汇。</p><p>使用什么方法从多个TOP100词汇中整合出总的TOP100词汇？ 使用堆结构。</p><ol><li>每个小文件的TOP100统计结果用一个大根堆来表示；</li><li>把每一个小文件的大根堆的堆顶取出，单独组织成一个大根堆（叫做总堆）；</li><li>从总堆中弹出堆顶元素（第一次弹出的就是总的TOP1词汇），把弹出的元素原来所在的大根堆的堆顶也弹出来（就是它自己），然后把该大根堆的新的堆顶元素取出，添加到总堆中去；</li><li>再次执行第三步，直到找到全部TOP100词汇。</li></ol><hr><a class=post-dummy-target id=题目340亿无符号整数中出现两次的数和中位数></a><h2>题目3：40亿无符号整数中出现两次的数和中位数</h2><p>问题描述：32位无符号整数的范围是：$0\sim4294967295$，现有40亿个无符号整数，最多可以使用1GiB内存，找出所有出现了两次的数。<br>思路：（当然可以使用哈希函数对大文件进行分流，然后使用哈希表来统计。）</p><ol><li>或者使用位图的升级版：使用两个位来表示某个数的状态（<code>00</code>出现0次，<code>01</code>出现1次，<code>10</code>出现两次，<code>11</code>出现多于两次）；</li><li>32位无符号整型一共有$2^{32}$种数，每个数使用两位来表示状态，一共需要$2^{32}\times2$bits，小于1GiB。</li></ol><p>进阶题目：最多可以使用10KiB内存，如何找到40亿数中的中位数？<br>思路：（和题目1一样的范围统计思路）</p><ol><li>看一下10KiB能申请多大的无符号整型数组：$10KiB/4B\approx2500$，向下取整为$2^{11}=2048$，申请一个长度为2048的无符号整型数组<code>arr</code>；</li><li>将无符号整型的范围等分为2048份，遍历这40亿个数，每个数属于哪个范围，<code>arr[i]++</code>；</li><li>求中位数，也就是第20亿个数是什么；</li><li>哪个范围上的累加和刚好超过20亿（<code>arr[0]+...+arr[i] >= 20亿</code>），就证明中位数在那个范围上<code>arr[i]</code>，假设累加和为22亿，那么你就要在这个范围上找第2亿个数；</li><li>遍历40亿数，再次等分小范围，重复此过程，直到范围缩小为1。</li></ol><hr><a class=post-dummy-target id=题目4无序的10g数据文件排序的问题></a><h2>题目4：无序的10G数据文件排序的问题</h2><p>题目描述：现有一个内容完全是整型数据的10GiB的文件，限定5GiB内存，如何保留文件中的所有数据并输出一个有序的文件？（5MiB 5KiB内存同理）</p><p>思路1：使用堆结构进行范围统计</p><ol><li>使用一个小根堆，元素的结构为：int数据本身和它出现的次数（一个元素占用8B空间），小根堆通过比较int数据本身来组织小根堆结构；</li><li>小根堆内部出了元素占用的空间，还可能需要其他的内存占用，这里假设每个包含了其他占用的元素内存空间为16B，5GiB内存的小根堆支持$5\times2^{30}/16=5\times2^{26}$个元素，向下取整为$2^{27}$个；</li><li>int类型数据的范围是$-2^{31}\sim2^{31}-1$，共$2^{32}$种数，将其按照每份$2^{27}$个，可以分为$2^{5}$份，比如第一份的范围是$-2^{31}\sim-2^{31}+2^{27}$。</li><li>遍历这10G数据，先统计第一份的范围上的数字（其他范围的数据跳过），遍历完一轮之后，小根堆种的数据就是第一个范围上的数据的词频状况；</li><li>将小根堆中的数据依次输出到新文件中，在统计下一个范围上的数字，直到所有范围都统计一遍。</li></ol><p>思路2：使用堆结构进行个数统计</p><ol><li>使用一个大根堆，元素结构同思路1，假设在内存限制的条件下大根堆最多维持1万个元素（根据内存限制来确定），再使用一个变量<code>min</code>来维持现在该统计的最小值（初始为$-2^{31}$），大根堆维持的这1万个元素是大于等于<code>min</code>的一万个最小的不同元素；</li><li>文件中共有10GiB数据，需要遍历$10GiB/4B\times16B/1万$次；</li><li>遍历到每一个int时，如果大根堆中元素数量小于1万，或者当前的int数据比大根堆堆顶元素小（或等于），就将该int数据插入大根堆，并调整大根堆，10GiB数据遍历完成后，<code>min</code>重新赋值为大根堆堆顶元素加1，并将这1万条记录按照每个数的词频写入新文件中；</li><li>进行下一轮遍历，直到$min>2^{31}-1$。</li></ol></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>xushun</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2022-04-22</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fxushun1221.github.io%2f2022%2f%25E7%25AE%2597%25E6%25B3%2595%25E8%25B5%2584%25E6%25BA%2590%25E9%2599%2590%25E5%2588%25B6%25E7%25B1%25BB%25E7%259A%2584%25E5%25A4%25A7%25E6%2595%25B0%25E6%258D%25AE%25E9%2597%25AE%25E9%25A2%2598-%25E6%258A%2580%25E5%25B7%25A7%25E6%2580%25BB%25E7%25BB%2593%2f&text=%e3%80%90%e7%ae%97%e6%b3%95%e3%80%91%e8%b5%84%e6%ba%90%e9%99%90%e5%88%b6%e7%b1%bb%e7%9a%84%e5%a4%a7%e6%95%b0%e6%8d%ae%e9%97%ae%e9%a2%98%20-%20%e6%8a%80%e5%b7%a7%e6%80%bb%e7%bb%93&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fxushun1221.github.io%2f2022%2f%25E7%25AE%2597%25E6%25B3%2595%25E8%25B5%2584%25E6%25BA%2590%25E9%2599%2590%25E5%2588%25B6%25E7%25B1%25BB%25E7%259A%2584%25E5%25A4%25A7%25E6%2595%25B0%25E6%258D%25AE%25E9%2597%25AE%25E9%25A2%2598-%25E6%258A%2580%25E5%25B7%25A7%25E6%2580%25BB%25E7%25BB%2593%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fxushun1221.github.io%2f2022%2f%25E7%25AE%2597%25E6%25B3%2595%25E8%25B5%2584%25E6%25BA%2590%25E9%2599%2590%25E5%2588%25B6%25E7%25B1%25BB%25E7%259A%2584%25E5%25A4%25A7%25E6%2595%25B0%25E6%258D%25AE%25E9%2597%25AE%25E9%25A2%2598-%25E6%258A%2580%25E5%25B7%25A7%25E6%2580%25BB%25E7%25BB%2593%2f&title=%e3%80%90%e7%ae%97%e6%b3%95%e3%80%91%e8%b5%84%e6%ba%90%e9%99%90%e5%88%b6%e7%b1%bb%e7%9a%84%e5%a4%a7%e6%95%b0%e6%8d%ae%e9%97%ae%e9%a2%98%20-%20%e6%8a%80%e5%b7%a7%e6%80%bb%e7%bb%93" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://xushun1221.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><i class="fas fa-tag fa-fw"></i>&nbsp;算法与数据结构</a>&nbsp;
</span><span class=tag><a href=https://xushun1221.github.io/tags/c++/><i class="fas fa-tag fa-fw"></i>&nbsp;C++</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://xushun1221.github.io>Home</a></span></section></div><div class=post-nav><a href=https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/ class=prev rel=prev title=【算法】一致性哈希算法><i class="fas fa-angle-left fa-fw"></i>【算法】一致性哈希算法</a>
<a href=https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/ class=next rel=next title=【算法】位运算相关题目>【算法】位运算相关题目<i class="fas fa-angle-right fa-fw"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xushun1221.github.io/about/ target=_blank>xushun</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>