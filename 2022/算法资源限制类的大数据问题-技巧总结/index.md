# 【算法】资源限制类的大数据问题 - 技巧总结


## 资源限制类的大数据问题的解题技巧
1. 哈希函数可以把数据按照种类均匀分流
2. 布隆过滤器用于集合的建立和查询，并可以节省大量空间
3. 一致性哈希解决数据服务器的负载管理问题
4. 利用并查集结构做岛屿问题的并行计算
5. 位图解决某一范围上数字的出现情况，并可以节省大量空间
6. 利用分段统计思想，并进一步节省大量空间
7. 利用堆、外排序来做多个处理单元的结果合并

*前4个问题在之前的笔记中有过记录*

-----

## 题目1：40亿数字中未出现的数
题目描述：32位无符号整数的范围是0~4294967295($2^{32}-1$)，现在有一个正好包含40亿个无符号整数的文件，在整个无符号整数的范围中必然存在没出现过的数，最多可以使用1GiB内存，怎么找到所有未出现的数？  
思路：使用位图bitmap来记录每一个数字是否出现过，位图只需要使用$2^{32}/8$的字节空间，大概500MiB即可。

进阶问题：内存限制为3KB，怎么找到一个未出现过的数？  
思路：
1. 如果3KB内存都用来存储无符号整型（4B），$3KB/4B\approx700$，大概可以存储700个无符号整型，向下取为$2^{9}=512$，申请一个长度为512的无符号整型数组`arr`（不会超过内存限制）；
2. 无符号整型的范围是$0\sim2^{32}-1$，一共有$2^{32}种数$，一定可以被512整除。所以把40亿个数分为512份，那么每一份中的数的个数都是一样的（$2^{32}/2^{9}$），第一份中的数据范围是：$0\sim2^{32}/2^{9}-1$，最后一份中的数据范围是：$2^{32}-1-2^{32}/2^{9}\sim2^{32}-1$；
3. `arr[i]`表示在$i\times2^{32}/2^{9}\sim\left(i+1\right)\times2^{32}/2^{9}-1$范围上的数字出现的次数；
4. 遍历统计所有数，由于40亿数据小于$2^{32}$，所以一定有某个`arr[i]`小于$2^{32}/2^{9}$；
5. 然后在这个数字个数小于$2^{32}/2^{9}$的范围上（$i\times2^{32}/2^{9}\sim\left(i+1\right)\times2^{32}/2^{9}-1$），再分为512份（每份$2^{32}/2^{9}/2^{9}$个），重新遍历40亿数，只统计在该范围上的数的出现次数；
6. 重复此过程，直到`arr[i]`表示的范围为1个数。

*（1KB内存限制同理）*

再进阶：如果只能使用几个变量来统计，怎么找到一个未出现过的数？
思路：使用两个变量`x`，`y`，分别表示$0\sim2^{32}/2-1$和$2^{32}/2\sim2^{32}-1$两个范围上数字出现的次数，那么一定有一个变量小于$2^{32}/2$，再在这个范围上继续找，直到`x y`表示的范围只有一个数为止。

-----

## 题目2：百亿数据中的重复数据和TOP100数据
问题描述：有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL。  
思路：
1. 哈希函数分流，相同的URL一定会进入同一个小文件，在小文件中统计哪些URL重复，再汇总信息；
2. 布隆过滤器，一边添加数据，一边查询数据是否有重复的，记录重复的URL到一个文件中（存在一定的失误率）。

进阶问题：某搜索公司一天的用户搜索词汇是海量的（百亿数据量，存放在一个大文件中），请设计一种求出每天热门TOP100词汇的可行方法。  
思路：使用哈希函数分流的思想，将大文件中的数据，分流到多个小文件中（同样的词汇一定分流到同一个文件中），使用哈希表（key-词汇 value-次数）进行次数统计，得到每个小文件的TOP100词汇，然后再汇总所有小文件的TOP100词汇得到总的TOP100词汇。

使用什么方法从多个TOP100词汇中整合出总的TOP100词汇？ 使用堆结构。  
1. 每个小文件的TOP100统计结果用一个大根堆来表示；
2. 把每一个小文件的大根堆的堆顶取出，单独组织成一个大根堆（叫做总堆）；
3. 从总堆中弹出堆顶元素（第一次弹出的就是总的TOP1词汇），把弹出的元素原来所在的大根堆的堆顶也弹出来（就是它自己），然后把该大根堆的新的堆顶元素取出，添加到总堆中去；
4. 再次执行第三步，直到找到全部TOP100词汇。

-----

## 题目3：40亿无符号整数中出现两次的数和中位数
问题描述：32位无符号整数的范围是：$0\sim4294967295$，现有40亿个无符号整数，最多可以使用1GiB内存，找出所有出现了两次的数。  
思路：（当然可以使用哈希函数对大文件进行分流，然后使用哈希表来统计。）
1. 或者使用位图的升级版：使用两个位来表示某个数的状态（`00`出现0次，`01`出现1次，`10`出现两次，`11`出现多于两次）；
2. 32位无符号整型一共有$2^{32}$种数，每个数使用两位来表示状态，一共需要$2^{32}\times2$bits，小于1GiB。


进阶题目：最多可以使用10KiB内存，如何找到40亿数中的中位数？  
思路：（和题目1一样的范围统计思路）
1. 看一下10KiB能申请多大的无符号整型数组：$10KiB/4B\approx2500$，向下取整为$2^{11}=2048$，申请一个长度为2048的无符号整型数组`arr`；
2. 将无符号整型的范围等分为2048份，遍历这40亿个数，每个数属于哪个范围，`arr[i]++`；
3. 求中位数，也就是第20亿个数是什么；
4. 哪个范围上的累加和刚好超过20亿（`arr[0]+...+arr[i] >= 20亿`），就证明中位数在那个范围上`arr[i]`，假设累加和为22亿，那么你就要在这个范围上找第2亿个数；
5. 遍历40亿数，再次等分小范围，重复此过程，直到范围缩小为1。

-----

## 题目4：无序的10G数据文件排序的问题
题目描述：现有一个内容完全是整型数据的10GiB的文件，限定5GiB内存，如何保留文件中的所有数据并输出一个有序的文件？（5MiB 5KiB内存同理）

思路1：使用堆结构进行范围统计
1. 使用一个小根堆，元素的结构为：int数据本身和它出现的次数（一个元素占用8B空间），小根堆通过比较int数据本身来组织小根堆结构；
2. 小根堆内部出了元素占用的空间，还可能需要其他的内存占用，这里假设每个包含了其他占用的元素内存空间为16B，5GiB内存的小根堆支持$5\times2^{30}/16=5\times2^{26}$个元素，向下取整为$2^{27}$个；
3. int类型数据的范围是$-2^{31}\sim2^{31}-1$，共$2^{32}$种数，将其按照每份$2^{27}$个，可以分为$2^{5}$份，比如第一份的范围是$-2^{31}\sim-2^{31}+2^{27}$。
4. 遍历这10G数据，先统计第一份的范围上的数字（其他范围的数据跳过），遍历完一轮之后，小根堆种的数据就是第一个范围上的数据的词频状况；
5. 将小根堆中的数据依次输出到新文件中，在统计下一个范围上的数字，直到所有范围都统计一遍。

思路2：使用堆结构进行个数统计
1. 使用一个大根堆，元素结构同思路1，假设在内存限制的条件下大根堆最多维持1万个元素（根据内存限制来确定），再使用一个变量`min`来维持现在该统计的最小值（初始为$-2^{31}$），大根堆维持的这1万个元素是大于等于`min`的一万个最小的不同元素；
2. 文件中共有10GiB数据，需要遍历$10GiB/4B\times16B/1万$次；
3. 遍历到每一个int时，如果大根堆中元素数量小于1万，或者当前的int数据比大根堆堆顶元素小（或等于），就将该int数据插入大根堆，并调整大根堆，10GiB数据遍历完成后，`min`重新赋值为大根堆堆顶元素加1，并将这1万条记录按照每个数的词频写入新文件中；
4. 进行下一轮遍历，直到$min>2^{31}-1$。


