<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>【Linux系统编程】12 - 线程同步 | XuShun's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="XuShun的个人博客，记录学习和生活。"><link rel=prev href=https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B11-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/><link rel=canonical href=https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B12-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="【Linux系统编程】12 - 线程同步"><meta name=twitter:description content="同步 什么是同步 所谓同步，即同时起步，协调一致。不同的对象，对同步的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【Linux系统编程】12 - 线程同步","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xushun1221.github.io\/2022\/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B12-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5\/"},"image":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"Linux","wordcount":7866,"url":"https:\/\/xushun1221.github.io\/2022\/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B12-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5\/","datePublished":"2022-06-06T00:00:00\x2b00:00","dateModified":"2022-06-06T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xushun","logo":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">【Linux系统编程】12 - 线程同步</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2022-06-06>2022-06-06</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 7866 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://xushun1221.github.io/categories/coding/>Coding</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#同步>同步</a><ul><li><a href=#什么是同步>什么是同步</a></li><li><a href=#什么是线程同步>什么是线程同步</a></li><li><a href=#数据混乱的原因>数据混乱的原因</a></li></ul></li><li><a href=#互斥量锁-mutex>互斥量(锁) mutex</a><ul><li><a href=#互斥量的概念>互斥量的概念</a></li><li><a href=#互斥量操作函数>互斥量操作函数</a><ul><li><a href=#pthread_mutex_init--pthread_mutex_destroy>pthread_mutex_init / pthread_mutex_destroy</a></li></ul></li><li><a href=#pthread_mutex_lock--pthread_mutex_unlock>pthread_mutex_lock / pthread_mutex_unlock</a></li><li><a href=#理解加锁和解锁>理解加锁和解锁</a></li><li><a href=#练习---多个线程打印-hello-world>练习 - 多个线程打印 hello world</a><ul><li><a href=#不使用互斥锁>不使用互斥锁</a></li><li><a href=#使用互斥锁>使用互斥锁</a></li><li><a href=#分析>分析</a></li></ul></li><li><a href=#非阻塞加锁-pthread_mutex_trylock>非阻塞加锁 pthread_mutex_trylock</a></li><li><a href=#死锁>死锁</a></li></ul></li><li><a href=#读写锁>读写锁</a><ul><li><a href=#读写锁状态>读写锁状态</a></li><li><a href=#读写锁特性>读写锁特性</a></li><li><a href=#读写锁的操作函数>读写锁的操作函数</a><ul><li><a href=#pthread_rwlock_init--pthread_rwlock_destroy>pthread_rwlock_init / pthread_rwlock_destroy</a></li><li><a href=#pthread_rwlock_rdlock--pthread_rwlock_tryrdlock>pthread_rwlock_rdlock / pthread_rwlock_tryrdlock</a></li><li><a href=#pthread_rwlock_wrlock--pthread_rwlock_trywrlock>pthread_rwlock_wrlock / pthread_rwlock_trywrlock</a></li><li><a href=#pthread_rwlock_unlock>pthread_rwlock_unlock</a></li></ul></li><li><a href=#练习---使用读写锁>练习 - 使用读写锁</a></li></ul></li><li><a href=#条件变量>条件变量</a><ul><li><a href=#条件变量的操作函数>条件变量的操作函数</a><ul><li><a href=#pthread_cond_init--pthread_cond_destroy>pthread_cond_init / pthread_cond_destroy</a></li><li><a href=#pthread_cond_wait>pthread_cond_wait</a></li><li><a href=#pthread_cond_timedwait>pthread_cond_timedwait</a></li><li><a href=#pthread_cond_signal--pthread_cond_broadcast>pthread_cond_signal / pthread_cond_broadcast</a></li></ul></li><li><a href=#生产者-消费者-条件变量模型>生产者-消费者 条件变量模型</a></li><li><a href=#练习1---生产者-消费者-一对一>练习1 - 生产者-消费者 一对一</a></li><li><a href=#练习2---生产者-消费者-一对多>练习2 - 生产者-消费者 一对多</a></li><li><a href=#条件变量的优点>条件变量的优点</a></li></ul></li><li><a href=#信号量-semaphore>信号量 semaphore</a><ul><li><a href=#信号量的基本操作>信号量的基本操作</a></li><li><a href=#信号量操作函数>信号量操作函数</a><ul><li><a href=#sem_init--sem_destroy>sem_init / sem_destroy</a></li><li><a href=#sem_wait--sem_post>sem_wait / sem_post</a></li><li><a href=#sem_trywait--sem_timedwait>sem_trywait / sem_timedwait</a></li></ul></li><li><a href=#生产者-消费者-信号量模型>生产者-消费者 信号量模型</a></li><li><a href=#生产者-消费者-一对一实现>生产者-消费者 一对一实现</a></li></ul></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#同步>同步</a><ul><li><a href=#什么是同步>什么是同步</a></li><li><a href=#什么是线程同步>什么是线程同步</a></li><li><a href=#数据混乱的原因>数据混乱的原因</a></li></ul></li><li><a href=#互斥量锁-mutex>互斥量(锁) mutex</a><ul><li><a href=#互斥量的概念>互斥量的概念</a></li><li><a href=#互斥量操作函数>互斥量操作函数</a><ul><li><a href=#pthread_mutex_init--pthread_mutex_destroy>pthread_mutex_init / pthread_mutex_destroy</a></li></ul></li><li><a href=#pthread_mutex_lock--pthread_mutex_unlock>pthread_mutex_lock / pthread_mutex_unlock</a></li><li><a href=#理解加锁和解锁>理解加锁和解锁</a></li><li><a href=#练习---多个线程打印-hello-world>练习 - 多个线程打印 hello world</a><ul><li><a href=#不使用互斥锁>不使用互斥锁</a></li><li><a href=#使用互斥锁>使用互斥锁</a></li><li><a href=#分析>分析</a></li></ul></li><li><a href=#非阻塞加锁-pthread_mutex_trylock>非阻塞加锁 pthread_mutex_trylock</a></li><li><a href=#死锁>死锁</a></li></ul></li><li><a href=#读写锁>读写锁</a><ul><li><a href=#读写锁状态>读写锁状态</a></li><li><a href=#读写锁特性>读写锁特性</a></li><li><a href=#读写锁的操作函数>读写锁的操作函数</a><ul><li><a href=#pthread_rwlock_init--pthread_rwlock_destroy>pthread_rwlock_init / pthread_rwlock_destroy</a></li><li><a href=#pthread_rwlock_rdlock--pthread_rwlock_tryrdlock>pthread_rwlock_rdlock / pthread_rwlock_tryrdlock</a></li><li><a href=#pthread_rwlock_wrlock--pthread_rwlock_trywrlock>pthread_rwlock_wrlock / pthread_rwlock_trywrlock</a></li><li><a href=#pthread_rwlock_unlock>pthread_rwlock_unlock</a></li></ul></li><li><a href=#练习---使用读写锁>练习 - 使用读写锁</a></li></ul></li><li><a href=#条件变量>条件变量</a><ul><li><a href=#条件变量的操作函数>条件变量的操作函数</a><ul><li><a href=#pthread_cond_init--pthread_cond_destroy>pthread_cond_init / pthread_cond_destroy</a></li><li><a href=#pthread_cond_wait>pthread_cond_wait</a></li><li><a href=#pthread_cond_timedwait>pthread_cond_timedwait</a></li><li><a href=#pthread_cond_signal--pthread_cond_broadcast>pthread_cond_signal / pthread_cond_broadcast</a></li></ul></li><li><a href=#生产者-消费者-条件变量模型>生产者-消费者 条件变量模型</a></li><li><a href=#练习1---生产者-消费者-一对一>练习1 - 生产者-消费者 一对一</a></li><li><a href=#练习2---生产者-消费者-一对多>练习2 - 生产者-消费者 一对多</a></li><li><a href=#条件变量的优点>条件变量的优点</a></li></ul></li><li><a href=#信号量-semaphore>信号量 semaphore</a><ul><li><a href=#信号量的基本操作>信号量的基本操作</a></li><li><a href=#信号量操作函数>信号量操作函数</a><ul><li><a href=#sem_init--sem_destroy>sem_init / sem_destroy</a></li><li><a href=#sem_wait--sem_post>sem_wait / sem_post</a></li><li><a href=#sem_trywait--sem_timedwait>sem_trywait / sem_timedwait</a></li></ul></li><li><a href=#生产者-消费者-信号量模型>生产者-消费者 信号量模型</a></li><li><a href=#生产者-消费者-一对一实现>生产者-消费者 一对一实现</a></li></ul></li></ul></nav></div></details></div><div class=post-content><a class=post-dummy-target id=同步></a><h2>同步</h2><a class=post-dummy-target id=什么是同步></a><h3>什么是同步</h3><p>所谓同步，即同时起步，协调一致。不同的对象，对<strong>同步</strong>的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；数据库同步，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；文件同步，是指让两个或多个文件夹里的文件保持一致。等等。</p><p>而编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。同字应是指协同、协助、互相配合。主旨在协同步调，按预定的<strong>先后次序</strong>运行。</p><a class=post-dummy-target id=什么是线程同步></a><h3>什么是线程同步</h3><p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p><p>举例 1： 银行存款 5000。柜台，折：取 3000；提款机，卡：取 3000。剩余：2000</p><p>举例 2： 内存中 100 字节，线程 T1 欲填入全 1， 线程 T2 欲填入全 0。但如果 T1 执行了 50 个字节失去 cpu，T2执行，会将 T1 写过的内容覆盖。当 T1 再次获得 cpu 继续 从失去 cpu 的位置向后写入 1，当执行结束，内存中的100 字节，既不是全 1，也不是全 0。</p><p>产生的现象叫做<strong>与时间有关的错误(time related)</strong>。为了避免这种数据混乱，线程需要同步。</p><p>同步的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</p><p>因此，所有<strong>多个控制流，共同操作一个共享资源</strong>的情况，都需要同步。</p><a class=post-dummy-target id=数据混乱的原因></a><h3>数据混乱的原因</h3><ol><li>资源共享（独享的数据则不会）</li><li>调度随机（意味着数据访问会出现竞争）</li><li>线程间缺乏必要的同步机制</li></ol><p>以上 3 点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。</p><p>所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p><a class=post-dummy-target id=互斥量锁-mutex></a><h2>互斥量(锁) mutex</h2><a class=post-dummy-target id=互斥量的概念></a><h3>互斥量的概念</h3><p>Linux中提供互斥量（mutex），也叫互斥锁。</p><p>使用互斥锁的一半流程：每个线程在对共享资源进行操作前都需要尝试加锁，成功加锁之后才能操作，操作完成后，解锁。（对同一个数据，同一个时刻，只有一个线程持有锁）</p><p>共享资源还是共享的，线程之间也还是竞争的，但是通过<strong>锁</strong>，就将资源的访问变成了互斥的操作，而后关于时间的错误也不会发生了。</p><p>请看示意图：<br><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=/post_images/posts/Coding/%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9112/%e4%ba%92%e6%96%a5%e9%87%8f%e7%a4%ba%e6%84%8f%e5%9b%be.jpg alt title=互斥量示意图 class=lazyload><figcaption class=image-caption>互斥量示意图</figcaption></figure></p><p>假设这样一种情况：当前有三个线程（T1，T2，T3），它们都向对共享数据进行操作，分别将数据填充为<code>000..</code>，<code>111..</code>，<code>777..</code>。</p><ol><li>此时，T1线程获得了CPU时间片，并拿到了互斥锁，它开始向共享数据中写<code>000..</code>。</li><li>T1的时间片结束后，此时T2线程开始执行，它要操作共享数据需要申请锁，它就会阻塞在锁上，并释放CPU。</li><li>此时T3线程开始执行，<ol><li>如果T3线程也去申请锁，那它也会阻塞在锁上，并释放CPU，T1重新获得CPU并开始继续填充<code>000..</code>。</li><li>如果T3线程，不去申请锁，那它可以操作共享数据吗？答案是可以。它会向共享数据内填写<code>777..</code>直到时间片结束，这样就破坏了T1线程的工作，数据出现混乱。</li></ol></li></ol><p>这个例子表明，互斥量（互斥锁）不是强制性的，它实际上是Linux系统提供的一把<strong>建议锁</strong>（也称协同锁）。建议在多线程访问共享数据时使用该机制，但是并没有强制限定。</p><p>所以，必须使用互斥锁来操作共享数据。</p><a class=post-dummy-target id=互斥量操作函数></a><h3>互斥量操作函数</h3><p>和互斥锁相关的操作函数主要有以下五个：</p><ul><li><code>pthread_mutex_init</code>；初始化锁；</li><li><code>pthread_mutex_destroy</code>：销毁锁；</li><li><code>pthread_mutex_lock</code>：加锁；</li><li><code>pthread_mutex_trylock</code>：（非阻塞）尝试加锁；</li><li><code>pthread_mutex_unlock</code>：解锁；</li><li>它们的成功返回值都为<code>0</code>，失败返回值都是错误号。</li></ul><p>Ubuntu默认没有安装POSIX标准的文档，可以自己安装一下：<code>sudo apt-get install manpages-posix-dev</code>。</p><a class=post-dummy-target id=pthread_mutex_init--pthread_mutex_destroy></a><h4>pthread_mutex_init / pthread_mutex_destroy</h4><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>pthread_mutex_destroy</span><span class=p>(</span><span class=n>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span>
<span class=kt>int</span> <span class=nf>pthread_mutex_init</span><span class=p>(</span><span class=n>pthread_mutex_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>mutex</span><span class=p>,</span>
    <span class=k>const</span> <span class=n>pthread_mutexattr_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>attr</span><span class=p>)</span><span class=p>;</span>
<span class=n>pthread_mutex_t</span> <span class=n>mutex</span> <span class=o>=</span> <span class=n>PTHREAD_MUTEX_INITIALIZER</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li>返回值：<ul><li>成功，返回<code>0</code>；</li><li>失败，返回错误号。</li></ul></li><li><code>mutex</code>：保存创建的互斥量，或要销毁的信号量；</li><li><code>attr</code>：互斥量的属性，默认传<code>NULL</code>。（参阅APUE.12.4同步属性）</li></ul><p>注，<code>restrict</code>关键字，用来限定指针变量，被该关键字限定的指针变量所指向的内存操作，必须由本指针完成，不能由其他指针修改。</p><p>使用<code>pthread_mutex_init(&mutex, NULL)</code>可以动态创建互斥锁，也可以使用宏静态创建<code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER</code>。</p><a class=post-dummy-target id=pthread_mutex_lock--pthread_mutex_unlock></a><h3>pthread_mutex_lock / pthread_mutex_unlock</h3><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=n>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span>
<span class=kt>int</span> <span class=nf>pthread_mutex_trylock</span><span class=p>(</span><span class=n>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span>
<span class=kt>int</span> <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=n>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li>返回值：<ul><li>成功，返回<code>0</code>；</li><li>失败，返回错误号。</li></ul></li></ul><a class=post-dummy-target id=理解加锁和解锁></a><h3>理解加锁和解锁</h3><p>我们可以将互斥锁<strong>看作一个整数</strong>（只能为<code>0</code>或<code>1</code>），当我们初始化一个互斥锁<code>pthread_mutex_t mute</code>，它的值为<code>1</code>。</p><ul><li>使用<code>pthread_mutex_lock</code>尝试加锁，<ul><li>如果加锁不成功（<code>mutex == 0</code>），线程阻塞，直到持有该锁的其他线程解锁为止；</li><li>如果成功加锁（<code>mutex == 1</code>），<code>mutex --</code>，访问共享资源。</li></ul></li><li>使用<code>pthread_mutex_unlock</code>解锁，<code>mutex ++</code>，解锁的同时，会将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度等。默认情况是，先被该锁阻塞的线程，先唤醒。</li></ul><a class=post-dummy-target id=练习---多个线程打印-hello-world></a><h3>练习 - 多个线程打印 hello world</h3><p>我们希望编写这样一个程序：使用两个线程，主线程和一个子线程交替打印<code>hello world</code>这两个单词，每个线程在打印一个单词后，要sleep几秒钟，主线程大写，子线程小写。</p><a class=post-dummy-target id=不使用互斥锁></a><h4>不使用互斥锁</h4><p>原始程序：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span><span class=o>*</span> <span class=nf>tfunc</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>hello </span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>3</span><span class=p>)</span><span class=p>;</span>
        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>world</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>3</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>pthread_exit</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span><span class=o>*</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
    <span class=n>pthread_t</span> <span class=n>tid</span><span class=p>;</span>
    <span class=n>srand</span><span class=p>(</span><span class=n>time</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>tfunc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_create error : %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>ret</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>HELLO </span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>3</span><span class=p>)</span><span class=p>;</span>
        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>WORLD</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>3</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_join</span><span class=p>(</span><span class=n>tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_join error : %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>ret</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>测试结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_thdsyn$ ./hello 
HELLO hello world
WORLD
hello HELLO world
WORLD
hello world
HELLO hello WORLD
HELLO WORLD
^C
xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_thdsyn$ 
</code></pre></td></tr></table></div></div><p>测试结果，输出的内容乱七八糟，大小写的<code>hello world</code>不能完整输出，而是交叉输出，原因是没有互斥地使用STDOUT。</p><a class=post-dummy-target id=使用互斥锁></a><h4>使用互斥锁</h4><p>使用互斥量进行输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=n>pthread_mutex_t</span> <span class=n>mutex</span><span class=p>;</span> <span class=c1>// 互斥锁
</span><span class=c1></span>
<span class=kt>void</span><span class=o>*</span> <span class=nf>tfunc</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 加锁
</span><span class=c1></span>        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>hello </span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>3</span><span class=p>)</span><span class=p>;</span>
        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>world</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 解锁
</span><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>3</span><span class=p>)</span><span class=p>;</span>
        <span class=c1>// pthread_mutex_unlock(&amp;mutex); // ***解锁***
</span><span class=c1></span>    <span class=p>}</span>
    <span class=n>pthread_exit</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span><span class=o>*</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
    <span class=n>pthread_t</span> <span class=n>tid</span><span class=p>;</span>
    <span class=n>srand</span><span class=p>(</span><span class=n>time</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_mutex_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 创建互斥锁
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_mutex_init error : %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>ret</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>tfunc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_create error : %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>ret</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 加锁
</span><span class=c1></span>        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>HELLO </span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>3</span><span class=p>)</span><span class=p>;</span>
        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>WORLD</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 解锁
</span><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>3</span><span class=p>)</span><span class=p>;</span>
        <span class=c1>// pthread_mutex_unlock(&amp;mutex); // ***解锁***
</span><span class=c1></span>    <span class=p>}</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_join</span><span class=p>(</span><span class=n>tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_join error : %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>ret</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_mutex_destroy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 销毁互斥锁
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_destroy error : %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>ret</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>测试结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_thdsyn$ ./mutex 
HELLO WORLD
hello world
HELLO WORLD
hello world
HELLO WORLD
HELLO WORLD
hello world
hello world
HELLO WORLD
^C
xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_thdsyn$ 
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=分析></a><h4>分析</h4><ol><li>定义了全局的互斥量；</li><li>两个线程的<code>while</code>中，两次<code>printf</code>前后进行了加锁和解锁；</li><li>如果将解锁位置挪到第二个<code>sleep</code>之后，发现线程交替打印的现象难以出现；<ul><li>原因：线程操作完共享资源后，本应该立即释放，但是，操作完成后，抱着锁睡眠，睡醒后又立即加锁，这两个库函数本身不会阻塞，所以在这两行代码之间失去CPU的 概率非常小，因此，另一个线程很难获得加锁的机会；</li><li>结论：尽可能让锁的<strong>粒度变小</strong>（访问共享资源前，加锁，访问结束后，<strong>立即</strong>解锁）。</li></ul></li><li>如果主线程输出几次后就退出循环，试图销毁锁，但子线程没有释放锁，销毁操作就无法完成。</li></ol><a class=post-dummy-target id=非阻塞加锁-pthread_mutex_trylock></a><h3>非阻塞加锁 pthread_mutex_trylock</h3><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>pthread_mutex_trylock</span><span class=p>(</span><span class=n>pthread_mutex_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>该函数尝试加锁，成功返回<code>0</code>，如果失败，就直接返回错误号，不会阻塞。</p><a class=post-dummy-target id=死锁></a><h3>死锁</h3><p>是使用锁不恰当导致的一种现象。</p><ol><li>对同一个互斥量反复加锁，如果线程已经持有锁，又对该锁进行加锁，会阻塞形成死锁；</li><li>如果两个线程各自持有一把锁，又请求对对方的锁进行加锁，双方都阻塞，导致死锁。</li></ol><a class=post-dummy-target id=读写锁></a><h2>读写锁</h2><p>读写锁，与互斥量类似，但是读写锁允许更高的并行性。其特性为：<strong>读共享，写独占</strong>。</p><a class=post-dummy-target id=读写锁状态></a><h3>读写锁状态</h3><p>强调：读写锁<strong>只有一把</strong>，但是具有两种状态，</p><ol><li>读模式下加锁状态（读锁）</li><li>写模式下加锁状态（写锁）</li></ol><a class=post-dummy-target id=读写锁特性></a><h3>读写锁特性</h3><ol><li>读写锁为<strong>写锁</strong>时，解锁前，<strong>所有</strong>对该锁加锁的线程都会被阻塞；</li><li>读写锁为<strong>读锁</strong>时，<ol><li>如果线程以读模式加锁，会成功；</li><li>如果线程以写模式加锁，会阻塞；</li></ol></li><li>读写锁为<strong>读锁</strong>时，如果既有以读模式加锁的线程，也有以写模式加锁的线程，那么读写锁会阻塞随后的读锁请求，优先满足写锁请求。（读锁、写锁并行阻塞，<strong>写锁的优先级高</strong>）</li></ol><p>读写锁，也叫<strong>共享-独占锁</strong>，当读写锁以读模式锁住时，它是以共享模式锁住的；当读写锁以写模式锁住时，它是以独占模式锁住的。（读共享，写独占）</p><p>读写锁非常适用于对数据的读的次数远大于写的次数的情况。</p><a class=post-dummy-target id=读写锁的操作函数></a><h3>读写锁的操作函数</h3><p>和互斥锁类似，读写锁的操作函数主要有以下几个：</p><ul><li><code>pthread_rwlock_init</code>：创建读写锁；</li><li><code>pthread_rwlock_destroy</code>：销毁读写锁；</li><li><code>pthread_rwlock_rdlock</code>：加读锁；</li><li><code>pthread_rwlock_wrlock</code>：加写锁；</li><li><code>pthread_rwlock_tryrdlock</code>：（非阻塞）尝试加读锁；</li><li><code>pthread_rwlock_trywrlock</code>：（非阻塞）尝试加写锁；</li><li><code>pthread_rwlock_unlock</code> ：解锁；</li><li>返回值都是，成功返回<code>0</code>，失败返回错误码。</li></ul><a class=post-dummy-target id=pthread_rwlock_init--pthread_rwlock_destroy></a><h4>pthread_rwlock_init / pthread_rwlock_destroy</h4><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>pthread_rwlock_destroy</span><span class=p>(</span><span class=n>pthread_rwlock_t</span> <span class=o>*</span><span class=n>rwlock</span><span class=p>)</span><span class=p>;</span>
<span class=kt>int</span> <span class=nf>pthread_rwlock_init</span><span class=p>(</span><span class=n>pthread_rwlock_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>rwlock</span><span class=p>,</span>
    <span class=k>const</span> <span class=n>pthread_rwlockattr_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>attr</span><span class=p>)</span><span class=p>;</span>
<span class=n>pthread_rwlock_t</span> <span class=n>rwlock</span> <span class=o>=</span> <span class=n>PTHREAD_RWLOCK_INITIALIZER</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>和互斥锁使用方法相同。</p><p>动态创建读写锁<code>pthread_rwlock_init(&rwlock, NULL)</code>，静态创建读写锁<code>pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER</code>，效果相同。</p><a class=post-dummy-target id=pthread_rwlock_rdlock--pthread_rwlock_tryrdlock></a><h4>pthread_rwlock_rdlock / pthread_rwlock_tryrdlock</h4><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>pthread_rwlock_rdlock</span><span class=p>(</span><span class=n>pthread_rwlock_t</span> <span class=o>*</span><span class=n>rwlock</span><span class=p>)</span><span class=p>;</span>
<span class=kt>int</span> <span class=nf>pthread_rwlock_tryrdlock</span><span class=p>(</span><span class=n>pthread_rwlock_t</span> <span class=o>*</span><span class=n>rwlock</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>以读模式加锁，<code>tryrdlock</code>是非阻塞版本。</p><a class=post-dummy-target id=pthread_rwlock_wrlock--pthread_rwlock_trywrlock></a><h4>pthread_rwlock_wrlock / pthread_rwlock_trywrlock</h4><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>pthread_rwlock_trywrlock</span><span class=p>(</span><span class=n>pthread_rwlock_t</span> <span class=o>*</span><span class=n>rwlock</span><span class=p>)</span><span class=p>;</span>
<span class=kt>int</span> <span class=nf>pthread_rwlock_wrlock</span><span class=p>(</span><span class=n>pthread_rwlock_t</span> <span class=o>*</span><span class=n>rwlock</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>以写模式加锁，<code>trywrlock</code>是非阻塞版本。</p><a class=post-dummy-target id=pthread_rwlock_unlock></a><h4>pthread_rwlock_unlock</h4><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>pthread_rwlock_unlock</span><span class=p>(</span><span class=n>pthread_rwlock_t</span> <span class=o>*</span><span class=n>rwlock</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>解锁，无论读写模式加的锁，都使用该函数解锁。</p><a class=post-dummy-target id=练习---使用读写锁></a><h3>练习 - 使用读写锁</h3><p>代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=n>global_counter</span><span class=p>;</span>
<span class=n>pthread_rwlock_t</span> <span class=n>rwlock</span><span class=p>;</span>

<span class=kt>void</span><span class=o>*</span> <span class=nf>th_write</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>arg</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>t</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pthread_rwlock_wrlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rwlock</span><span class=p>)</span><span class=p>;</span>
        <span class=n>t</span> <span class=o>=</span> <span class=n>global_counter</span><span class=p>;</span>
        <span class=n>usleep</span><span class=p>(</span><span class=mi>1000</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 抱着睡 浪费时间
</span><span class=c1></span>        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>==write(%d - tid %lu) : %d, ++ counter %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>pthread_self</span><span class=p>(</span><span class=p>)</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=o>+</span><span class=o>+</span> <span class=n>global_counter</span><span class=p>)</span><span class=p>;</span>
        <span class=n>pthread_rwlock_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rwlock</span><span class=p>)</span><span class=p>;</span>
        <span class=n>usleep</span><span class=p>(</span><span class=mi>10000</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>void</span><span class=o>*</span> <span class=nf>th_read</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>arg</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pthread_rwlock_rdlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rwlock</span><span class=p>)</span><span class=p>;</span>
        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>--read (%d - tid %lu) : %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>pthread_self</span><span class=p>(</span><span class=p>)</span><span class=p>,</span> <span class=n>global_counter</span><span class=p>)</span><span class=p>;</span>
        <span class=n>pthread_rwlock_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rwlock</span><span class=p>)</span><span class=p>;</span>
        <span class=n>usleep</span><span class=p>(</span><span class=mi>2000</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span><span class=o>*</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 错误码判断就不写了 ^^
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
    <span class=n>pthread_t</span> <span class=n>tids</span><span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=p>;</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_rwlock_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rwlock</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=o>+</span><span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 3 write thread
</span><span class=c1></span>        <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=n>tids</span> <span class=o>+</span> <span class=n>i</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>th_write</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>i</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=o>+</span><span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 5 read  thread
</span><span class=c1></span>        <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=n>tids</span> <span class=o>+</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>3</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>th_read</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>i</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=o>+</span><span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_join</span><span class=p>(</span><span class=n>tids</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_rwlock_destroy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rwlock</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=条件变量></a><h2>条件变量</h2><p>条件变量，<strong>不是锁</strong>，但它可以阻塞线程。和互斥锁配合使用。给多线程提供一个会合的场所。</p><a class=post-dummy-target id=条件变量的操作函数></a><h3>条件变量的操作函数</h3><p>主要有这几个：</p><ul><li><code>pthread_cond_init</code>：创建条件变量；</li><li><code>pthread_cond_destroy</code>：销毁条件变量；</li><li><code>pthread_cond_wait</code>：阻塞等待条件满足；</li><li><code>pthread_cond_timedwait</code>：限时等待条件变量；</li><li><code>pthread_cond_signal</code>：通知；</li><li><code>pthread_cond_broadcast</code>：广播；</li><li>返回值，成功都返回<code>0</code>，失败都返回错误号。</li></ul><a class=post-dummy-target id=pthread_cond_init--pthread_cond_destroy></a><h4>pthread_cond_init / pthread_cond_destroy</h4><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>pthread_cond_destroy</span><span class=p>(</span><span class=n>pthread_cond_t</span> <span class=o>*</span><span class=n>cond</span><span class=p>)</span><span class=p>;</span>
<span class=kt>int</span> <span class=nf>pthread_cond_init</span><span class=p>(</span><span class=n>pthread_cond_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>cond</span><span class=p>,</span>
    <span class=k>const</span> <span class=n>pthread_condattr_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>attr</span><span class=p>)</span><span class=p>;</span>
<span class=n>pthread_cond_t</span> <span class=n>cond</span> <span class=o>=</span> <span class=n>PTHREAD_COND_INITIALIZER</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p><code>attr</code>：条件变量的属性，默认传<code>NULL</code>。</p><p>动态初始化<code>pthread_cond_init(&cond, NULL)</code>，静态初始化<code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER</code>。</p><a class=post-dummy-target id=pthread_cond_wait></a><h4>pthread_cond_wait</h4><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>pthread_cond_wait</span><span class=p>(</span><span class=n>pthread_cond_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>cond</span><span class=p>,</span>
    <span class=n>pthread_mutex_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>mutex</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>需要一个条件变量和一个互斥锁。</p><p>函数的作用：</p><ol><li><strong>阻塞</strong>等待条件变量<code>cond</code>满足；</li><li>释放已掌握的互斥锁（解锁），相当于<code>pthread_mutex_unlock(&mutex)</code>（之前要加锁）<ul><li>1，2两步为一个<strong>原子操作</strong></li></ul></li><li>当被唤醒（条件变量满足了），<code>pthread_cond_wait</code>函数返回时，解除阻塞并重新申请获得互斥锁（加锁）<code>pthread_mutex_lock(&mutex)</code></li></ol><p>条件满足的情况通过<code>pthread_cond_signal</code>和<code>pthread_cond_broadcast</code>通知。</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=/post_images/posts/Coding/%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9112/wait%e7%a4%ba%e6%84%8f%e5%9b%be.jpg alt title=wait示意图 class=lazyload><figcaption class=image-caption>wait示意图</figcaption></figure></p><a class=post-dummy-target id=pthread_cond_timedwait></a><h4>pthread_cond_timedwait</h4><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>pthread_cond_timedwait</span><span class=p>(</span><span class=n>pthread_cond_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>cond</span><span class=p>,</span>
    <span class=n>pthread_mutex_t</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>mutex</span><span class=p>,</span>
    <span class=k>const</span> <span class=k>struct</span> <span class=n>timespec</span> <span class=o>*</span><span class=kr>restrict</span> <span class=n>abstime</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li><code>abstime</code>：<code>struct timespec</code>类型的绝对时间的描述。</li></ul><p><code>man sem_timedwait</code>，查看<code>struct_timespec</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=n>timespec</span> <span class=p>{</span>
    <span class=n>time_t</span> <span class=n>tv_sec</span><span class=p>;</span>      <span class=cm>/* Seconds */</span>
    <span class=kt>long</span>   <span class=n>tv_nsec</span><span class=p>;</span>     <span class=cm>/* Nanoseconds [0 .. 999999999] */</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>该结构体表述的时间是<strong>绝对时间</strong>（从1970.01.01-00:00:01开始），正确用法如下：参阅APUE.11.6线程同步条件变量小节</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=n>time_t</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>time</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 获得当前时间
</span><span class=c1></span><span class=k>struct</span> <span class=n>timespec</span> <span class=n>t</span><span class=p>;</span>
<span class=n>t</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>=</span> <span class=n>cur</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// 定时一秒
</span><span class=c1></span><span class=n>pthread_cond_timedwait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=pthread_cond_signal--pthread_cond_broadcast></a><h4>pthread_cond_signal / pthread_cond_broadcast</h4><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>pthread_cond_broadcast</span><span class=p>(</span><span class=n>pthread_cond_t</span> <span class=o>*</span><span class=n>cond</span><span class=p>)</span><span class=p>;</span>
<span class=kt>int</span> <span class=nf>pthread_cond_signal</span><span class=p>(</span><span class=n>pthread_cond_t</span> <span class=o>*</span><span class=n>cond</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li>signal：唤醒<strong>至少一个</strong>阻塞在该条件变量上的线程；（不绝对是一个）</li><li>broadcast：唤醒全部阻塞在该条件变量上的线程。</li></ul><a class=post-dummy-target id=生产者-消费者-条件变量模型></a><h3>生产者-消费者 条件变量模型</h3><p>线程同步的经典案例即为生产者-消费者模型，借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产者向其中添加产品，消费者从中消费掉产品。</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=/post_images/posts/Coding/%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9112/%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f%e6%a8%a1%e5%9e%8b.jpg alt title=生产者消费者条件变量模型 class=lazyload><figcaption class=image-caption>生产者消费者条件变量模型</figcaption></figure></p><p>示意图可能不太能理解，参考下面的实现代码。</p><a class=post-dummy-target id=练习1---生产者-消费者-一对一></a><h3>练习1 - 生产者-消费者 一对一</h3><p>代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=c1>// 共享数据 链表形式
</span><span class=c1></span><span class=k>struct</span> <span class=n>msg</span><span class=p>{</span>
    <span class=kt>int</span> <span class=n>num</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>msg</span><span class=o>*</span> <span class=n>next</span><span class=p>;</span>
<span class=p>}</span><span class=p>;</span>
<span class=c1>// 初始链表中没有节点
</span><span class=c1></span><span class=k>struct</span> <span class=n>msg</span><span class=o>*</span> <span class=n>head</span><span class=p>;</span>

<span class=c1>// 静态初始化条件变量和互斥锁
</span><span class=c1></span><span class=n>pthread_cond_t</span> <span class=n>cond</span> <span class=o>=</span> <span class=n>PTHREAD_COND_INITIALIZER</span><span class=p>;</span> <span class=c1>// 链表中是否新增数据了
</span><span class=c1></span><span class=n>pthread_mutex_t</span> <span class=n>mutex</span> <span class=o>=</span> <span class=n>PTHREAD_MUTEX_INITIALIZER</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>err_pthread</span><span class=p>(</span><span class=kt>int</span> <span class=n>ret</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>!</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>%s : %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>ret</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
        <span class=n>pthread_exit</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span><span class=o>*</span> <span class=nf>procuder_pthread</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 生产一个节点
</span><span class=c1></span>        <span class=k>struct</span> <span class=n>msg</span><span class=o>*</span> <span class=n>m</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>msg</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
        <span class=n>m</span> <span class=o>-</span><span class=o>&gt;</span> <span class=n>num</span> <span class=o>=</span> <span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>1000</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>++producer : %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>m</span> <span class=o>-</span><span class=o>&gt;</span> <span class=n>num</span><span class=p>)</span><span class=p>;</span>
        <span class=c1>// 将生产的节点放入共享链表
</span><span class=c1></span>        <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 尝试加锁
</span><span class=c1></span>        <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_mutex_lock error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>m</span> <span class=o>-</span><span class=o>&gt;</span> <span class=n>next</span> <span class=o>=</span> <span class=n>head</span><span class=p>;</span> <span class=c1>// 新节点头插 放入链表
</span><span class=c1></span>        <span class=n>head</span> <span class=o>=</span> <span class=n>m</span><span class=p>;</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 解锁
</span><span class=c1></span>        <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_mutex_unlock error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=c1>// 通知阻塞的消费者 有新的节点
</span><span class=c1></span>        <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>)</span><span class=p>;</span>
        <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_cond_signal error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>3</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 放弃CPU
</span><span class=c1></span>    <span class=p>}</span>
    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>void</span><span class=o>*</span> <span class=nf>consumer_pthread</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>struct</span> <span class=n>msg</span><span class=o>*</span> <span class=n>m</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 尝试加锁
</span><span class=c1></span>        <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_mutex_lock error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>head</span> <span class=o>=</span><span class=o>=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 拿到锁 但是没有数据 就阻塞等待条件变量通知 解锁 条件变量满足时再次尝试加锁
</span><span class=c1></span>            <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span>
            <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_cond_wait error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 跳出循环 1. 链表中有数据 2. 无数据 wait阻塞 条件变量满足通知 重新竞争到锁
</span><span class=c1></span>        <span class=c1>// 进行消费
</span><span class=c1></span>        <span class=n>m</span> <span class=o>=</span> <span class=n>head</span><span class=p>;</span> <span class=c1>// 把链表的第一个节点取下
</span><span class=c1></span>        <span class=n>head</span> <span class=o>=</span> <span class=n>m</span> <span class=o>-</span><span class=o>&gt;</span> <span class=n>next</span><span class=p>;</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 消费完共享数据 解锁
</span><span class=c1></span>        <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_mutex_unlock error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>--consumer : %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>m</span> <span class=o>-</span><span class=o>&gt;</span> <span class=n>num</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 打印获得的节点
</span><span class=c1></span>        <span class=n>free</span><span class=p>(</span><span class=n>m</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 释放内存
</span><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>3</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 放弃CPU
</span><span class=c1></span>    <span class=p>}</span>
    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span><span class=o>*</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
    <span class=n>srand</span><span class=p>(</span><span class=n>time</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
    <span class=n>pthread_t</span> <span class=n>prod_tid</span><span class=p>,</span> <span class=n>cons_tid</span><span class=p>;</span>
    <span class=c1>// 创建线程 生产者-消费者
</span><span class=c1></span>    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>prod_tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>procuder_pthread</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_create error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cons_tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>consumer_pthread</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_create error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=c1>// 回收线程
</span><span class=c1></span>    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_join</span><span class=p>(</span><span class=n>prod_tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_join error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_join</span><span class=p>(</span><span class=n>cons_tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_join error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>测试结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_thdsyn$ ./cond_prod_cons 
++producer : 89
--consumer : 89
++producer : 820
--consumer : 820
++producer : 271
--consumer : 271
++producer : 725
--consumer : 725
++producer : 339
--consumer : 339
++producer : 841
++producer : 520
++producer : 64
--consumer : 64
--consumer : 520
--consumer : 841
++producer : 146
++producer : 771
--consumer : 771
++producer : 63
--consumer : 63
++producer : 591
--consumer : 591
--consumer : 146
^C
xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_thdsyn$ 
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=练习2---生产者-消费者-一对多></a><h3>练习2 - 生产者-消费者 一对多</h3><p>代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=c1>// 其他略了
</span><span class=c1></span>
<span class=kt>void</span><span class=o>*</span> <span class=nf>consumer_pthread</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>struct</span> <span class=n>msg</span><span class=o>*</span> <span class=n>m</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 尝试加锁
</span><span class=c1></span>        <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_mutex_lock error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=c1>// *******************************************
</span><span class=c1></span>        <span class=k>while</span> <span class=p>(</span><span class=n>head</span> <span class=o>=</span><span class=o>=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 拿到锁 但是没有数据 就阻塞等待条件变量通知 解锁 条件变量满足时再次尝试加锁
</span><span class=c1></span>            <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span>
            <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_cond_wait error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
            <span class=c1>// 当线程结束等待并获得锁时
</span><span class=c1></span>            <span class=c1>// 有可能共享内容被消费完了
</span><span class=c1></span>            <span class=c1>// 不能退出循环进行消费 需要重新等待生产者的通知
</span><span class=c1></span>        <span class=p>}</span>
        <span class=c1>// ********************************************
</span><span class=c1></span>        <span class=c1>// 跳出循环 1. 链表中有数据 2. 无数据 wait阻塞 条件变量满足通知 重新竞争到锁
</span><span class=c1></span>        <span class=c1>// 进行消费
</span><span class=c1></span>        <span class=n>m</span> <span class=o>=</span> <span class=n>head</span><span class=p>;</span> <span class=c1>// 把链表的第一个节点取下
</span><span class=c1></span>        <span class=n>head</span> <span class=o>=</span> <span class=n>m</span> <span class=o>-</span><span class=o>&gt;</span> <span class=n>next</span><span class=p>;</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 消费完共享数据 解锁
</span><span class=c1></span>        <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_mutex_unlock error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>--consumer(%lu) : %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pthread_self</span><span class=p>(</span><span class=p>)</span><span class=p>,</span> <span class=n>m</span> <span class=o>-</span><span class=o>&gt;</span> <span class=n>num</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 打印获得的节点
</span><span class=c1></span>        <span class=n>free</span><span class=p>(</span><span class=n>m</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 释放内存
</span><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>3</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 放弃CPU
</span><span class=c1></span>    <span class=p>}</span>
    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span><span class=o>*</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
    <span class=n>srand</span><span class=p>(</span><span class=n>time</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
    <span class=n>pthread_t</span> <span class=n>prod_tid</span><span class=p>,</span> <span class=n>cons_tids</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span><span class=p>;</span>
    <span class=c1>// 创建线程 生产者-消费者
</span><span class=c1></span>    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>prod_tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>procuder_pthread</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_create error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=o>+</span><span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=n>cons_tids</span> <span class=o>+</span> <span class=n>i</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>consumer_pthread</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
        <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_create error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// 回收线程
</span><span class=c1></span>    <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_join</span><span class=p>(</span><span class=n>prod_tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_join error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=o>+</span><span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=n>pthread_join</span><span class=p>(</span><span class=n>cons_tids</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
        <span class=n>err_pthread</span><span class=p>(</span><span class=n>ret</span><span class=p>,</span> <span class=sa></span><span class=s>&#34;</span><span class=s>pthread_join error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>测试结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_thdsyn$ ./cond_prod_cons_more 
++producer : 794
--consumer(140171192317696) : 794
++producer : 480
--consumer(140171183924992) : 480
++producer : 375
--consumer(140171089540864) : 375
++producer : 910
--consumer(140171175532288) : 910
++producer : 50
--consumer(140171167139584) : 50
^C
xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_thdsyn$ 
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=条件变量的优点></a><h3>条件变量的优点</h3><p>相较于 mutex 而言，条件变量可以减少竞争。</p><p>如直接使用 mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引 起消费者之间的竞争。提高了程序效率。</p><a class=post-dummy-target id=信号量-semaphore></a><h2>信号量 semaphore</h2><p>可以看作是进阶版的互斥量（初始化值为N的互斥量）。N表示可以同时访问共享数据区的线程数。</p><p>由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。</p><p>信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p><a class=post-dummy-target id=信号量的基本操作></a><h3>信号量的基本操作</h3><ul><li><code>sem_wait</code>：类似于<code>pthread_mutex_lock</code><ul><li>如果信号量大于0，则将信号量减一；</li><li>如果信号量为0，线程阻塞。</li></ul></li><li><code>sem_post</code>：类似于<code>phtread_mutex_unlock</code><ul><li>将信号量加一，同时唤醒阻塞在信号量上的线程。</li></ul></li><li><code>sem_t</code>的实现对用户是隐藏的，所以对信号量的加减操作只能通过函数完成；</li><li>信号量的初值，决定了能占用信号量的线程的个数。</li></ul><a class=post-dummy-target id=信号量操作函数></a><h3>信号量操作函数</h3><p>主要操作函数如下：</p><ul><li><code>sem_init</code>：创建信号量；</li><li><code>sem_destroy</code>：销毁信号量；</li><li><code>sem_wait</code>：相当于mutex加锁；</li><li><code>sem_trywait</code>：非阻塞的wait；</li><li><code>sem_timedwait</code>：有限时的wait；</li><li><code>sem_post</code>：相当于mutex解锁；</li><li>它们的返回值，成功返回<code>0</code>，失败返回<code>-1</code>，并设置<code>errno</code>。</li></ul><p>注意，信号量相关函数没有<code>pthread</code>前缀，错误返回方式也和<code>pthread_*</code>不同。</p><p>（信号量不仅可以使用在线程中，也可以使用在进程中）</p><a class=post-dummy-target id=sem_init--sem_destroy></a><h4>sem_init / sem_destroy</h4><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;semaphore.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>sem_init</span><span class=p>(</span><span class=n>sem_t</span> <span class=o>*</span><span class=n>sem</span><span class=p>,</span> <span class=kt>int</span> <span class=n>pshared</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>value</span><span class=p>)</span><span class=p>;</span>      <span class=kt>int</span> <span class=nf>sem_destroy</span><span class=p>(</span><span class=n>sem_t</span> <span class=o>*</span><span class=n>sem</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li><code>pshared</code>：process shared，表示是否在进程间共享<ul><li><code>0</code>：用于线程间同步；</li><li>非零，通常为<code>1</code>：用于进程间同步。</li></ul></li><li><code>value</code>：指定可以同时访问的线程数。</li></ul><p>好像不能静态初始化。</p><a class=post-dummy-target id=sem_wait--sem_post></a><h4>sem_wait / sem_post</h4><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;semaphore.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>sem_wait</span><span class=p>(</span><span class=n>sem_t</span> <span class=o>*</span><span class=n>sem</span><span class=p>)</span><span class=p>;</span> <span class=c1>// -- 
</span><span class=c1></span><span class=kt>int</span> <span class=nf>sem_post</span><span class=p>(</span><span class=n>sem_t</span> <span class=o>*</span><span class=n>sem</span><span class=p>)</span><span class=p>;</span> <span class=c1>// ++
</span></code></pre></td></tr></table></div></div><a class=post-dummy-target id=sem_trywait--sem_timedwait></a><h4>sem_trywait / sem_timedwait</h4><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;semaphore.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>sem_trywait</span><span class=p>(</span><span class=n>sem_t</span> <span class=o>*</span><span class=n>sem</span><span class=p>)</span><span class=p>;</span>
<span class=kt>int</span> <span class=nf>sem_timedwait</span><span class=p>(</span><span class=n>sem_t</span> <span class=o>*</span><span class=n>sem</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>timespec</span> <span class=o>*</span><span class=n>abs_timeout</span><span class=p>)</span><span class=p>;</span>

<span class=k>struct</span> <span class=n>timespec</span> <span class=p>{</span>
    <span class=n>time_t</span> <span class=n>tv_sec</span><span class=p>;</span>      <span class=cm>/* Seconds */</span>
    <span class=kt>long</span>   <span class=n>tv_nsec</span><span class=p>;</span>     <span class=cm>/* Nanoseconds [0 .. 999999999] */</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li>trywait：非阻塞的wait；</li><li>timedwait：有限时的wait；</li><li><code>abs_timeout</code>，使用的是绝对时间（从1970.01.01-00:00:01开始）</li></ul><p>正确使用方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=n>tiem_t</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>time</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
<span class=k>struct</span> <span class=n>timespec</span> <span class=n>t</span><span class=p>;</span>
<span class=n>t</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>=</span> <span class=n>cur</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// 定时一秒
</span><span class=c1></span><span class=n>sem_timedwait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sem</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=生产者-消费者-信号量模型></a><h3>生产者-消费者 信号量模型</h3><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=/post_images/posts/Coding/%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9112/%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e4%bf%a1%e5%8f%b7%e9%87%8f%e6%a8%a1%e5%9e%8b.jpg alt title=生产者消费者信号量模型 class=lazyload><figcaption class=image-caption>生产者消费者信号量模型</figcaption></figure></p><a class=post-dummy-target id=生产者-消费者-一对一实现></a><h3>生产者-消费者 一对一实现</h3><p>代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;semaphore.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=c1>// 错误输出就不写了^^
</span><span class=c1></span>
<span class=cp>#</span><span class=cp>define NUM 5</span><span class=cp>
</span><span class=cp></span><span class=c1>// 存放产品的循环队列
</span><span class=c1></span><span class=kt>int</span> <span class=n>queue</span><span class=p>[</span><span class=n>NUM</span><span class=p>]</span><span class=p>;</span>
<span class=c1>// 空格子信号量  产品数信号量
</span><span class=c1></span><span class=n>sem_t</span> <span class=n>blank_num</span><span class=p>,</span> <span class=n>product_num</span><span class=p>;</span>

<span class=kt>void</span><span class=o>*</span> <span class=nf>producer</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>blank_num</span><span class=p>)</span><span class=p>;</span> <span class=c1>// --空格子数
</span><span class=c1></span>        <span class=n>queue</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>1000</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// 生产一个产品
</span><span class=c1></span>        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>++produce : %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>queue</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=p>)</span><span class=p>;</span>
        <span class=n>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>product_num</span><span class=p>)</span><span class=p>;</span> <span class=c1>// ++ 产品数
</span><span class=c1></span>        <span class=n>i</span> <span class=o>=</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>NUM</span><span class=p>;</span> <span class=c1>// 循环队列
</span><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>1</span><span class=p>)</span><span class=p>;</span> <span class=c1>// CPU让给消费者
</span><span class=c1></span>    <span class=p>}</span>
    <span class=n>pthread_exit</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>void</span><span class=o>*</span> <span class=nf>consumer</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>product_num</span><span class=p>)</span><span class=p>;</span> <span class=c1>// -- 产品数
</span><span class=c1></span>        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>--consumer : %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>queue</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 消费一个商品
</span><span class=c1></span>        <span class=n>queue</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=n>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>blank_num</span><span class=p>)</span><span class=p>;</span> <span class=c1>// ++ 格子数
</span><span class=c1></span>        <span class=n>i</span> <span class=o>=</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>NUM</span><span class=p>;</span>
        <span class=n>sleep</span><span class=p>(</span><span class=n>rand</span><span class=p>(</span><span class=p>)</span> <span class=o>%</span> <span class=mi>3</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 让出CPU
</span><span class=c1></span>    <span class=p>}</span>
    <span class=n>pthread_exit</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span><span class=o>*</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>pthread_t</span> <span class=n>prod_tid</span><span class=p>,</span> <span class=n>cons_tid</span><span class=p>;</span>
    <span class=n>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>blank_num</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>NUM</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 初始空格子5个
</span><span class=c1></span>    <span class=n>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>product_num</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span><span class=p>;</span> <span class=c1>// 初始产品0个
</span><span class=c1></span>    <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>prod_tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>producer</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cons_tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>consumer</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=n>pthread_join</span><span class=p>(</span><span class=n>prod_tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=n>pthread_join</span><span class=p>(</span><span class=n>cons_tid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span><span class=p>;</span>
    <span class=n>sem_destroy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>blank_num</span><span class=p>)</span><span class=p>;</span>
    <span class=n>sem_destroy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>product_num</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>测试结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_thdsyn$ ./sem_prod_cons 
++produce : 384
--consumer : 384
++produce : 916
++produce : 336
--consumer : 916
++produce : 650
++produce : 363
++produce : 691
--consumer : 336
++produce : 927
++produce : 427
--consumer : 650
++produce : 212
--consumer : 363
++produce : 430
--consumer : 691
++produce : 863
^C
xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_thdsyn$ 
</code></pre></td></tr></table></div></div></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>xushun</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2022-06-06</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fxushun1221.github.io%2f2022%2flinux%25E7%25B3%25BB%25E7%25BB%259F%25E7%25BC%2596%25E7%25A8%258B12-%25E7%25BA%25BF%25E7%25A8%258B%25E5%2590%258C%25E6%25AD%25A5%2f&text=%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9112%20-%20%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fxushun1221.github.io%2f2022%2flinux%25E7%25B3%25BB%25E7%25BB%259F%25E7%25BC%2596%25E7%25A8%258B12-%25E7%25BA%25BF%25E7%25A8%258B%25E5%2590%258C%25E6%25AD%25A5%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fxushun1221.github.io%2f2022%2flinux%25E7%25B3%25BB%25E7%25BB%259F%25E7%25BC%2596%25E7%25A8%258B12-%25E7%25BA%25BF%25E7%25A8%258B%25E5%2590%258C%25E6%25AD%25A5%2f&title=%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9112%20-%20%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://xushun1221.github.io/tags/linux/><i class="fas fa-tag fa-fw"></i>&nbsp;Linux</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://xushun1221.github.io>Home</a></span></section></div><div class=post-nav><a href=https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B11-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/ class=prev rel=prev title="【Linux系统编程】11 - 守护进程、线程"><i class="fas fa-angle-left fa-fw"></i>【Linux系统编程】11 - 守护进程、线程</a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xushun1221.github.io/about/ target=_blank>xushun</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>