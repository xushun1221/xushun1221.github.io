<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>CS144 Lab Assignment lab-3 | XuShun's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="XuShun的个人博客，记录学习和生活。"><link rel=prev href=https://xushun1221.github.io/2022/cs144-lab-assignment-lab-2/><link rel=next href=https://xushun1221.github.io/2022/cs144-lab-assignment-lab-4/><link rel=canonical href=https://xushun1221.github.io/2022/cs144-lab-assignment-lab-3/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="CS144 Lab Assignment lab-3"><meta name=twitter:description content="the TCP sender 本次实验是TCP的sender，需要完成的主要功能有： 跟踪接收方的接收窗口，正确处理接收方返回的确认号ackno和窗口大小window"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"CS144 Lab Assignment lab-3","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xushun1221.github.io\/2022\/cs144-lab-assignment-lab-3\/"},"image":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"network, C\x2b\x2b","wordcount":2548,"url":"https:\/\/xushun1221.github.io\/2022\/cs144-lab-assignment-lab-3\/","datePublished":"2022-03-17T00:00:00\x2b00:00","dateModified":"2022-03-17T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xushun","logo":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">CS144 Lab Assignment lab-3</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2022-03-17>2022-03-17</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 2548 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://xushun1221.github.io/categories/networking/>Networking</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#the-tcp-sender>the TCP sender</a></li><li><a href=#how-does-the-tcpsender-know-if-a-segment-was-lost>How does the TCPSender know if a segment was lost?</a></li><li><a href=#implementing-the-tcp-sender>Implementing the TCP sender</a></li><li><a href=#lab3测试结果>lab3测试结果</a></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#the-tcp-sender>the TCP sender</a></li><li><a href=#how-does-the-tcpsender-know-if-a-segment-was-lost>How does the TCPSender know if a segment was lost?</a></li><li><a href=#implementing-the-tcp-sender>Implementing the TCP sender</a></li><li><a href=#lab3测试结果>lab3测试结果</a></li></ul></nav></div></details></div><div class=post-content><a class=post-dummy-target id=the-tcp-sender></a><h2>the TCP sender</h2><p>本次实验是TCP的sender，需要完成的主要功能有：</p><ul><li>跟踪接收方的接收窗口，正确处理接收方返回的确认号<code>ackno</code>和窗口大小<code>window_size</code></li><li>发送方从字节流<code>ByteStream</code>中读取字节，并包装成<code>TCPSegment</code>，用以填充接收窗口，发送方应该保持持续发送，直到接收窗口大小为0，或字节流为空</li><li>将发送过但未收到确认的<code>segment</code>缓存下来，直到收到接收方返回的确认</li><li>为发送过的TCP段进行计时，在一段时间后还没有收到确认，则认为该段在网络中丢失，此时应该重新向接收方发送该段</li></ul><p>需要完成的接口如下：</p><ul><li><code>fill_window()</code>：向接收方发送组装的<code>TCPSegment</code></li><li><code>ack_received()</code>：接收来自接收方的确认号和窗口大小，移除缓存区中已经确认的<code>segment</code>，并调用<code>fill_window()</code>填充接收窗口</li><li><code>tick()</code>：该函数是本次实验中唯一的获得时间流逝的函数，用来判断<code>segment</code>是否超时需要重发</li><li><code>send_empty_segment()</code>：发送一个空的<code>segment</code></li></ul><hr><a class=post-dummy-target id=how-does-the-tcpsender-know-if-a-segment-was-lost></a><h2>How does the TCPSender know if a segment was lost?</h2><p>TCPSender怎么知道一个<code>segment</code>在网络中丢失了呢？<br>TCP协议使用<strong>超时重传</strong>机制，简单来说，对于每个发送出去的<code>segment</code>，都将其保存在缓存区中，直到收到该<code>segment</code>的<strong>完全确认</strong>，再把它从缓存区删除。发送时，对其进行计时，如果当超过某个超时时间时，我们对其进行重发操作。<br>需要注意的是：在实验中我们使用<strong>完全确认</strong>，也就是说，对于每个等待确认的<code>segment</code>，我们不会确认它的部分，而是只有在收到的确认号完全覆盖该<code>segment</code>时，才确认它。</p><p>超时重传机制的实现比较复杂，下面是几个关键点：</p><ul><li>每隔几个毫秒，<code>TCPSender</code>的<code>tick()</code>函数就会被调用（<em>被谁调用？被该TCP实现的更高层调用</em>），它会传回一个参数，代表从上次调用<code>tick()</code>之后经过了多少个毫秒，这是我们用来记录时间流逝并判断超时的方法。除此之外，我们不能调用系统提供的其他<code>time</code>或<code>clock</code>相关的接口</li><li>在构造<code>TCPSender</code>时，会从参数中得知<strong>超时重传时间RTO</strong>的初始值，RTO会随网络情况的改变而变化，但是初始值始终不变</li><li>需要设计一个<strong>重传定时器</strong>，它需要在RTO超时时处理一些事情，我们需要在一些不同事件发生时启动重传定时器</li><li>当重传定时器超时时，我们需要做一些事情：<ul><li>重新发送之前最先发送的且没有收到确认的<code>segment</code></li><li>如果接收方的窗口大小 > 0：<ul><li>启用<strong>二进制指数退避</strong>，将RTO翻倍</li><li>超时重发计数增加1，这个量是用来给上层判断连接是否可达的，如果超时重发次数过多，则认为连接已不可达</li></ul></li><li>重置定时器</li></ul></li><li>当<code>TCPSender</code>收到来自接收方的<code>ackno</code>时（要比之前收到的<code>ackno</code>大）<ul><li>RTO设为初始值</li><li>发送缓存区存在未确认的数据，重启定时器</li><li>连续超时重传计数归零（因为收到ack证明网络没有中断）</li></ul></li></ul><hr><a class=post-dummy-target id=implementing-the-tcp-sender></a><h2>Implementing the TCP sender</h2><p>在<code>tcp_sender.hh</code>和<code>tcp_sender.cc</code>中完成接口即可。</p><p>注释已经足够详细，就不再赘述：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>class</span> <span class=nc>TCPSender</span> <span class=p>{</span>
  <span class=k>private</span><span class=o>:</span>
    <span class=c1>//! our initial sequence number, the number for our SYN.
</span><span class=c1></span>    <span class=n>WrappingInt32</span> <span class=n>_isn</span><span class=p>;</span>

    <span class=c1>//! outbound queue of segments that the TCPSender wants sent
</span><span class=c1></span>    <span class=n>std</span><span class=o>:</span><span class=o>:</span><span class=n>queue</span><span class=o>&lt;</span><span class=n>TCPSegment</span><span class=o>&gt;</span> <span class=n>_segments_out</span><span class=p>{</span><span class=p>}</span><span class=p>;</span>

    <span class=c1>//! retransmission timer for the connection
</span><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>_initial_retransmission_timeout</span><span class=p>;</span>

    <span class=c1>//! outgoing stream of bytes that have not yet been sent
</span><span class=c1></span>    <span class=n>ByteStream</span> <span class=n>_stream</span><span class=p>;</span>

    <span class=c1>//! the (absolute) sequence number for the next byte to be sent
</span><span class=c1></span>    <span class=kt>uint64_t</span> <span class=n>_next_seqno</span><span class=p>{</span><span class=mi>0</span><span class=p>}</span><span class=p>;</span>


    <span class=c1>// 定时器
</span><span class=c1></span>    <span class=k>struct</span> <span class=nc>retrans_timer</span> <span class=p>{</span>
      <span class=n>size_t</span> <span class=n>timecount</span><span class=p>{</span><span class=mi>0</span><span class=p>}</span><span class=p>;</span> <span class=c1>// 计时
</span><span class=c1></span>      <span class=n>size_t</span> <span class=n>timeout</span><span class=p>;</span>      <span class=c1>// 当前的RTO
</span><span class=c1></span>      <span class=n>size_t</span> <span class=n>consecutive_retransmissions_count</span><span class=p>{</span><span class=mi>0</span><span class=p>}</span><span class=p>;</span> <span class=c1>// 连续超时重传次数
</span><span class=c1></span>      <span class=n>retrans_timer</span><span class=p>(</span><span class=n>size_t</span> <span class=n>retx_timeout</span><span class=p>)</span> <span class=o>:</span> <span class=n>timeout</span><span class=p>(</span><span class=n>retx_timeout</span><span class=p>)</span> <span class=p>{</span><span class=p>}</span>
    <span class=p>}</span> <span class=n>_retrans_timer</span><span class=p>;</span>

    <span class=c1>// 已发送未确认的TCP段
</span><span class=c1></span>    <span class=n>std</span><span class=o>:</span><span class=o>:</span><span class=n>queue</span><span class=o>&lt;</span><span class=n>TCPSegment</span><span class=o>&gt;</span> <span class=n>_outstanding_queue</span><span class=p>{</span><span class=p>}</span><span class=p>;</span>
    <span class=n>size_t</span> <span class=n>_outstanding_bytes</span><span class=p>{</span><span class=mi>0</span><span class=p>}</span><span class=p>;</span>

    <span class=c1>// 接收方窗口大小
</span><span class=c1></span>    <span class=n>size_t</span> <span class=n>_window_size</span><span class=p>{</span><span class=mi>1</span><span class=p>}</span><span class=p>;</span>
    <span class=c1>// syn fin 是否发送
</span><span class=c1></span>    <span class=kt>bool</span> <span class=n>_syn_flag</span><span class=p>{</span><span class=nb>false</span><span class=p>}</span><span class=p>;</span>
    <span class=kt>bool</span> <span class=n>_fin_flag</span><span class=p>{</span><span class=nb>false</span><span class=p>}</span><span class=p>;</span>
<span class=p>.</span><span class=p>.</span><span class=p>.</span>
	
	
<span class=n>TCPSender</span><span class=o>:</span><span class=o>:</span><span class=n>TCPSender</span><span class=p>(</span><span class=k>const</span> <span class=n>size_t</span> <span class=n>capacity</span><span class=p>,</span> <span class=k>const</span> <span class=kt>uint16_t</span> <span class=n>retx_timeout</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>:</span><span class=o>:</span><span class=n>optional</span><span class=o>&lt;</span><span class=n>WrappingInt32</span><span class=o>&gt;</span> <span class=n>fixed_isn</span><span class=p>)</span>
    <span class=o>:</span> <span class=n>_isn</span><span class=p>(</span><span class=n>fixed_isn</span><span class=p>.</span><span class=n>value_or</span><span class=p>(</span><span class=n>WrappingInt32</span><span class=p>{</span><span class=n>random_device</span><span class=p>(</span><span class=p>)</span><span class=p>(</span><span class=p>)</span><span class=p>}</span><span class=p>)</span><span class=p>)</span>
    <span class=p>,</span> <span class=n>_initial_retransmission_timeout</span><span class=p>{</span><span class=n>retx_timeout</span><span class=p>}</span>
    <span class=p>,</span> <span class=n>_stream</span><span class=p>(</span><span class=n>capacity</span><span class=p>)</span>
    <span class=p>,</span> <span class=n>_retrans_timer</span><span class=p>(</span><span class=n>retx_timeout</span><span class=p>)</span> <span class=p>{</span><span class=p>}</span>

<span class=kt>uint64_t</span> <span class=n>TCPSender</span><span class=o>:</span><span class=o>:</span><span class=n>bytes_in_flight</span><span class=p>(</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>_outstanding_bytes</span><span class=p>;</span> <span class=p>}</span>

<span class=kt>void</span> <span class=n>TCPSender</span><span class=o>:</span><span class=o>:</span><span class=n>fill_window</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 尽管接收方的窗口大小为0 还是要发送报文段以期得到接收方返回的最新窗口大小
</span><span class=c1></span>    <span class=c1>// 我们需要用另一个变量来表示_window_size
</span><span class=c1></span>    <span class=c1>// 因为如果我们将_window_size 视作 1 实际上是超出接收方的接受范围
</span><span class=c1></span>    <span class=c1>// 直接令其为1 在调用tick()时 无法判断超时的原因是网络问题还是接收方窗口为0
</span><span class=c1></span>    <span class=c1>// 会导致错误的二进制指数退避
</span><span class=c1></span>    <span class=n>size_t</span> <span class=n>win_size</span> <span class=o>=</span> <span class=n>_window_size</span> <span class=o>=</span><span class=o>=</span> <span class=mi>0</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=n>_window_size</span><span class=p>;</span>
    <span class=c1>// 循环填充窗口 窗口大小大于以发送的字节数
</span><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>win_size</span> <span class=o>&gt;</span> <span class=n>_outstanding_bytes</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 构造新报文段
</span><span class=c1></span>        <span class=n>TCPSegment</span> <span class=n>segment</span><span class=p>;</span>
        <span class=c1>// 如果没有握手 立即发送syn信号
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>_syn_flag</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>segment</span><span class=p>.</span><span class=n>header</span><span class=p>(</span><span class=p>)</span><span class=p>.</span><span class=n>syn</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
            <span class=n>_syn_flag</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 装入序列号
</span><span class=c1></span>        <span class=n>segment</span><span class=p>.</span><span class=n>header</span><span class=p>(</span><span class=p>)</span><span class=p>.</span><span class=n>seqno</span> <span class=o>=</span> <span class=n>next_seqno</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
        <span class=c1>// 装入负载  注意syn会占用一个payload_size
</span><span class=c1></span>        <span class=n>size_t</span> <span class=n>payload_size</span> <span class=o>=</span> <span class=n>min</span><span class=p>(</span><span class=n>TCPConfig</span><span class=o>:</span><span class=o>:</span><span class=n>MAX_PAYLOAD_SIZE</span><span class=p>,</span> <span class=n>win_size</span> <span class=o>-</span> <span class=n>_outstanding_bytes</span><span class=p>)</span> <span class=o>-</span> <span class=n>segment</span><span class=p>.</span><span class=n>header</span><span class=p>(</span><span class=p>)</span><span class=p>.</span><span class=n>syn</span><span class=p>;</span>
        <span class=c1>// 从字节流中读取字节
</span><span class=c1></span>        <span class=n>string</span> <span class=n>payload</span> <span class=o>=</span> <span class=n>_stream</span><span class=p>.</span><span class=n>read</span><span class=p>(</span><span class=n>payload_size</span><span class=p>)</span><span class=p>;</span>
        <span class=c1>// 判断是否装入fin 装入fin的条件为
</span><span class=c1></span>        <span class=c1>// 1.没发送过fin信号 2.字节流已经读取完毕并关闭
</span><span class=c1></span>        <span class=c1>// 3.接收方能接收的字节数 &gt; 装入负载数 + syn(算一个)
</span><span class=c1></span>        <span class=c1>// 这样才能将fin装入seg
</span><span class=c1></span>        <span class=c1>// 若接收方当前能够接收的字节数 == 装入负载数 + syn
</span><span class=c1></span>        <span class=c1>// 那么fin信号应装在下一个空负载的seg中
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>_fin_flag</span> <span class=o>&amp;</span><span class=o>&amp;</span> <span class=n>_stream</span><span class=p>.</span><span class=n>eof</span><span class=p>(</span><span class=p>)</span> <span class=o>&amp;</span><span class=o>&amp;</span> <span class=n>payload</span><span class=p>.</span><span class=n>size</span><span class=p>(</span><span class=p>)</span> <span class=o>+</span> <span class=n>segment</span><span class=p>.</span><span class=n>header</span><span class=p>(</span><span class=p>)</span><span class=p>.</span><span class=n>syn</span> <span class=o>&lt;</span> <span class=n>win_size</span> <span class=o>-</span> <span class=n>_outstanding_bytes</span><span class=p>)</span>
            <span class=n>_fin_flag</span> <span class=o>=</span> <span class=n>segment</span><span class=p>.</span><span class=n>header</span><span class=p>(</span><span class=p>)</span><span class=p>.</span><span class=n>fin</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
        <span class=c1>// 装入负载
</span><span class=c1></span>        <span class=n>segment</span><span class=p>.</span><span class=n>payload</span><span class=p>(</span><span class=p>)</span> <span class=o>=</span> <span class=n>Buffer</span><span class=p>(</span><span class=n>move</span><span class=p>(</span><span class=n>payload</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
        <span class=c1>// 发送数据包的条件是 该数据包有占用seqno (包括 syn fin)
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>segment</span><span class=p>.</span><span class=n>length_in_sequence_space</span><span class=p>(</span><span class=p>)</span> <span class=o>=</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=c1>// 如果缓存区没有等待确认的seg 我们应为这个新的seg开启定时器
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>_outstanding_queue</span><span class=p>.</span><span class=n>empty</span><span class=p>(</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>_retrans_timer</span><span class=p>.</span><span class=n>timeout</span> <span class=o>=</span> <span class=n>_initial_retransmission_timeout</span><span class=p>;</span>
            <span class=n>_retrans_timer</span><span class=p>.</span><span class=n>timecount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 发送
</span><span class=c1></span>        <span class=n>_segments_out</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>segment</span><span class=p>)</span><span class=p>;</span>
        <span class=c1>// 缓存新的seg
</span><span class=c1></span>        <span class=n>_outstanding_bytes</span> <span class=o>+</span><span class=o>=</span> <span class=n>segment</span><span class=p>.</span><span class=n>length_in_sequence_space</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
        <span class=n>_outstanding_queue</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>segment</span><span class=p>)</span><span class=p>;</span>
        <span class=c1>// 更新 _next_seqno
</span><span class=c1></span>        <span class=n>_next_seqno</span> <span class=o>+</span><span class=o>=</span> <span class=n>segment</span><span class=p>.</span><span class=n>length_in_sequence_space</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
        <span class=c1>// 如果发送完毕立即退出fill
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>segment</span><span class=p>.</span><span class=n>header</span><span class=p>(</span><span class=p>)</span><span class=p>.</span><span class=n>fin</span><span class=p>)</span>
            <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=c1>//! \param ackno The remote receiver&#39;s ackno (acknowledgment number)
</span><span class=c1></span><span class=c1>//! \param window_size The remote receiver&#39;s advertised window size
</span><span class=c1></span><span class=kt>void</span> <span class=n>TCPSender</span><span class=o>:</span><span class=o>:</span><span class=n>ack_received</span><span class=p>(</span><span class=k>const</span> <span class=n>WrappingInt32</span> <span class=n>ackno</span><span class=p>,</span> <span class=k>const</span> <span class=kt>uint16_t</span> <span class=n>window_size</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 获得绝对ack的seqno
</span><span class=c1></span>    <span class=n>size_t</span> <span class=n>abs_seqno</span> <span class=o>=</span> <span class=n>unwrap</span><span class=p>(</span><span class=n>ackno</span><span class=p>,</span> <span class=n>_isn</span><span class=p>,</span> <span class=n>_next_seqno</span><span class=p>)</span><span class=p>;</span>
    <span class=c1>// abs_seqno表示该字节之前的所有字节已收到
</span><span class=c1></span>    <span class=c1>// 确认号不能大于待发送字节
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>abs_seqno</span> <span class=o>&gt;</span> <span class=n>_next_seqno</span><span class=p>)</span>
        <span class=k>return</span><span class=p>;</span>
    <span class=c1>// 把已经收到确认的seg弹出缓存区
</span><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>_outstanding_queue</span><span class=p>.</span><span class=n>empty</span><span class=p>(</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>const</span> <span class=n>TCPSegment</span> <span class=o>&amp;</span><span class=n>seg</span> <span class=o>=</span> <span class=n>_outstanding_queue</span><span class=p>.</span><span class=n>front</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
        <span class=c1>// 如果队头seg（最先发送的）完全确认
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>unwrap</span><span class=p>(</span><span class=n>seg</span><span class=p>.</span><span class=n>header</span><span class=p>(</span><span class=p>)</span><span class=p>.</span><span class=n>seqno</span><span class=p>,</span> <span class=n>_isn</span><span class=p>,</span> <span class=n>abs_seqno</span><span class=p>)</span> <span class=o>+</span> <span class=n>seg</span><span class=p>.</span><span class=n>length_in_sequence_space</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>=</span> <span class=n>abs_seqno</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 弹出队列
</span><span class=c1></span>            <span class=n>_outstanding_bytes</span> <span class=o>-</span><span class=o>=</span> <span class=n>seg</span><span class=p>.</span><span class=n>length_in_sequence_space</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
            <span class=n>_outstanding_queue</span><span class=p>.</span><span class=n>pop</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
            <span class=c1>// 如果有新的数据包被成功接收 RTO回归初始值 定时器重新计时
</span><span class=c1></span>            <span class=n>_retrans_timer</span><span class=p>.</span><span class=n>timeout</span> <span class=o>=</span> <span class=n>_initial_retransmission_timeout</span><span class=p>;</span>
            <span class=n>_retrans_timer</span><span class=p>.</span><span class=n>timecount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 如果seg没有被完全确认 说明后面的seg也一样
</span><span class=c1></span>        <span class=k>else</span>
            <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// 只要收到了ack 则说明网络并没有中断
</span><span class=c1></span>    <span class=c1>// 那么连续重传计数也应该归零
</span><span class=c1></span>    <span class=n>_retrans_timer</span><span class=p>.</span><span class=n>consecutive_retransmissions_count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=c1>// 更新窗口大小
</span><span class=c1></span>    <span class=n>_window_size</span> <span class=o>=</span> <span class=n>window_size</span><span class=p>;</span>
    <span class=c1>// 填充发送窗口
</span><span class=c1></span>    <span class=n>fill_window</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>

<span class=c1>//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method
</span><span class=c1></span><span class=kt>void</span> <span class=n>TCPSender</span><span class=o>:</span><span class=o>:</span><span class=n>tick</span><span class=p>(</span><span class=k>const</span> <span class=n>size_t</span> <span class=n>ms_since_last_tick</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 统计经过的时间
</span><span class=c1></span>    <span class=n>_retrans_timer</span><span class=p>.</span><span class=n>timecount</span> <span class=o>+</span><span class=o>=</span> <span class=n>ms_since_last_tick</span><span class=p>;</span>
    <span class=c1>// 如果存在未确认的seg 且 超时 则重传最先发送的seg
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>_retrans_timer</span><span class=p>.</span><span class=n>timecount</span> <span class=o>&gt;</span><span class=o>=</span> <span class=n>_retrans_timer</span><span class=p>.</span><span class=n>timeout</span> <span class=o>&amp;</span><span class=o>&amp;</span> <span class=o>!</span><span class=n>_outstanding_queue</span><span class=p>.</span><span class=n>empty</span><span class=p>(</span><span class=p>)</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// _window_size &gt; 0 说明接收方还在接收
</span><span class=c1></span>        <span class=c1>// 如果超时则是网络拥堵导致
</span><span class=c1></span>        <span class=c1>// 启动二进制指数退避
</span><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>_window_size</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>_retrans_timer</span><span class=p>.</span><span class=n>timeout</span> <span class=o>*</span><span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
            <span class=c1>// 超时则将超时重发计数加一
</span><span class=c1></span>            <span class=o>+</span><span class=o>+</span><span class=n>_retrans_timer</span><span class=p>.</span><span class=n>consecutive_retransmissions_count</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 重新计时
</span><span class=c1></span>        <span class=n>_retrans_timer</span><span class=p>.</span><span class=n>timecount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=c1>// 重发
</span><span class=c1></span>        <span class=n>_segments_out</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>_outstanding_queue</span><span class=p>.</span><span class=n>front</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
        
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>TCPSender</span><span class=o>:</span><span class=o>:</span><span class=n>consecutive_retransmissions</span><span class=p>(</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>_retrans_timer</span><span class=p>.</span><span class=n>consecutive_retransmissions_count</span><span class=p>;</span> <span class=p>}</span>

<span class=kt>void</span> <span class=n>TCPSender</span><span class=o>:</span><span class=o>:</span><span class=n>send_empty_segment</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>TCPSegment</span> <span class=n>segment</span><span class=p>;</span>
    <span class=n>segment</span><span class=p>.</span><span class=n>header</span><span class=p>(</span><span class=p>)</span><span class=p>.</span><span class=n>seqno</span> <span class=o>=</span> <span class=n>next_seqno</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=n>_segments_out</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>segment</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
	
</code></pre></td></tr></table></div></div><hr><a class=post-dummy-target id=lab3测试结果></a><h2>lab3测试结果</h2><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=/post_images/posts/Networking/CS144LabAssignmentlab-3/lab3%e6%b5%8b%e8%af%95%e7%bb%93%e6%9e%9c.jpg alt title=lab3测试结果 class=lazyload><figcaption class=image-caption>lab3测试结果</figcaption></figure></p></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>xushun</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2022-03-17</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fxushun1221.github.io%2f2022%2fcs144-lab-assignment-lab-3%2f&text=CS144%20Lab%20Assignment%20lab-3&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fxushun1221.github.io%2f2022%2fcs144-lab-assignment-lab-3%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fxushun1221.github.io%2f2022%2fcs144-lab-assignment-lab-3%2f&title=CS144%20Lab%20Assignment%20lab-3" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://xushun1221.github.io/tags/network/><i class="fas fa-tag fa-fw"></i>&nbsp;network</a>&nbsp;
</span><span class=tag><a href=https://xushun1221.github.io/tags/c++/><i class="fas fa-tag fa-fw"></i>&nbsp;C++</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://xushun1221.github.io>Home</a></span></section></div><div class=post-nav><a href=https://xushun1221.github.io/2022/cs144-lab-assignment-lab-2/ class=prev rel=prev title="CS144 Lab Assignment lab-2"><i class="fas fa-angle-left fa-fw"></i>CS144 Lab Assignment lab-2</a>
<a href=https://xushun1221.github.io/2022/cs144-lab-assignment-lab-4/ class=next rel=next title="CS144 Lab Assignment lab-4">CS144 Lab Assignment lab-4<i class="fas fa-angle-right fa-fw"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xushun1221.github.io/about/ target=_blank>xushun</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>