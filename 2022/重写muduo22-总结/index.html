<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>【重写muduo】22 - 总结 | XuShun's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="XuShun的个人博客，记录学习和生活。"><link rel=prev href=https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo21-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/><link rel=next href=https://xushun1221.github.io/2022/mysql01-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/><link rel=canonical href=https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo22-%E6%80%BB%E7%BB%93/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="【重写muduo】22 - 总结"><meta name=twitter:description content="muduo库的核心部分终于重写完了，我们来总结一下各个核心组件的功能和联系。 Channel Channel是对sockfd和其感兴趣的事件以及对应的回调函"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【重写muduo】22 - 总结","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xushun1221.github.io\/2022\/%E9%87%8D%E5%86%99muduo22-%E6%80%BB%E7%BB%93\/"},"image":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"network, C\x2b\x2b, muduo","wordcount":3340,"url":"https:\/\/xushun1221.github.io\/2022\/%E9%87%8D%E5%86%99muduo22-%E6%80%BB%E7%BB%93\/","datePublished":"2022-10-06T00:00:00\x2b00:00","dateModified":"2022-10-06T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xushun","logo":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">【重写muduo】22 - 总结</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2022-10-06>2022-10-06</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 3340 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://xushun1221.github.io/categories/networking/>Networking</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#channel>Channel</a></li><li><a href=#poller和epollpoller---demultiplex>Poller和EPollPoller - Demultiplex</a></li><li><a href=#eventloop---reactor>EventLoop - Reactor</a></li><li><a href=#threadeventloopthreadeventloopthreadpool>Thread、EventLoopThread、EventLoopThreadPool</a></li><li><a href=#acceptor>Acceptor</a></li><li><a href=#buffer>Buffer</a></li><li><a href=#tcpconnection>TcpConnection</a></li><li><a href=#tcpserver>TcpServer</a></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#channel>Channel</a></li><li><a href=#poller和epollpoller---demultiplex>Poller和EPollPoller - Demultiplex</a></li><li><a href=#eventloop---reactor>EventLoop - Reactor</a></li><li><a href=#threadeventloopthreadeventloopthreadpool>Thread、EventLoopThread、EventLoopThreadPool</a></li><li><a href=#acceptor>Acceptor</a></li><li><a href=#buffer>Buffer</a></li><li><a href=#tcpconnection>TcpConnection</a></li><li><a href=#tcpserver>TcpServer</a></li></ul></nav></div></details></div><div class=post-content><p>muduo库的核心部分终于重写完了，我们来总结一下各个核心组件的功能和联系。</p><a class=post-dummy-target id=channel></a><h2>Channel</h2><p><code>Channel</code>是对sockfd和其感兴趣的事件以及对应的回调函数的封装。</p><p>核心组件：</p><ul><li><code>EventLoop* loop_</code>：Channel所属的EventLoop（用于和EventLoop上的Poller通信）；</li><li><code>const int fd_</code>：Channel对应的文件描述符，注册到Poller上的sockfd；</li><li><code>int events_</code>：Channel感兴趣的事件；</li><li><code>int revents_</code>：Poller给Channel返回的发生的具体事件，据此调用下方相应的回调函数；</li><li>一组回调函数：<ul><li><code>ReadEventCallback readCallback_</code></li><li><code>EventCallback writeCallback_</code></li><li><code>EventCallback closeCallback_</code></li><li><code>EventCallback errorCallback_</code></li></ul></li></ul><blockquote><p>Channel和Poller是互相独立的，它们都从属于EventLoop，所以使用一个EventLoop的指针来进行通信。</p></blockquote><p>核心功能：</p><ul><li>向Poller上注册（更新）fd感兴趣的事件，<code>void update();</code>；</li><li>获得Poller返回的fd发生的事件，<code>void set_revents();</code>，（由Poller调用）；</li><li>设置各类事件对应的回调函数，很明显，回调函数来自于Channel的上层Acceptor或TcpConnection；</li><li>根据返回的发生事件和设置的回调函数对事件进行处理，<code>void handleEvent(Timestamp receiveTime);</code>。</li></ul><blockquote><p>muduo库中有两种不同的sockfd，一种是用于监听新连接的<strong>listenfd</strong>，另一种是用于处理已连接用户IO事件的<strong>connfd</strong>。这两种sockfd和Poller的交互都使用<strong>Channel</strong>进行封装，但由于两种sockfd执行的功能不同，我们使用<code>Acceptor</code>和<code>TcpConnection</code>两个类来分别封装这两种Channel。<br>对于socket操作的细节，通过<code>Socket</code>类来封装。</p></blockquote><a class=post-dummy-target id=poller和epollpoller---demultiplex></a><h2>Poller和EPollPoller - Demultiplex</h2><blockquote><p>muduo库支持<code>epoll</code>和<code>poll</code>两种IO复用模型，所以使用抽象类<code>Poller</code>来为所有的IO复用模型提供统一的接口。<code>EPollPoller</code>是使用<code>epoll</code>方法的事件分发器类。</p></blockquote><p><code>EPollPoller</code>的核心组件：</p><ul><li>Poller基类的组件<ul><li><code>EventLoop* ownerLoop_</code>，Poller所属的EventLoop，用于和注册到该Poller上的Channel通信；</li><li><code>ChannelMap channels_</code>，（<code>using ChannelMap = std::unordered_map&lt;int, Channel*>;</code>）用一个hashmap来保存所有注册到该Poller上的Channel，key是Channel对应的sockfd；</li></ul></li><li><code>int epollfd_</code>，epoll的文件描述符；</li><li><code>EventList events_</code>，（<code>using EventList = std::vector&lt;epoll_event>;</code>），用于接收发生事件的epoll_event，用作epoll_wait的传出参数。</li></ul><p>核心功能：</p><ul><li>事件分发器获得发生事件的sockfd（对<code>epoll_wait</code>的封装）<ul><li><code>Timestamp poll(int timeoutMs, Poller::ChannelList* activeChannels);</code>（timeoutMs是超时时长，activeChannels是有监听事件发生的Channel列表，交由EventLoop进行处理）</li></ul></li><li>注册（更新）Channel在Poller中的状态（对<code>epoll_ctl</code>的封装）<ul><li><code>void updateChannel(Channel* channel);</code></li></ul></li><li>将注册在Poller上的Channel删除（对<code>epoll_ctl</code>的封装）<ul><li><code>void removeChannel(Channel* channel);</code></li></ul></li></ul><a class=post-dummy-target id=eventloop---reactor></a><h2>EventLoop - Reactor</h2><p><code>EventLoop</code>事件循环类，是Reactor模型的核心，它是对Poller事件分发器的进一步封装，管理属于该EventLoop的所有Channel以及一个Poller事件分发器，为Channel和Poller提供一个通信的途径。它的主要功能是，在有事件到来时，执行Channel对应事件的回调，或者执行其他组件发送来的回调函数。</p><p>核心组件：</p><ul><li><code>std::unique_ptr&lt;Poller> poller_</code>：Poller；</li><li><code>int wakeupFd_</code>和<code>std::unique_ptr&lt;Channel> wakeupChannel_</code>：用于唤醒事件循环的eventfd；</li><li><code>ChannelList activeChannels_</code>，（<code>using ChannelList = std::vector&lt;Channel*>;</code>），保存事件分发器返回的发送事件的Channel；</li><li><code>std::vector&lt;Functor> pendingFunctors_</code>，（using Functor = std::function&lt;void()>;），用于保存其他组件发送来的需要当前Loop执行的所有回调函数。</li></ul><p>核心功能：</p><ul><li>进行事件循环，执行发生事件的Channel对应的回调，以及其他应该执行的回调<ul><li><code>void loop();</code></li><li><code>void doPendingFunctors();</code></li></ul></li><li>在当前Loop中执行指定回调，如果当前在该Loop对应的Thread中，直接执行，否则放入队列等待执行<ul><li><code>void runInLoop(Functor cb);</code></li><li><code>void queueInLoop(Functor cb);</code></li></ul></li><li>唤醒功能<ul><li><code>void wakeup();</code></li></ul></li></ul><blockquote><p>在Poller上没有事件发生的情况下，事件循环会阻塞在<code>poll</code>处，如果此时有其他需要处理的回调（如Acceptor接收了新的连接，并将其注册到Poller上），那么就无法被及时处理<br>我们使用eventfd（<code>wakeupFd_</code>）来解决这个问题，在创建EventLoop时我们使用<code>eventfd()</code>系统调用创建一个用于消息通知的fd，封装为Channel，并将其读事件注册到Poller上，当我们有回调操作需要Loop立即处理时，只需向<code>pendingFunctors_</code>添加回调操作，并向该Loop对应的wakeupFd_写入8字节数据，就可以让当前Loop从阻塞状态唤醒，立即处理回调。</p></blockquote><a class=post-dummy-target id=threadeventloopthreadeventloopthreadpool></a><h2>Thread、EventLoopThread、EventLoopThreadPool</h2><p>muduo网络库中的一个最重要的概念就是：<strong>One Loop per Thread</strong>，每个事件循环都在一个单独的线程中执行。</p><p><code>Thread</code>线程类，封装了对底层线程的操作；<br><code>EventLoopThread</code>事件循环线程类，实现了启动事件循环线程的操作；<br><code>EventLoopThreadPool</code>事件循环线程池类，封装了多个事件循环线程。</p><p>每一个TcpServer中都有一个EventLoopThreadPool，当TcpServer启动时，EventLoopThreadPool也被启动，EventLoopThreadPool会根据用户设定的线程数量创建多个子线程(EventLoopThread)，用于处理已连接fd的IO事件，这样的事件循环线程称为<strong>SubLoop</strong>，而用于接收新连接的事件循环称为<strong>BaseLoop</strong>，它作为参数传入TcpServer。</p><p>每个线程创建完成后，就立即执行事件循环了(<code>loop()</code>)。</p><p>值得一提的是，每当BaseLoop接收到一个新连接时，会按<strong>轮询</strong>的方式选择一个SubLoop并注册，由该Loop处理该连接的IO事件。线程池会使用<code>EventLoop* getNextLoop();</code>方法给出下一个接收连接的LoopThread，如果用户没有设置额外的线程用于IO操作，那么所有的事件都由MAINLOOP来处理。</p><a class=post-dummy-target id=acceptor></a><h2>Acceptor</h2><p><code>Acceptor</code>实际上就是对listenfd的封装，将listenfd封装为一个acceptChannel，并交由BaseLoop监听新用户连接，当有新用户连接时，调用<code>NewConnectionCallback newConnectionCallback_;</code>回调函数进行处理。</p><a class=post-dummy-target id=buffer></a><h2>Buffer</h2><p>muduo库使用<code>Buffer</code>缓冲区来实现相关的IO操作。</p><p>当某个连接要发送数据时，它不会直接写入内核的TCP发送缓冲区，而是，写入该连接自带的发送缓冲区，并注册写事件，当可以发送时，写事件回调会将连接的发送缓冲区中的数据写入TCP发送缓冲区，进行发送。</p><p>当某个连接接收到数据时，它会调用写事件回调，将接收的数据写入该连接自己的接收缓冲区，并调用<code>messageCallback_</code>，进行处理。</p><p>实现细节和原理在源码中有非常详细的注解。</p><a class=post-dummy-target id=tcpconnection></a><h2>TcpConnection</h2><p><code>TcpConnection</code>类，是对一个成功连接的客户Channel的封装，它管理对这个Channel的所有操作。</p><p>核心组件：</p><ul><li><code>EventLoop* loop_</code></li><li><code>std::unique_ptr&lt;Channel> channel_</code></li><li><code>Buffer inputBuffer_</code></li><li><code>Buffer outputBuffer_</code></li><li>连接的各种回调（和Channel的回调不同）<ul><li>ConnectionCallback connectionCallback_;</li><li>MessageCallback messageCallback_;</li><li>WriteCompleteCallback writeCompleteCallback_;</li><li>HighWaterMarkCallback highWaterMarkCallback_;</li><li>CloseCallback closeCallback_;</li></ul></li></ul><p>核心功能：</p><ul><li>建立连接，<code>void connectEstablished();</code></li><li>销毁连接，<code>void connectDestroyed();</code></li><li>发送数据，<code>void send(const std::string& buf);</code></li><li>关闭连接，<code>void shutdown();</code></li><li>Channel的各类事件回调<ul><li><code>void handleRead(Timestamp receiveTime);</code></li><li><code>void handleWrite();</code></li><li><code>void handleClose();</code></li><li><code>void handleError();</code></li></ul></li></ul><a class=post-dummy-target id=tcpserver></a><h2>TcpServer</h2><p><code>TcpServer</code>是muduo库服务器编程的入口类，它管理所有的EventLoop、EventLoopThreadPool、Acceptor、所有的TcpConnection连接，以及连接事件的回调。</p></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>xushun</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2022-10-06</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fxushun1221.github.io%2f2022%2f%25E9%2587%258D%25E5%2586%2599muduo22-%25E6%2580%25BB%25E7%25BB%2593%2f&text=%e3%80%90%e9%87%8d%e5%86%99muduo%e3%80%9122%20-%20%e6%80%bb%e7%bb%93&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fxushun1221.github.io%2f2022%2f%25E9%2587%258D%25E5%2586%2599muduo22-%25E6%2580%25BB%25E7%25BB%2593%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fxushun1221.github.io%2f2022%2f%25E9%2587%258D%25E5%2586%2599muduo22-%25E6%2580%25BB%25E7%25BB%2593%2f&title=%e3%80%90%e9%87%8d%e5%86%99muduo%e3%80%9122%20-%20%e6%80%bb%e7%bb%93" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://xushun1221.github.io/tags/network/><i class="fas fa-tag fa-fw"></i>&nbsp;network</a>&nbsp;
</span><span class=tag><a href=https://xushun1221.github.io/tags/c++/><i class="fas fa-tag fa-fw"></i>&nbsp;C++</a>&nbsp;
</span><span class=tag><a href=https://xushun1221.github.io/tags/muduo/><i class="fas fa-tag fa-fw"></i>&nbsp;muduo</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://xushun1221.github.io>Home</a></span></section></div><div class=post-nav><a href=https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo21-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/ class=prev rel=prev title="【重写muduo】21 - 编译安装脚本&测试代码"><i class="fas fa-angle-left fa-fw"></i>【重写muduo】21 - 编译安装脚本&测试代码</a>
<a href=https://xushun1221.github.io/2022/mysql01-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/ class=next rel=next title="【MySQL】01 - 安装配置">【MySQL】01 - 安装配置<i class="fas fa-angle-right fa-fw"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xushun1221.github.io/about/ target=_blank>xushun</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>