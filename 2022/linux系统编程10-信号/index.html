<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>【Linux系统编程】10 - 信号 | XuShun's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="XuShun的个人博客，记录学习和生活。"><link rel=prev href=https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B09-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/><link rel=canonical href=https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B10-%E4%BF%A1%E5%8F%B7/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="【Linux系统编程】10 - 信号"><meta name=twitter:description content="信号的概念 信号在我们的生活中随处可见，如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪…… 他们都有共性： 简单； 不能携带大量"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【Linux系统编程】10 - 信号","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xushun1221.github.io\/2022\/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B10-%E4%BF%A1%E5%8F%B7\/"},"image":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"Linux","wordcount":4401,"url":"https:\/\/xushun1221.github.io\/2022\/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B10-%E4%BF%A1%E5%8F%B7\/","datePublished":"2022-05-29T00:00:00\x2b00:00","dateModified":"2022-05-29T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xushun","logo":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">【Linux系统编程】10 - 信号</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2022-05-29>2022-05-29</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 4401 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://xushun1221.github.io/categories/coding/>Coding</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#信号的概念>信号的概念</a><ul><li><a href=#信号的机制>信号的机制</a></li><li><a href=#信号的相关事件和状态>信号的相关事件和状态</a><ul><li><a href=#产生信号>产生信号</a></li><li><a href=#递达>递达</a></li><li><a href=#未决>未决</a></li><li><a href=#信号处理>信号处理</a></li><li><a href=#阻塞信号集信号屏蔽字>阻塞信号集（信号屏蔽字）</a></li><li><a href=#未决信号集>未决信号集</a></li></ul></li><li><a href=#常规信号和信号四要素>常规信号和信号四要素</a><ul><li><a href=#信号四要素>信号四要素</a></li><li><a href=#常规信号一览>常规信号一览</a></li></ul></li></ul></li><li><a href=#信号的产生>信号的产生</a><ul><li><a href=#终端按键产生信号>终端按键产生信号</a></li><li><a href=#硬件异常产生信号>硬件异常产生信号</a></li><li><a href=#kill函数命令产生信号>kill函数/命令产生信号</a><ul><li><a href=#kill命令>kill命令</a></li><li><a href=#kill函数>kill函数</a></li></ul></li><li><a href=#软件条件产生信号>软件条件产生信号</a><ul><li><a href=#alarm函数产生信号>alarm函数产生信号</a></li><li><a href=#setitimer函数产生信号--getitimer>setitimer函数产生信号 / getitimer</a></li></ul></li></ul></li><li><a href=#信号集操作函数>信号集操作函数</a></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#信号的概念>信号的概念</a><ul><li><a href=#信号的机制>信号的机制</a></li><li><a href=#信号的相关事件和状态>信号的相关事件和状态</a><ul><li><a href=#产生信号>产生信号</a></li><li><a href=#递达>递达</a></li><li><a href=#未决>未决</a></li><li><a href=#信号处理>信号处理</a></li><li><a href=#阻塞信号集信号屏蔽字>阻塞信号集（信号屏蔽字）</a></li><li><a href=#未决信号集>未决信号集</a></li></ul></li><li><a href=#常规信号和信号四要素>常规信号和信号四要素</a><ul><li><a href=#信号四要素>信号四要素</a></li><li><a href=#常规信号一览>常规信号一览</a></li></ul></li></ul></li><li><a href=#信号的产生>信号的产生</a><ul><li><a href=#终端按键产生信号>终端按键产生信号</a></li><li><a href=#硬件异常产生信号>硬件异常产生信号</a></li><li><a href=#kill函数命令产生信号>kill函数/命令产生信号</a><ul><li><a href=#kill命令>kill命令</a></li><li><a href=#kill函数>kill函数</a></li></ul></li><li><a href=#软件条件产生信号>软件条件产生信号</a><ul><li><a href=#alarm函数产生信号>alarm函数产生信号</a></li><li><a href=#setitimer函数产生信号--getitimer>setitimer函数产生信号 / getitimer</a></li></ul></li></ul></li><li><a href=#信号集操作函数>信号集操作函数</a></li></ul></nav></div></details></div><div class=post-content><a class=post-dummy-target id=信号的概念></a><h2>信号的概念</h2><p>信号在我们的生活中随处可见，如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪……<br>他们都有共性：</p><ol><li>简单；</li><li>不能携带大量信息；</li><li>满足某个特设条件才发送。</li></ol><p>信号能承载一些消息，它是Linux/Unix环境下，古老、经典的通信方式，现在依然是主要的通信手段。</p><p>Unix早期版本就提供了信号机制，但是并不可靠，信号可能丢失。Berkeley和AT&T都对信号模型做了更改，增加了可靠信号机制，但彼此并不兼容。POSIX.1对可靠信号例程进行了标准化。</p><a class=post-dummy-target id=信号的机制></a><h3>信号的机制</h3><p>进程在收到信号之前执行自己的代码，收到信号后，无论程序执行到什么位置，都必须立即停止执行，处理信号，处理完毕之后再继续执行。</p><p>信号可以看作是软件层面上的“中断”，所有信号的产生和处理都是由<strong>内核</strong>来完成的。</p><a class=post-dummy-target id=信号的相关事件和状态></a><h3>信号的相关事件和状态</h3><a class=post-dummy-target id=产生信号></a><h4>产生信号</h4><ol><li>按键产生：如，<code>Ctrl+c</code>，<code>Ctrl+z</code>，<code>Ctrl+\</code>；</li><li>系统调用产生：如，<code>kill</code>，<code>raise</code>，<code>abort</code>；</li><li>软件条件产生：如，<code>alarm</code>；</li><li>硬件异常产生：如，非法访问内存（段错误），除0（浮点数例外），内存对齐错误（总线错误）；</li><li>命令产生：如，<code>kill</code>命令。</li></ol><a class=post-dummy-target id=递达></a><h4>递达</h4><p>信号由内核递送并到达进程。</p><a class=post-dummy-target id=未决></a><h4>未决</h4><p>信号由内核产生后，到递达之前的状态，主要由于阻塞（屏蔽）导致该状态。</p><a class=post-dummy-target id=信号处理></a><h4>信号处理</h4><ol><li>执行默认动作（每个信号都有自己的默认动作）；</li><li>忽略（丢弃）；</li><li>捕捉（调用用户处理函数）。</li></ol><a class=post-dummy-target id=阻塞信号集信号屏蔽字></a><h4>阻塞信号集（信号屏蔽字）</h4><p>Linux系统的进程控制块PCB中，包含了和信号相关的信息，主要有阻塞信号集和未决信号集。</p><p>阻塞信号集，本质是位图，记录信号的屏蔽状态，当屏蔽某信号后，再次收到该信号时，该信号的处理将会被推后（解除屏蔽后）。在解除屏蔽前，该信号一直处于未决状态。</p><a class=post-dummy-target id=未决信号集></a><h4>未决信号集</h4><p>未决信号集，本质是位图，用来记录信号的处理状态。信号产生时，未决信号集中描述该信号的位立即翻转，表示该信号处于未决状态，当信号被处理，对应的位又翻转回去。</p><p>信号产生后由于某些原因不能递达（主要是阻塞），这类信号的集合就是未决信号集。</p><a class=post-dummy-target id=常规信号和信号四要素></a><h3>常规信号和信号四要素</h3><p>使用<code>kill -l</code>命令可以查看系统支持的所有信号。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_sigal$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	
</code></pre></td></tr></table></div></div><p>不存在编号为0的信号，其中1-31号信号称为<strong>常规信号</strong>（普通信号，标准信号），34-64号信号称为实时信号，与底层驱动开发和硬件相关（与常规信号相比没有默认处理动作）。</p><a class=post-dummy-target id=信号四要素></a><h4>信号四要素</h4><p>每个信号都要具备四个要素：</p><ol><li>编号；</li><li>名称；</li><li>事件；</li><li>默认处理动作。</li></ol><p>使用信号之前要确定信号的四要素，之后再使用。<br>使用<code>man 7 signal</code>命令查看信号详细信息。</p><p>默认处理动作总结：</p><ul><li>Trem：终止进程；</li><li>Ign：忽略信号（默认动作对其忽略）；</li><li>Core：终止进程，生成Core文件（查验进程死亡原因，用于gdb调试）</li><li>Stop：停止（暂停）进程；</li><li>Cont：继续运行进程。</li></ul><p>注意，9号<code>SIGKILL</code>和19号<code>SIGSTOP</code>信号，不允许忽略和捕捉，只能执行默认动作，甚至不能设置为阻塞。</p><p>只有每个信号所对应的事件发生了，该信号才会被递送（但不一定递达），不可以乱发信号！</p><a class=post-dummy-target id=常规信号一览></a><h4>常规信号一览</h4><table><thead><tr><th>编号</th><th>名称</th><th>事件</th><th>默认动作</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>当用户退出 shell 时，由该 shell 启动的所有进程将收到这个信号。</td><td>默认动作为终止进程</td></tr><tr><td>2</td><td>SIGINT</td><td>当用户按下了<code>Ctrl+C</code>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。</td><td>默认动作为终止进程。</td></tr><tr><td>3</td><td>SIGQUIT</td><td>当用户按下<code>ctrl+\</code>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。|默认动作为终止进程。|</td><td></td></tr><tr><td>4</td><td>SIGILL</td><td>CPU 检测到某进程执行了非法指令。</td><td>默认动作为终止进程并产生 core 文件</td></tr><tr><td>5</td><td>SIGTRAP</td><td>该信号由断点指令或其他 trap 指令产生。</td><td>默认动作为终止里程 并产生 core 文件。</td></tr><tr><td>6</td><td>SIGABRT</td><td>调用 abort 函数时产生该信号。</td><td>默认动作为终止进程并产生 core 文件。</td></tr><tr><td>7</td><td>SIGBUS</td><td>非法访问内存地址，包括内存对齐出错，</td><td>默认动作为终止进程并产生 core 文件。</td></tr><tr><td>8</td><td>SIGFPE</td><td>在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等所有的算法错误。</td><td>默认动作为终止进程并产生 core 文件。</td></tr><tr><td>9</td><td>SIGKILL</td><td>无条件终止进程。本信号不能被忽略，处理和阻塞。</td><td>默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。</td></tr><tr><td>10</td><td>SIGUSR1</td><td>用户定义 的信号。即程序员可以在程序中定义并使用该信号。</td><td>默认动作为终止进程。</td></tr><tr><td>11</td><td>SIGSEGV</td><td>指示进程进行了无效内存访问。</td><td>默认动作为终止进程并产生 core 文件。</td></tr><tr><td>12</td><td>SIGUSR2</td><td>另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。</td><td>默认动作为终止进程。</td></tr><tr><td>13</td><td>SIGPIPE</td><td>Broken pipe 向一个没有读端的管道写数据。</td><td>默认动作为终止进程。</td></tr><tr><td>14</td><td>SIGALRM</td><td>定时器超时，超时的时间 由系统调用 alarm 设置。</td><td>默认动作为终止进程。</td></tr><tr><td>15</td><td>SIGTERM</td><td>程序结束信号，与 SIGKILL 不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行 shell 命令 Kill 时，缺省产生这个信号。</td><td>默认动作为终止进程。</td></tr><tr><td>16</td><td>SIGSTKFLT</td><td>Linux 早期版本出现的信号，现仍保留向后兼容。</td><td>默认动作为终止进程。</td></tr><tr><td>17</td><td>SIGCHLD</td><td>子进程状态发生变化时，父进程会收到这个信号。</td><td>默认动作为忽略这个信号。</td></tr><tr><td>18</td><td>SIGCONT</td><td>如果进程已停止，则使其继续运行。</td><td>默认动作为继续/忽略。</td></tr><tr><td>19</td><td>SIGSTOP</td><td>停止进程的执行。信号不能被忽略，处理和阻塞。</td><td>默认动作为暂停进程。</td></tr><tr><td>20</td><td>SIGTSTP</td><td>停止终端交互进程的运行。按下<code>ctrl+z</code>组合键时发出这个信号。</td><td>默认动作为暂停进程。</td></tr><tr><td>21</td><td>SIGTTIN</td><td>后台进程读终端控制台。</td><td>默认动作为暂停进程。</td></tr><tr><td>22</td><td>SIGTTOU</td><td>该信号类似于 SIGTTIN，在后台进程要向终端输出数据时发生。</td><td>默认动作为暂停进程。</td></tr><tr><td>23</td><td>SIGURG</td><td>套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。</td><td>如网络带外数据到达，默认动作为忽略该信号。</td></tr><tr><td>24</td><td>SIGXCPU</td><td>进程执行时间超过了分配给该进程的 CPU 时间 ，系统产生该信号并发送给该进程。</td><td>默认动作为终止进程。</td></tr><tr><td>25</td><td>SIGXFSZ</td><td>超过文件的最大长度设置。</td><td>默认动作为终止进程。</td></tr><tr><td>26</td><td>SIGVTALRM</td><td>虚拟时钟超时时产生该信号。类似于 SIGALRM，但是该信号只计算该进程占用 CPU 的使用时间。</td><td>默认动作为终止进程。</td></tr><tr><td>27</td><td>SGIPROF</td><td>类似于 SIGVTALRM，它不公包括该进程占用 CPU 时间还包括执行系统调用时间。</td><td>默认动作为终止进程。</td></tr><tr><td>28</td><td>SIGWINCH</td><td>窗口变化大小时发出。</td><td>默认动作为忽略该信号。</td></tr><tr><td>29</td><td>SIGIO</td><td>此信号向进程指示发出了一个异步 IO 事件。</td><td>默认动作为忽略。</td></tr><tr><td>30</td><td>SIGPWR</td><td>关机。</td><td>默认动作为终止进程。</td></tr><tr><td>31</td><td>SIGSYS</td><td>无效的系统调用。</td><td>默认动作为终止进程并产生 core 文件。</td></tr><tr><td>34-64</td><td>SIGRTMIN - SIGRTMAX</td><td>LINUX 的实时信号，它们没有固定的含义（可以由用户自定义）。</td><td>所有的实时信号的默认动作都为终止进程。</td></tr></tbody></table><a class=post-dummy-target id=信号的产生></a><h2>信号的产生</h2><a class=post-dummy-target id=终端按键产生信号></a><h3>终端按键产生信号</h3><ul><li><code>ctrl + c</code>， 2) SIGINT（终止/中断） &ldquo;INT&rdquo; &mdash;-Interrupt</li><li><code>Ctrl + z</code>， 20) SIGTSTP（暂停/停止） &ldquo;T&rdquo; &mdash;-Terminal 终端。</li><li><code>Ctrl + \</code>， 3) SIGQUIT（退出）</li></ul><a class=post-dummy-target id=硬件异常产生信号></a><h3>硬件异常产生信号</h3><ul><li>除0操作，8) SIGFPE（浮点数例外） &ldquo;F&rdquo; &mdash;-Float 浮点数</li><li>非法访问内存，11) SIGSEGV（段错误）</li><li>总线错误，7) SIGBUS</li></ul><a class=post-dummy-target id=kill函数命令产生信号></a><h3>kill函数/命令产生信号</h3><p>注意，kill函数或命令的作用是给某个进程发送指定信号（不一定是杀死该进程）。</p><a class=post-dummy-target id=kill命令></a><h4>kill命令</h4><p><code>kill -SIGKILL pid</code>，发送SIGKILL（啥信号都行）到pid号进程。</p><a class=post-dummy-target id=kill函数></a><h4>kill函数</h4><p>给指定进程发送指定信号。（系统函数）</p><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>kill</span><span class=p>(</span><span class=n>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sig</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li>返回值：<ul><li>成功，返回<code>0</code>；</li><li>失败，返回<code>-1</code>，并设置<code>errno</code>，原因可能是ID非法、信号非法、普通用户杀init进程等权级问题。</li></ul></li><li><code>sig</code>：要发送的信号，应使用宏名称而非数字；</li><li><code>pid</code>：<ul><li><code>pid > 0</code>：发送信号给pid进程；</li><li><code>pid == 0</code>：发送信号给与调用kill函数进程属于同一进程组的所有进程；</li><li><code>pid &lt; -1</code>：取<code>abs(pid)</code>发送给对应进程组（因为进程组长和进程组ID相同，以此区分）；</li><li><code>pid == -1</code>：发送给进程有权发送的系统中的所有进程。</li></ul></li></ul><p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，它们互相关联，共同完成一个实体任务，每个进程组都有一个进程组组长，默认进程组ID与组长ID相同。</p><p>权限保护：root用户可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。只能向自己创建的进程发送信号。普通用户的基本规则是：发送者实际或有效用户ID==接收者实际或有效用户ID。</p><p>测试，父进程杀死一个子进程：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span><span class=o>*</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>child_index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=n>kpid</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>child_index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>child_index</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=o>+</span><span class=o>+</span> <span class=n>child_index</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>=</span><span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>child_index</span> <span class=o>=</span><span class=o>=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// kill 3th child
</span><span class=c1></span>                <span class=n>kpid</span> <span class=o>=</span> <span class=n>pid</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>fork error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>child_index</span> <span class=o>=</span><span class=o>=</span> <span class=mi>5</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// parent
</span><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>kill</span><span class=p>(</span><span class=n>kpid</span><span class=p>,</span> <span class=n>SIGKILL</span><span class=p>)</span> <span class=o>=</span><span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>kill error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=o>+</span><span class=o>+</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>-- parent : wait %d child</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>sec</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>sec</span> <span class=o>=</span><span class=o>=</span> <span class=mi>6</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>break</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>-%d- %dth child : %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>+</span><span class=o>+</span> <span class=n>sec</span><span class=p>,</span> <span class=n>child_index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>getpid</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
            <span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=软件条件产生信号></a><h3>软件条件产生信号</h3><a class=post-dummy-target id=alarm函数产生信号></a><h4>alarm函数产生信号</h4><p>设置一个定时器，指定时间后，内核会向当前进程发送14)SIGALRM信号，默认动作为终止进程。（系统函数）</p><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>unsigned</span> <span class=kt>int</span> <span class=nf>alarm</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>seconds</span><span class=p>)</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li>返回值：返回上一次设置的定时器还剩下的秒数，如果为0，则表示之前设置的定时器已经到期，或之前没设置定时器；<ul><li>无错误情况。</li></ul></li><li><code>seconds</code>：设置定时器的秒数；</li><li>使用<code>alarm(0)</code>可以取消定时器；</li><li>每一个进程都有且只有唯一一个定时器。</li></ul><p>测试：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span><span class=o>*</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>alarm</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>sec</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>sec : %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>+</span><span class=o>+</span> <span class=n>sec</span><span class=p>)</span><span class=p>;</span>
        <span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>sec</span> <span class=o>=</span><span class=o>=</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>alarm</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=p>;</span>
            <span class=n>sec</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>测试表明，如果上一个alarm还没结束就调用下一个alarm，会重置定时器。</p><a class=post-dummy-target id=setitimer函数产生信号--getitimer></a><h4>setitimer函数产生信号 / getitimer</h4><p>设定和获取内置定时器。（系统函数）</p><p>可以替代<code>alarm</code>，精度为微秒级us，可以实现周期定时（需要捕捉信号）。</p><p>函数原型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;sys/time.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>getitimer</span><span class=p>(</span><span class=kt>int</span> <span class=n>which</span><span class=p>,</span> <span class=k>struct</span> <span class=n>itimerval</span> <span class=o>*</span><span class=n>curr_value</span><span class=p>)</span><span class=p>;</span>
<span class=kt>int</span> <span class=nf>setitimer</span><span class=p>(</span><span class=kt>int</span> <span class=n>which</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>itimerval</span> <span class=o>*</span><span class=n>new_value</span><span class=p>,</span>
                <span class=k>struct</span> <span class=n>itimerval</span> <span class=o>*</span><span class=n>old_value</span><span class=p>)</span><span class=p>;</span>

<span class=k>struct</span> <span class=n>itimerval</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=n>timeval</span> <span class=n>it_interval</span><span class=p>;</span> <span class=cm>/* Interval for periodic timer 两次定时任务的间隔 */</span>
    <span class=k>struct</span> <span class=n>timeval</span> <span class=n>it_value</span><span class=p>;</span>    <span class=cm>/* Time until next expiration 定时时长*/</span>
<span class=p>}</span><span class=p>;</span>
<span class=k>struct</span> <span class=n>timeval</span> <span class=p>{</span>
    <span class=n>time_t</span>      <span class=n>tv_sec</span><span class=p>;</span>         <span class=cm>/* seconds 秒*/</span>
    <span class=n>suseconds_t</span> <span class=n>tv_usec</span><span class=p>;</span>        <span class=cm>/* microseconds 微秒*/</span>
<span class=p>}</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><ul><li>返回值：<ul><li>成功：返回<code>0</code>；</li><li>失败：返回<code>-1</code>。</li></ul></li><li><code>which</code>：指定定时方式，<ul><li><code>ITIMER_REAL</code>，自然定时，14)SIGLARM，计算自然时间；</li><li><code>ITIMER_VIRTUAL</code>，虚拟空间定时（用户空间），26)SIGVTALRM，只计算进程占用CPU的时间；</li><li><code>ITIMER_PROF</code>，运行时定时（用户+内核），27)SIGPROF，计算占用CPU及执行系统调用的时间。</li></ul></li><li><code>new_value</code>：定时的参数（周期定时时长，第一次定时时长，第一次定时后，每过一个周期发送一次定时信号）（两个参数都是0，清零）；</li><li><code>old_value</code>：上次定时剩余的时间。</li></ul><p>测试：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;sys/time.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=cp>#</span><span class=cp>include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>void</span> <span class=nf>myfunc</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>alarm</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span><span class=o>*</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=n>itimerval</span> <span class=n>it</span><span class=p>,</span> <span class=n>oldit</span><span class=p>;</span>

    <span class=n>signal</span><span class=p>(</span><span class=n>SIGALRM</span><span class=p>,</span> <span class=n>myfunc</span><span class=p>)</span><span class=p>;</span>

    <span class=c1>// 定时时长 2s0us
</span><span class=c1></span>    <span class=n>it</span><span class=p>.</span><span class=n>it_value</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
    <span class=n>it</span><span class=p>.</span><span class=n>it_value</span><span class=p>.</span><span class=n>tv_usec</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=c1>// 定时间隔 5s0us
</span><span class=c1></span>    <span class=n>it</span><span class=p>.</span><span class=n>it_interval</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
    <span class=n>it</span><span class=p>.</span><span class=n>it_interval</span><span class=p>.</span><span class=n>tv_usec</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>setitimer</span><span class=p>(</span><span class=n>ITIMER_REAL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>it</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldit</span><span class=p>)</span> <span class=o>=</span><span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>perror</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>setitimer error</span><span class=s>&#34;</span><span class=p>)</span><span class=p>;</span>
        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>int</span> <span class=n>sec</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=sa></span><span class=s>&#34;</span><span class=s>-%3d-</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>+</span><span class=o>+</span> <span class=n>sec</span><span class=p>)</span><span class=p>;</span>
        <span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>测试结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>xushun@xushun-virtual-machine:~/LinuxSysPrograming/test_sigal$ ./setitimer 
-  1-
-  2-
alarm
-  3-
-  4-
-  5-
-  6-
-  7-
alarm
-  8-
-  9-
- 10-
- 11-
- 12-
alarm
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=信号集操作函数></a><h2>信号集操作函数</h2></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>xushun</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2022-05-29</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fxushun1221.github.io%2f2022%2flinux%25E7%25B3%25BB%25E7%25BB%259F%25E7%25BC%2596%25E7%25A8%258B10-%25E4%25BF%25A1%25E5%258F%25B7%2f&text=%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9110%20-%20%e4%bf%a1%e5%8f%b7&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fxushun1221.github.io%2f2022%2flinux%25E7%25B3%25BB%25E7%25BB%259F%25E7%25BC%2596%25E7%25A8%258B10-%25E4%25BF%25A1%25E5%258F%25B7%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fxushun1221.github.io%2f2022%2flinux%25E7%25B3%25BB%25E7%25BB%259F%25E7%25BC%2596%25E7%25A8%258B10-%25E4%25BF%25A1%25E5%258F%25B7%2f&title=%e3%80%90Linux%e7%b3%bb%e7%bb%9f%e7%bc%96%e7%a8%8b%e3%80%9110%20-%20%e4%bf%a1%e5%8f%b7" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://xushun1221.github.io/tags/linux/><i class="fas fa-tag fa-fw"></i>&nbsp;Linux</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://xushun1221.github.io>Home</a></span></section></div><div class=post-nav><a href=https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B09-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/ class=prev rel=prev title="【Linux系统编程】09 - 进程间通信"><i class="fas fa-angle-left fa-fw"></i>【Linux系统编程】09 - 进程间通信</a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xushun1221.github.io/about/ target=_blank>xushun</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>