<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>【MySQL】22 - MVCC和undo log | XuShun's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="XuShun的个人博客，记录学习和生活。"><link rel=prev href=https://xushun1221.github.io/2022/mysql21-innodb%E9%97%B4%E9%9A%99%E9%94%81%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB/><link rel=next href=https://xushun1221.github.io/2022/centos7%E5%AE%89%E8%A3%85gooletest%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/><link rel=canonical href=https://xushun1221.github.io/2022/mysql22-mvcc%E5%92%8Cundo-log/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="【MySQL】22 - MVCC和undo log"><meta name=twitter:description content="已提交读和可重复读的实现原理 之前几篇已经分析了未提交读和串行化的实现原理，未提交读相当于没有做任何的并发控制，串行化完全使用共享锁、排他锁、"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"【MySQL】22 - MVCC和undo log","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xushun1221.github.io\/2022\/mysql22-mvcc%E5%92%8Cundo-log\/"},"image":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"datebase, MySQL","wordcount":2223,"url":"https:\/\/xushun1221.github.io\/2022\/mysql22-mvcc%E5%92%8Cundo-log\/","datePublished":"2022-11-10T00:00:00\x2b00:00","dateModified":"2022-11-10T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xushun","logo":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">【MySQL】22 - MVCC和undo log</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2022-11-10>2022-11-10</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 2223 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://xushun1221.github.io/categories/datebase/>Date base</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#已提交读和可重复读的实现原理>已提交读和可重复读的实现原理</a></li><li><a href=#undo-log-简述>undo log 简述</a></li><li><a href=#mvcc-快照读>MVCC 快照读</a></li><li><a href=#已提交读--解决脏读>已提交读 解决脏读</a><ul><li><a href=#无法解决--不可重复读>无法解决 不可重复读</a></li><li><a href=#无法解决--幻读>无法解决 幻读</a></li></ul></li><li><a href=#可重复读--解决脏读不可重复读>可重复读 解决脏读、不可重复读</a></li><li><a href=#可重复读--部分解决幻读>可重复读 部分解决幻读</a></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#已提交读和可重复读的实现原理>已提交读和可重复读的实现原理</a></li><li><a href=#undo-log-简述>undo log 简述</a></li><li><a href=#mvcc-快照读>MVCC 快照读</a></li><li><a href=#已提交读--解决脏读>已提交读 解决脏读</a><ul><li><a href=#无法解决--不可重复读>无法解决 不可重复读</a></li><li><a href=#无法解决--幻读>无法解决 幻读</a></li></ul></li><li><a href=#可重复读--解决脏读不可重复读>可重复读 解决脏读、不可重复读</a></li><li><a href=#可重复读--部分解决幻读>可重复读 部分解决幻读</a></li></ul></nav></div></details></div><div class=post-content><a class=post-dummy-target id=已提交读和可重复读的实现原理></a><h2>已提交读和可重复读的实现原理</h2><p>之前几篇已经分析了未提交读和串行化的实现原理，未提交读相当于没有做任何的并发控制，串行化完全使用共享锁、排他锁、间隙锁等，数据安全性、一致性最高，但是并发度最低。</p><p>对于其他两个隔离级别：已提交读、可重复读，它们的底层实现依赖于：<strong>MVCC（Multi-Version Concurrency Control）多版本并发控制机制</strong>。</p><p>MVCC提供的最重要的功能是，<strong>快照读</strong>，一种并发读取方式。（就像在某个时刻，对数据拍了张照片，不管数据怎么变，访问的都是照片里的数据一样）</p><p>实际上，InnoDB提供了两种读取操作，一种是之前提到的<strong>锁定读</strong>，读取数据之前，需要使用共享锁或排他锁锁定数据，另一种<strong>非锁定读</strong>，就是MVCC提供的快照读。</p><p>快照读方法依赖的底层技术是：<strong>undo log 回滚日志</strong>。</p><a class=post-dummy-target id=undo-log-简述></a><h2>undo log 简述</h2><p>undo log：回滚日志，保存了事务发生之前的数据的一个版本，用于事务执行时的回滚操作，同时也是实现多版本并发控制（MVCC）下快照读操作的关键技术。</p><p>undo log 示意图：</p><p><figure><img src=/svg/loading.min.svg data-sizes=auto data-src=/post_images/posts/Database/MySQL/undolog.jpg alt title="undo log" class=lazyload><figcaption class=image-caption>undo log</figcaption></figure></p><ul><li><code>DB_TRX_ID</code>：事务id</li><li><code>DB_ROLL_PTR</code>：回滚指针，指向数据的上一个版本（在undo log中的）</li><li><code>DB_ROW_ID</code>：InnoDB中，如果没有给表定义主键，它会用该字段作为默认主键</li></ul><p>如果要在某张表中修改某一行的数据，首先会将原始数据加入undo log中，修改该行的<code>DB_TRX_ID</code>和<code>DB_ROLL_PTR</code>指向undo log中的原始数据节点。再次修改时，会将当前行加入undo log，同样修改指针，此时就形成了一个三个节点的链表。</p><p>如果要插入一行新数据，首先会在undo log中生成一个空节点，然后当前行的指针，指向该空节点。</p><a class=post-dummy-target id=mvcc-快照读></a><h2>MVCC 快照读</h2><p>MVCC是多版本并发控制（Multi-Version Concurrency Control，简称MVCC），是MySQL中基于乐观锁理论实现隔离级别的方式，用于实现已提交读和可重复读隔离级别的实现，也经常称为多版本数据库。MVCC机制会生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本（系统版本号和事务版本号）。</p><p>MVCC中的读操作可以分为两类：</p><ol><li>快照读（snapshot read）（非锁定读），读的是记录的可见版本，不用加锁，如select；</li><li>当前读（current read）（锁定读），读取的是记录的最新版本，并且当前读返回的记录。如insert、delete、update、select&mldr;lock in share mode、for update。</li></ol><p>快照内容读取原则：</p><ol><li>版本未提交，无法生成快照</li><li>版本已提交，但是在快照创建后提交的，无法读取</li><li>版本已提交，但是在快照创建前提交的，可以读取</li><li>当前事务内自己的更新，可以读到</li></ol><a class=post-dummy-target id=已提交读--解决脏读></a><h2>已提交读 解决脏读</h2><p>脏读，简单说就是一个事务对数据的修改尚未提交时，另一个事务读取了这个事务未提交的修改，而未提交修改可能rollback，导致一致性错误。</p><p>在已提交读隔离级别下，脏读被解决了，原理简述如下：<br>在已提交读级别下，对数据的读取，使用的是<strong>非锁定读</strong>，没有对数据进行加锁（S、X锁），而是使用MVCC提供的<strong>快照读</strong>。事务<strong>每一次select</strong>时，都会对被查询的数据生成快照，生成数据快照的前提，就是数据的状态必须时<strong>committed已提交的</strong>。其他事务对数据的修改在未提交状态下，不会被生成快照，快照使用的仍是已提交的老数据。</p><a class=post-dummy-target id=无法解决--不可重复读></a><h3>无法解决 不可重复读</h3><p>已提交读级别下，可以阻止未提交状态数据的脏读，但是仍然会出现不可重复读的现象。原因是，每一次select都会重新产生一次数据快照。其他事务更新并提交后的数据，可以实时反馈到当前事务的select结果中。</p><a class=post-dummy-target id=无法解决--幻读></a><h3>无法解决 幻读</h3><p>原因和不可重复读相同，每次select都会重新生成快照，其他事务插入或删除的数据（已提交），当然可以反馈到当前事务的查询结果中。</p><a class=post-dummy-target id=可重复读--解决脏读不可重复读></a><h2>可重复读 解决脏读、不可重复读</h2><p>解决脏读的原因同样是，使用快照读。</p><p>在可重复读级别下，解决不可重复读现象的原理：<br>可重复读级别下，当前事务<strong>第一次select</strong>产生数据快照，而且<strong>只产生一次</strong>数据快照。在此过程中，其他事务虽然更新了数据（无论是否提交），当前事务依然在第一次select产生的数据快照上进行select查询。所以看不到其他事务对数据的更新。</p><a class=post-dummy-target id=可重复读--部分解决幻读></a><h2>可重复读 部分解决幻读</h2><p>在可重复读级别下，幻读的现象有两种情况：</p><ol><li>在当前事务中，进行select查询时，其他事务插入或删除的数据记录不会反馈到当前事务查询结果中；</li><li>在另一个事务中添加了一个数据记录（提交了），如果在当前事务中，使用update更新了刚刚添加的记录，再次select查询时，就会将其查询到。产生幻读了。</li></ol><p>所以我们说，可重复读级别<strong>部分</strong>解决了幻读问题。</p><p>仅select不会幻读的原因：<br>当前事务如果仅进行select，使用<strong>快照读</strong>，它查询的是第一次select时生成的数据快照，自然不会看到其他事务添加的记录。</p><p>update更新了其他事务插入的数据，为什么会幻读？原因如下：<br>当前事务使用update进行更新时，用的是<strong>当前读</strong>来查询记录！而不是在快照上匹配。所以当前事务，可以更新其他事务插入的记录。在当前事务进行select查询时，它不仅能看见快照上的记录，<strong>还能看见自己进行过更新的记录</strong>（事务快照读的原则），所以更新后进行查询时，就可以看到其他事务插入的记录。这也是幻读的情况。</p><p>当前事务是怎么看到自己的更新呢？因为<code>DB_TRX_ID</code>事务号记录了进行更新的事务。</p></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>xushun</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2022-11-10</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fxushun1221.github.io%2f2022%2fmysql22-mvcc%25E5%2592%258Cundo-log%2f&text=%e3%80%90MySQL%e3%80%9122%20-%20MVCC%e5%92%8cundo%20log&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fxushun1221.github.io%2f2022%2fmysql22-mvcc%25E5%2592%258Cundo-log%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fxushun1221.github.io%2f2022%2fmysql22-mvcc%25E5%2592%258Cundo-log%2f&title=%e3%80%90MySQL%e3%80%9122%20-%20MVCC%e5%92%8cundo%20log" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://xushun1221.github.io/tags/datebase/><i class="fas fa-tag fa-fw"></i>&nbsp;datebase</a>&nbsp;
</span><span class=tag><a href=https://xushun1221.github.io/tags/mysql/><i class="fas fa-tag fa-fw"></i>&nbsp;MySQL</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://xushun1221.github.io>Home</a></span></section></div><div class=post-nav><a href=https://xushun1221.github.io/2022/mysql21-innodb%E9%97%B4%E9%9A%99%E9%94%81%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB/ class=prev rel=prev title="【MySQL】21 - InnoDB间隙锁：解决幻读"><i class="fas fa-angle-left fa-fw"></i>【MySQL】21 - InnoDB间隙锁：解决幻读</a>
<a href=https://xushun1221.github.io/2022/centos7%E5%AE%89%E8%A3%85gooletest%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/ class=next rel=next title=CentOS7安装GooleTest测试框架>CentOS7安装GooleTest测试框架<i class="fas fa-angle-right fa-fw"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xushun1221.github.io/about/ target=_blank>xushun</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>