# 算法--位运算_异或运算


# 算法--位运算_异或运算

## 什么是异或
逻辑运算符异或（exclusive or），XOR或EOR（编程语言中多用`^`），对两个运算元的一种逻辑析取类型，异或算符的值为真当且仅当两个运算元中一个为真，而另一个为假。

真值表

|Y|B=0|B=1|
|:---:|:---:|:---:|
|A=0|0|1|
|A=1|1|0|

*异或运算也可以理解为，二进制的**无进位加法**。*


## 异或的性质

1. 恒等律 `x^0=x`
2. 归零律 `x^x=0`
3. 交换律 `a^b=b^a`
4. 结合律 `(a^b)^c=a^(b^c)`


## 异或的应用

### 判断两数是否相等
```C++
bool equal(int a, int b) {
	return a ^ b == 0;
}
```

### 变量置零
```C++
int a = 123;
a ^= a; // a == 0
```

### 翻转特定位
由真值表可知，无论`1`或`0`，与`1`做异或运算都将得到原值的相反值。`1^1=0` `0^1=1`<br>例如，将`a`的第5位翻转。
```C++
unsigned int    a = 0b10100100;
unsigned int mask = 0b00010000;
unsigned int b = a ^ mask; // b = 0b10110100
```

### 判断二进制数中1的数量的奇偶
将所有的二进制位依次异或，结果为`1`则`1`的个数为奇，否则为偶。<br>例如，`10100001`，`1^0^1^0^0^0^0^1=1`，由异或运算的交换律和结合律可知。

### 经典题目：不使用额外空间，交换两个变量的值
```C++
void swap(int & a, int & b) {
	a = a ^ b; // a == a ^ b;          b == b;
	b = a ^ b; // a == a ^ b;          b == a ^ b ^ b == a;
	a = a ^ b; // a == a ^ b ^ a == b; b == a;
}
```

### 题目1：找出数组中唯一出现奇数次的数
[LeetCode136](https://leetcode-cn.com/problems/single-number/)<br>在一个int数组中，只有一个数出现了奇数次，其他数都出现偶数次，请找出这个数。

思路：只需将所有出现的数异或起来，即可得到唯一的奇数次出现的数。解释：
- 根据异或的交换律和结合律，偶数次出现的数都被消掉了。
- 或者看作将所有的数，进行二进制无进位加法，出现偶数次的数，在相同的位上都是相同的，加法运算可以将其归零；只有奇数次出现的数的各位得以保留。

代码：
```C++
int singleNum(vector<int> nums) {
	int eor = 0;
	for (auto x : nums)
		eor ^= x;
	return eor;
} 
```
时间复杂度 $O\left(n\right)$
空间复杂度 $O\left(1\right)$


### 题目2：找出数组中唯二出现奇数次的数
在一个int数组中，有两个数出现了奇数次，其他数都出现偶数次，请找出这两个数。

思路：假设出现奇数次的数为`a`和`b`，将所有数异或，得`eor1 = a ^ b`，因为`a`和`b`是两个不同的数，所以`eor1 != 0`，那么eor中，必然有某一位或者某几位为`1`，我们可以取`eor1`中最右的为`1`的一位，作为区分`a`和`b`的方法，假设`a`数该位置上为`1`。将所有该位置上为`0`的数异或，得`eor2 == b`，所以我们要找的两个数为`eor2 == b`和`eor1 ^ eor2 == a ^ b ^ b == a`。

如何在一个二进制数`x`中，找到最右边的值为`1`的位？`x & (~x + 1)`<br>`& ~`分别是按位与和取反。看个例子
```C++
int x = 0b110010100;
//            x = 110010100
//           ~x = 001101011
//       ~x + 1 = 001101100
// x & (~x + 1) = 000000100
```

代码：
```C++
vector<int> doubleNum(vector<int> nums) {
	int eor1 = 0;
	for (auto x : nums)
		eor1 ^= x;
	// 假设出现奇数次的两个数是a和b
	// eor1 == a ^ b
	int rightBit = eor1 & (~eor1 + 1);
	// rightBit找到了a^b最右的为1的位
	int eor2 = 0;
	for (auto x : nums)
		if ((x & rightBit) == 0)
			eor2 ^= x;
	// eor2 == a和b中rightBit位不为1的数
	return {eor2, eor1 ^ eor2};
}
```
空间复杂度 $O\left(n\right)$
空间复杂度 $O\left(1\right)$
