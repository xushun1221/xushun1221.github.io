# 【C++基础】01 - 进程虚拟地址空间内存划分和布局


## 虚拟地址空间

这里讨论的虚拟地址空间，是在x86-32位-Linux环境下的。

任何编程语言的程序代码编译为可执行文件（存放在磁盘上）时，都会生成指令和文件，当运行该可执行文件时，操作系统就会将其加载到内存中（不是简单地直接加载到物理内存中）。

在32位Linux系统中，系统会给每一个进程分配一个$2^{32}$字节（4GiB）大小的空间，这个空间是**进程的虚拟地址空间**。

何谓虚拟，看如下解释：  
> 它存在，你能看得见，它是物理的；  
> 它存在，你看不见，它是透明的；  
> 它不存在，你却看得见，它是虚拟的；
> 它不存在，你看不见，它被删除了！

## 虚拟地址空间的划分
进程的虚拟地址空间（共4GiB），可以分为两个部分：  
1. user space 用户空间（共3GiB）：0x00000000~0xBFFFFFFF
2. kernal space 内核空间（共1GiB）：0xC0000000~0xFFFFFFFF

这是32位系统默认的分配比例。

![](/post_images/posts/Coding/C++基础/linux虚拟地址空间划分.jpg "linux虚拟地址空间划分")

用户空间划分为以下部分：  
1. 0x00000000~0x08047FFF：预留空间，用户空间并非从头开始使用，这一部分地址不可访问，如`char* p = nullptr; strlen(p);`，程序试图访问保护的地址，就会出错；
2. 0x08048000~0xBFFFFFFF：
   1. `.text`（代码段）：存放机器指令；
   2. `.rodata`（只读数据段）：存放只读数据，如`const char* = "hello world"`中的字符串常量就存储在只读数据段中；
   3. `.data`（数据段）：存放已初始化且初始化值不为0的变量；
   4. `.bss`（数据段）：存放未初始化以及初始化值为0的变量；
   5. 堆空间：调用`new`和`malloc`时会分配堆中内存（从低地址向高地址增长）；
   6. 共享库：程序运行过程中加载的动态链接库`.so`；
   7. 栈空间：程序执行过程中用来存放临时变量和函数返回值的区域，由系统分配和回收，每个进程（线程）都有自己独立的栈空间（从高地址向低地址增长）；
   8. 命令行参数&环境变量

内核空间划分为以下部分：
1. ZONE_DMA
2. ZONE_NORMAL
3. ZONE_HIGHMEM



## 问题
了解了Linux虚拟地址空间后，考虑这样的代码，分别声明初始化的、初始化为0的、未初始化的三个一组变量，分别声明为全局变量、静态全局变量、main函数内的变量、main函数内的全局变量。

这些变量分别存放在内存的什么位置上呢？

```C++
#include <iostream>
using namespace std;

int gdata1 = 10;
int gdata2 = 0;
int gdata3;

static int gdata4 = 11;
static int gdata5 = 0;
static int gdata6;

int main() {
    int a = 12;
    int b = 0;
    int c;

    static int e = 13;
    static int f = 0;
    static int g;

    return 0;
}
```

