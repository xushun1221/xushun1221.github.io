<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>数据结构-链表 | XuShun's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="XuShun的个人博客，记录学习和生活。"><link rel=prev href=https://xushun1221.github.io/2020/how-to-do-if-no-enough-time/><link rel=next href=https://xushun1221.github.io/2020/life-weekly-8/><link rel=canonical href=https://xushun1221.github.io/2020/data-structure-linkedlist/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="数据结构-链表"><meta name=twitter:description content="链表是一种最为基础的数据结构，由一系列结点组成，每个结点不仅包含值，还包含指向下一个结点（有时也包括上一个结点）的指针。相比于数组，在链表中"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"数据结构-链表","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xushun1221.github.io\/2020\/data-structure-linkedlist\/"},"image":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"数据结构与算法","wordcount":2949,"url":"https:\/\/xushun1221.github.io\/2020\/data-structure-linkedlist\/","datePublished":"2020-02-20T00:00:00\x2b00:00","dateModified":"2020-03-28T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xushun","logo":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">数据结构-链表</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2020-02-20>2020-02-20</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 2949 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://xushun1221.github.io/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/>爱编程爱技术的孩子</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#1-单链表>1. 单链表</a><ul><li><a href=#11-获取指定结点的值>1.1 获取指定结点的值</a></li><li><a href=#12-插入结点>1.2 插入结点</a></li><li><a href=#13-删除结点>1.3 删除结点</a></li><li><a href=#14-打印链表>1.4 打印链表</a></li></ul></li><li><a href=#2-双指针技巧>2. 双指针技巧</a><ul><li><a href=#21-环形链表>2.1 环形链表</a></li><li><a href=#22-相交链表>2.2 相交链表</a></li></ul></li><li><a href=#其它资料>其它资料</a></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#1-单链表>1. 单链表</a><ul><li><a href=#11-获取指定结点的值>1.1 获取指定结点的值</a></li><li><a href=#12-插入结点>1.2 插入结点</a></li><li><a href=#13-删除结点>1.3 删除结点</a></li><li><a href=#14-打印链表>1.4 打印链表</a></li></ul></li><li><a href=#2-双指针技巧>2. 双指针技巧</a><ul><li><a href=#21-环形链表>2.1 环形链表</a></li><li><a href=#22-相交链表>2.2 相交链表</a></li></ul></li><li><a href=#其它资料>其它资料</a></li></ul></nav></div></details></div><div class=post-content><p>链表是一种最为基础的数据结构，由一系列结点组成，每个结点不仅包含值，还包含指向下一个结点（有时也包括上一个结点）的指针。相比于数组，在链表中访问指定的元素则需要$O(N)$的复杂度，但进行插入和删除操作只需要$O(1)$的复杂度</p><a class=post-dummy-target id=1-单链表></a><h2>1. 单链表</h2><p>一个单链表的例子如下，蓝色箭头显示链表中的结点是如何相连的</p><p><img src=https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/05/screen-shot-2018-04-12-at-152754.png style=zoom:50%></p><p>关于结点的最常见的定义如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//单链表结点
</span><span class=c1></span><span class=kd>type</span> <span class=nx>node</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>val</span>  <span class=kt>int</span>   <span class=c1>// 结点的值
</span><span class=c1></span>	<span class=nx>next</span> <span class=o>*</span><span class=nx>node</span> <span class=c1>// 指向下一个结点的指针
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>多数情况下，我们使用头结点来表示整个链表，并将链表的长度存储其中。虽然增加了一个结点的存储，但带来的好处却是巨大的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>//头结点，也是单链表的起始
</span><span class=c1></span><span class=kd>type</span> <span class=nx>singlyLinkedList</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>length</span> <span class=kt>int</span>   <span class=c1>// 链表长度
</span><span class=c1></span>	<span class=nx>next</span>   <span class=o>*</span><span class=nx>node</span> <span class=c1>// 指向第一个结点的指针
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>定义了头结点的情况下，需要事先对链表进行初始化</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=cm>/* @description: 初始化链表(头结点)
</span><span class=cm>   @author: shuzang 2020-03-28
</span><span class=cm>   @param: 无
</span><span class=cm>   @return: _ *singleLinkedList 指向单链表(头结点)的指针
</span><span class=cm>*/</span>
<span class=kd>func</span> <span class=nf>constructor</span><span class=p>(</span><span class=p>)</span> <span class=o>*</span><span class=nx>singlyLinkedList</span> <span class=p>{</span>
	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>singlyLinkedList</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span><span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=11-获取指定结点的值></a><h3>1.1 获取指定结点的值</h3><p>本质是对链表的遍历，修改操作也是相同的算法，只是需要遍历到指定元素后进行修改即可，程序实现如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=cm>/* @description: 如果索引有效，获取链表中第 index 个结点的值
</span><span class=cm>   @author: shuzang 2020-03-28
</span><span class=cm>   @param: index int 要获取的元素位置
</span><span class=cm>   @return: _ int 获取元素的值; _ error 索引无效时返回错误
</span><span class=cm>*/</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>list</span> <span class=o>*</span><span class=nx>singlyLinkedList</span><span class=p>)</span> <span class=nf>Get</span><span class=p>(</span><span class=nx>index</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nx>index</span> <span class=p>&lt;</span> <span class=mi>1</span> <span class=o>||</span> <span class=nx>index</span> <span class=p>&gt;</span> <span class=nx>list</span><span class=p>.</span><span class=nx>length</span> <span class=p>{</span>
		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;param - index is invalid&#34;</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=nx>cur</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nx>next</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>index</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>next</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>val</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=12-插入结点></a><h3>1.2 插入结点</h3><p>如果我们想在 prev 结点后插入新结点，基本操作步骤如下</p><ol><li>初始化新结点 newNode</li><li>将新结点的 Next 指针指向 prev 结点的下一个结点</li><li>将 prev 结点的 Next 指针指向新结点</li></ol><p><img src=https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/04/26/screen-shot-2018-04-25-at-163243.png style=zoom:50%></p><p>在开头插入结点和在结尾插入结点是两种特殊情况，前者需要考虑头结点的存在，后者需要遍历到链表结尾，我们不再详述。三种插入的程序实现如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=cm>/* @description: 在链表的第一个元素之前插入结点，插入后，新结点将成为链表的第一个结点
</span><span class=cm>   @author: shuzang	2020-03-28
</span><span class=cm>   @param: val	int	要添加的元素的值
</span><span class=cm>   @return: 无
</span><span class=cm>*/</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>list</span> <span class=o>*</span><span class=nx>singlyLinkedList</span><span class=p>)</span> <span class=nf>AddAtHead</span><span class=p>(</span><span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>list</span><span class=p>.</span><span class=nx>next</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>node</span><span class=p>{</span><span class=nx>val</span><span class=p>,</span> <span class=nx>list</span><span class=p>.</span><span class=nx>next</span><span class=p>}</span>
	<span class=nx>list</span><span class=p>.</span><span class=nx>length</span><span class=o>++</span>
<span class=p>}</span>

<span class=cm>/* @description: 将新结点追加到链表的最后一个元素
</span><span class=cm>   @author: shuzang 2020-03-28
</span><span class=cm>   @param: val int 要添加的元素的值
</span><span class=cm>   @return: 无
</span><span class=cm>*/</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>list</span> <span class=o>*</span><span class=nx>singlyLinkedList</span><span class=p>)</span> <span class=nf>AddAtTail</span><span class=p>(</span><span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>newNode</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>node</span><span class=p>{</span><span class=nx>val</span><span class=p>,</span> <span class=kc>nil</span><span class=p>}</span>

	<span class=k>if</span> <span class=nx>list</span><span class=p>.</span><span class=nx>next</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>list</span><span class=p>.</span><span class=nx>next</span> <span class=p>=</span> <span class=nx>newNode</span>
	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
		<span class=nx>cur</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nx>next</span>
		<span class=k>for</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>next</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>next</span>
		<span class=p>}</span>
		<span class=nx>cur</span><span class=p>.</span><span class=nx>next</span> <span class=p>=</span> <span class=nx>newNode</span>
	<span class=p>}</span>

	<span class=nx>list</span><span class=p>.</span><span class=nx>length</span><span class=o>++</span>
<span class=p>}</span>

<span class=cm>/* @description: 在链表的第 index 个结点前添加结点，插入后新结点成为第 index 个结点，
</span><span class=cm>如果 index 大于链表长度，结点添加到链表末尾，如果 index 小于 1，则在头部插入结点
</span><span class=cm>   @author: shuzang 2020-03-28
</span><span class=cm>   @param: index int 要插入的位置，起始数字为 1; val int 要插入的元素的值
</span><span class=cm>   @return: 无
</span><span class=cm>*/</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>list</span> <span class=o>*</span><span class=nx>singlyLinkedList</span><span class=p>)</span> <span class=nf>AddAtIndex</span><span class=p>(</span><span class=nx>index</span><span class=p>,</span> <span class=nx>val</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nx>index</span> <span class=p>&gt;</span> <span class=nx>list</span><span class=p>.</span><span class=nx>length</span> <span class=p>{</span>
		<span class=nx>list</span><span class=p>.</span><span class=nf>AddAtTail</span><span class=p>(</span><span class=nx>val</span><span class=p>)</span>
	<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>index</span> <span class=o>&lt;=</span> <span class=mi>1</span> <span class=p>{</span>
		<span class=nx>list</span><span class=p>.</span><span class=nf>AddAtHead</span><span class=p>(</span><span class=nx>val</span><span class=p>)</span>
	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
		<span class=nx>cur</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nx>next</span>
		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>index</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
			<span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>next</span>
		<span class=p>}</span>
		<span class=nx>cur</span><span class=p>.</span><span class=nx>next</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>node</span><span class=p>{</span><span class=nx>val</span><span class=p>,</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>next</span><span class=p>}</span>
	<span class=p>}</span>

	<span class=nx>list</span><span class=p>.</span><span class=nx>length</span><span class=o>++</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=13-删除结点></a><h3>1.3 删除结点</h3><p>删除结点只需要将前一个结点的 Next 指针指向当前结点的下一个结点，需要注意的是我们只需要遍历到待插入结点的前一个结点即可</p><p><img src=https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/04/26/screen-shot-2018-04-26-at-203640.png style=zoom:50%></p><p>程序实现如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=cm>/* @description: 如果索引有效，删除链表第 index 个位置的结点
</span><span class=cm>   @author: shuzang 2020-03-28
</span><span class=cm>   @param: index int 要删除的元素位置
</span><span class=cm>   @return: _ error 索引无效时返回错误
</span><span class=cm>*/</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>list</span> <span class=o>*</span><span class=nx>singlyLinkedList</span><span class=p>)</span> <span class=nf>DeleteAtIndex</span><span class=p>(</span><span class=nx>index</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nx>index</span> <span class=p>&lt;</span> <span class=mi>1</span> <span class=o>||</span> <span class=nx>index</span> <span class=p>&gt;</span> <span class=nx>list</span><span class=p>.</span><span class=nx>length</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;param - index is invalid&#34;</span><span class=p>)</span>
	<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>index</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
		<span class=nx>list</span><span class=p>.</span><span class=nx>next</span> <span class=p>=</span> <span class=nx>list</span><span class=p>.</span><span class=nx>next</span><span class=p>.</span><span class=nx>next</span>
	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
		<span class=nx>cur</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nx>next</span>
		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>index</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
			<span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>next</span>
		<span class=p>}</span>
		<span class=nx>cur</span><span class=p>.</span><span class=nx>next</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>next</span><span class=p>.</span><span class=nx>next</span>
	<span class=p>}</span>

	<span class=nx>list</span><span class=p>.</span><span class=nx>length</span><span class=o>--</span>
	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=14-打印链表></a><h3>1.4 打印链表</h3><p>一个工具函数，不是必要的，但是很常用，打印输出整个单链表</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=cm>/* @description: 工具函数，打印单链表
</span><span class=cm>   @author: shzuang 2020-03-28
</span><span class=cm>   @param: 无
</span><span class=cm>   @return: 无
</span><span class=cm>*/</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>list</span> <span class=o>*</span><span class=nx>singlyLinkedList</span><span class=p>)</span> <span class=nf>PrintList</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>cur</span> <span class=o>:=</span> <span class=nx>list</span><span class=p>.</span><span class=nx>next</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=p>(</span><span class=s>&#34;当前单链表为: &#34;</span><span class=p>)</span><span class=p>)</span>
	<span class=k>for</span> <span class=p>;</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>next</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=nx>cur</span> <span class=p>=</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>next</span> <span class=p>{</span>
		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%v-&gt;&#34;</span><span class=p>,</span> <span class=nx>cur</span><span class=p>.</span><span class=nx>val</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>cur</span><span class=p>.</span><span class=nx>val</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=2-双指针技巧></a><h2>2. 双指针技巧</h2><p>双指针是一种经典的链表操作技巧，对很多问题都有非常好的作用，下面通过几个经典问题进行介绍</p><a class=post-dummy-target id=21-环形链表></a><h3>2.1 环形链表</h3><p>关于环形链表的经典问法是：给定一个链表，判断链表中是否有环。更多扩展的问题包括：</p><ol><li>如果存在环，找出环的入口结点</li><li>如果存在环，求环中的结点个数</li><li>如果存在环，求链表长度</li></ol><p>这些问题都可以通过Floyd判环算法解决，算法的基本思想可以拿跑圈来举例说明：假设两个人在一条环形跑道上跑步，同时出发，但速度一个快一个慢，我们知道，如果一直跑下去，快的人总能追上慢的一方，此时快的一方多跑的路程一定是跑道长度的整数倍，即我们所说的「套圈了」</p><p>有人也拿龟兔赛跑举例，但思想是相同的。基于上述思想，Floyd提出了双指针算法（快指针和慢指针），算法分两个阶段。</p><p><strong>第一阶段</strong>可以用来判断是否有环。慢指针（龟）每次前进一步，快指针（兔）每次前进两步（两步或多步效果是等价的，只要一个比另一个快就行）。如果两者在链表头以外的某一点相遇（即相等）了，那么说明链表有环，否则，如果（快指针）到达了链表的结尾，那么说明没环。</p><p><img src=https://pic.leetcode-cn.com/99987d4e679fdfbcfd206a4429d9b076b46ad09bd2670f886703fb35ef130635-image.png style=zoom:50%></p><p><strong>第二阶段</strong>确定环的起点。假设链表起点到环的起点距离为$F$（这里我们提到的距离是结点个数），第一阶段相遇时的结点距离环的起点为$a$，环的周长为 $n = a + b$。那么第一阶段两者相遇时，慢指针移动的总距离为 $d = F + r_1 n + a$，由于快指针移动速度是慢指针的两倍，其移动的总距离为$2d = F + r_2 n + a$，其中$r_1$为慢指针第一次相遇时转过的圈数，$r_2$为快指针第一次相遇时转过的圈数。我们令两者相减（快减慢），那么得到 $d = (r_2 - r_1)n$，意为 $d$ 是环长度的倍数。</p><p>因此，我们将慢指针移动到链表的起点，快指针保持在第一次相遇的结点，然后两者同时开始移动，但这次两者每次都只移动一步。当慢指针前进了 $F$ 到达环的起点时，快指针距离链表起点 $d + F$，由于 $d$ 是环长度的倍数，这个距离可以看作快指针从链表起点出发，走到环的起点，然后绕环转了几圈，但此时停在了环的起点。即两个第二次的相遇点就是环的起点。</p><p>程序实现如下，需要注意的有两点</p><ol><li>调用 Next 字段前，检查结点是否为空</li><li>仔细考虑循环的结束条件</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>detectCycle</span><span class=p>(</span><span class=nx>head</span> <span class=o>*</span><span class=nx>LinkedList</span><span class=p>)</span> <span class=o>*</span><span class=nx>Node</span> <span class=p>{</span>
    <span class=nx>slow</span><span class=p>,</span> <span class=nx>fast</span> <span class=o>:=</span> <span class=nx>head</span><span class=p>.</span><span class=nx>Next</span><span class=p>,</span><span class=nx>head</span><span class=p>.</span><span class=nx>Next</span>
    <span class=c1>//第一阶段，循环退出条件为fast指针或fast.Next为nil，因为fast始终在slow前面，所以不需要判断slow
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>fast</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>fast</span><span class=p>.</span><span class=nx>Next</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=nx>slow</span> <span class=p>=</span> <span class=nx>slow</span><span class=p>.</span><span class=nx>Next</span>
        <span class=nx>fast</span> <span class=p>=</span> <span class=nx>fast</span><span class=p>.</span><span class=nx>Next</span><span class=p>.</span><span class=nx>Next</span>
        <span class=k>if</span> <span class=nx>fast</span> <span class=o>==</span> <span class=nx>slow</span> <span class=p>{</span>
            <span class=nx>slow</span> <span class=p>=</span> <span class=nx>head</span>
            <span class=k>break</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>//退出循环要么是到达相遇点，要么是没有环，没有环时返回nil
</span><span class=c1></span>    <span class=k>if</span> <span class=nx>fast</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>||</span> <span class=nx>fast</span><span class=p>.</span><span class=nx>Next</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>nil</span>
    <span class=p>}</span>
    <span class=c1>//第二阶段,每次移动一步直到相遇，slow指针已经调整完毕
</span><span class=c1></span>    <span class=k>for</span> <span class=nx>fast</span> <span class=o>!=</span> <span class=nx>slow</span> <span class=p>{</span>
        <span class=nx>slow</span> <span class=p>=</span> <span class=nx>slow</span><span class=p>.</span><span class=nx>Next</span>
        <span class=nx>fast</span> <span class=p>=</span> <span class=nx>fast</span><span class=p>.</span><span class=nx>Next</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>fast</span> <span class=c1>//此时fast == slow，返回任一个都可以
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table></div></div><p>得到环的起点后，快指针再跑一圈就可以得到环的长度，相应的，慢指针移回链表起点再走一遍然后和环的长度相加可以得到链表长度。</p><a class=post-dummy-target id=22-相交链表></a><h3>2.2 相交链表</h3><p>经典问法是：判断两个无环链表是否相交，如果相交，求相交的起始结点。如下图在 c1 结点相交。</p><p><img src=https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png style=zoom:67%></p><p>基本求解步骤如下</p><ol><li>创建两个指针 pA 和 pB，分别初始化为链表 <code>A</code> 和 <code>B</code> 的头结点。然后让它们向后逐结点遍历。</li><li>当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (注意，是链表 B)；类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。</li><li>若在某一时刻 pA 和 pB 相遇，则该结点为相交结点。</li></ol><p>可以这样理解，除去相交部分（3个结点），A 有 2 个结点，B有 3 个结点。重定位后，A多走的距离正好是重定位前少走的距离，这样直到相交，两者都走了 2+3+3 个结点距离。</p><p>程序实现如下，正常情况两个链表不相交的条件是最后一个结点不相同，但是实际上如果任意一个链表为空或两者不相交，根据循环最后都会走到 nil，因此也会跳出循环，而且返回pA或pB的值 nil 也是我们想要的返回值，如果相交，同样直接返回pA或pB的值即可。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>getIntersectionNode</span><span class=p>(</span><span class=nx>headA</span><span class=p>,</span> <span class=nx>headB</span> <span class=o>*</span><span class=nx>LinkedList</span><span class=p>)</span> <span class=o>*</span><span class=nx>Node</span> <span class=p>{</span>
    <span class=nx>pA</span><span class=p>,</span><span class=nx>pB</span> <span class=o>:=</span> <span class=nx>headA</span><span class=p>.</span><span class=nx>Next</span><span class=p>,</span> <span class=nx>headB</span><span class=p>.</span><span class=nx>Next</span>
    <span class=k>for</span> <span class=nx>pA</span> <span class=o>!=</span> <span class=nx>pB</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nx>pA</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>pA</span> <span class=p>=</span> <span class=nx>headB</span><span class=p>.</span><span class=nx>Next</span>
        <span class=p>}</span><span class=k>else</span><span class=p>{</span>
            <span class=nx>pA</span> <span class=p>=</span> <span class=nx>pA</span><span class=p>.</span><span class=nx>Next</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=nx>pB</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
            <span class=nx>pB</span> <span class=p>=</span> <span class=nx>headA</span><span class=p>.</span><span class=nx>Next</span>
        <span class=p>}</span><span class=k>else</span><span class=p>{</span>
            <span class=nx>pB</span> <span class=p>=</span> <span class=nx>pB</span><span class=p>.</span><span class=nx>Next</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>pA</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=其它资料></a><h2>其它资料</h2><p><a href=https://xiaoneng.blog.csdn.net/article/details/104007259 target=_blank>Leetcode刷题总结之链表</a></p></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>xushun</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2020-03-28</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fxushun1221.github.io%2f2020%2fdata-structure-linkedlist%2f&text=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-%e9%93%be%e8%a1%a8&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fxushun1221.github.io%2f2020%2fdata-structure-linkedlist%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fxushun1221.github.io%2f2020%2fdata-structure-linkedlist%2f&title=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-%e9%93%be%e8%a1%a8" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://xushun1221.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/><i class="fas fa-tag fa-fw"></i>&nbsp;数据结构与算法</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://xushun1221.github.io>Home</a></span></section></div><div class=post-nav><a href=https://xushun1221.github.io/2020/how-to-do-if-no-enough-time/ class=prev rel=prev title=时间不够用怎么办><i class="fas fa-angle-left fa-fw"></i>时间不够用怎么办</a>
<a href=https://xushun1221.github.io/2020/life-weekly-8/ class=next rel=next title="书藏的生活周刊第 8 期 (20200221)">书藏的生活周刊第 8 期 (20200221)<i class="fas fa-angle-right fa-fw"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xushun1221.github.io/about/ target=_blank>xushun</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>