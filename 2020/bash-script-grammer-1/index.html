<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Bash脚本语法1 | XuShun's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=Description content="XuShun的个人博客，包括各种学习和生活记录。"><link rel=prev href=https://xushun1221.github.io/2020/operate-system-6-file-management/><link rel=next href=https://xushun1221.github.io/2020/http-method/><link rel=canonical href=https://xushun1221.github.io/2020/bash-script-grammer-1/><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bash脚本语法1"><meta name=twitter:description content="很多时候都要求能使用 Shell 脚本进行编程，本文是根据阮一峰大神的 系列教程 总结的基本知识。"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Bash脚本语法1","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xushun1221.github.io\/2020\/bash-script-grammer-1\/"},"image":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/cover.png","width":800,"height":600},"genre":"posts","keywords":"linux","wordcount":4269,"url":"https:\/\/xushun1221.github.io\/2020\/bash-script-grammer-1\/","datePublished":"2020-08-18T11:37:00\x2b08:00","dateModified":"2020-08-18T00:00:00\x2b00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xushun","logo":{"@type":"ImageObject","url":"https:\/\/xushun1221.github.io\/logo.png","width":127,"height":40}},"description":""}</script><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/css/lib/fontawesome-free/all.min.css></head><body><script>window.isDark=(window.localStorage&&window.localStorage.getItem('theme'))==='dark';window.isDark&&document.body.classList.add('dark-theme');</script><div class=wrapper><nav class=navbar><div class=top-scroll-bar></div><div class=navbar-container><div class="navbar-header animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=navbar-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><nav class=navbar-mobile><div class=top-scroll-bar></div><div class=navbar-container><div class=navbar-header><div class="navbar-header-title animated bounceIn"><a href=https://xushun1221.github.io>XuShun's Blog</a></div><div class=menu-toggle id=menu-toggle><span></span><span></span><span></span></div></div><div class=navbar-menu id=mobile-menu><a class=menu-item href=https://xushun1221.github.io/posts>Posts</a><a class=menu-item href=https://xushun1221.github.io/tags>Tags</a><a class=menu-item href=https://xushun1221.github.io/categories>Categories</a><a class=menu-item href=https://xushun1221.github.io/about>About</a><a href=javascript:void(0); class=theme-switch><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a></div></div></nav><main class=main><div class=container><article class=page><h1 class="post-title animated flipInX">Bash脚本语法1</h1><div class=post-meta><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2020-08-18>2020-08-18</time>&nbsp;
<i class="fas fa-pencil-alt fa-fw"></i>about 4269 words&nbsp;<span class=post-category><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href=https://xushun1221.github.io/categories/%E7%88%B1%E7%BC%96%E7%A8%8B%E7%88%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AD%A9%E5%AD%90/>爱编程爱技术的孩子</a>&nbsp;</span></div><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#1-shell-和-bash>1. Shell 和 Bash</a></li><li><a href=#2-预备知识>2. 预备知识</a></li><li><a href=#3-模式扩展>3. 模式扩展</a></li><li><a href=#4-变量>4. 变量</a><ul><li><a href=#41-创建变量>4.1 创建变量</a></li><li><a href=#42-读取变量>4.2 读取变量</a></li><li><a href=#43-删除变量>4.3 删除变量</a></li><li><a href=#44-输出变量>4.4 输出变量</a></li></ul></li><li><a href=#5-脚本>5. 脚本</a><ul><li><a href=#51-shebang行>5.1 Shebang行</a></li><li><a href=#52-执行权限和路径>5.2 执行权限和路径</a></li><li><a href=#53-脚本参数>5.3 脚本参数</a></li><li><a href=#54-命令执行>5.4 命令执行</a></li><li><a href=#55-别名>5.5 别名</a></li></ul></li><li><a href=#6-用户输入>6. 用户输入</a></li></ul></nav></div></div><div class=post-toc-mobile id=post-toc-mobile><details><summary><div class=post-toc-title><span>Contents</span>
<span><i class="details icon fas fa-angle-down"></i></span></div></summary><div class=post-toc-content><nav id=TableOfContentsMobile><ul><li><a href=#1-shell-和-bash>1. Shell 和 Bash</a></li><li><a href=#2-预备知识>2. 预备知识</a></li><li><a href=#3-模式扩展>3. 模式扩展</a></li><li><a href=#4-变量>4. 变量</a><ul><li><a href=#41-创建变量>4.1 创建变量</a></li><li><a href=#42-读取变量>4.2 读取变量</a></li><li><a href=#43-删除变量>4.3 删除变量</a></li><li><a href=#44-输出变量>4.4 输出变量</a></li></ul></li><li><a href=#5-脚本>5. 脚本</a><ul><li><a href=#51-shebang行>5.1 Shebang行</a></li><li><a href=#52-执行权限和路径>5.2 执行权限和路径</a></li><li><a href=#53-脚本参数>5.3 脚本参数</a></li><li><a href=#54-命令执行>5.4 命令执行</a></li><li><a href=#55-别名>5.5 别名</a></li></ul></li><li><a href=#6-用户输入>6. 用户输入</a></li></ul></nav></div></details></div><div class=post-content><p>很多时候都要求能使用 Shell 脚本进行编程，本文是根据阮一峰大神的 <a href=https://wangdoc.com/bash/intro.html target=_blank>系列教程</a> 总结的基本知识。</p><a class=post-dummy-target id=1-shell-和-bash></a><h2>1. Shell 和 Bash</h2><p>Shell 是一个程序，为用户提供和内核的交互界面，一般由用户从键盘输入命令，然后送给操作系统指向，执行完毕将结果返回给用户，因此又称为命令行环境。</p><p>只要能给用户提供命令行界面用于和内核交互，就叫 Shell，因此 Shell 有很多种，比如</p><ul><li>Bourne Shell（sh）</li><li>Bourne Again shell（bash）</li><li>C Shell（csh）</li></ul><p>Bash 是目前最常用的 Shell，一般也是默认的 Shell。</p><p>具有图形界面的 Linux 打开的命令行一般是终端模拟器，顾名思义，就是模拟命令行环境的，不是真正的命令行，但使用和直接使用非图形界面的命令行没有区别。因此我们随后不区分终端和命令行，全部使用命令行这个称呼。</p><p>图形界面下使用 <code>Ctrl + Alt + T</code> 打开命令行，默认位于用户主目录 <code>~</code>，提示符为美元符号 <code>$</code>，输入 <code>exit</code> 命令或使用快捷键 <code>Ctrl + D</code> 退出当前命令行。</p><a class=post-dummy-target id=2-预备知识></a><h2>2. 预备知识</h2><p>使用 <code>echo</code> 命令可以在屏幕上输入文本，添加引号可以输出多行文本，添加 <code>-e</code> 参数会解释引号中的特殊字符。该命令经常使用。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>echo</span> hello world
hello world

$ <span class=nb>echo</span> <span class=s2>&#34;hello
</span><span class=s2>world&#34;</span>
hello
world

$ <span class=nb>echo</span> -e <span class=s2>&#34;hello\nworld&#34;</span>
hello
world
</code></pre></td></tr></table></div></div><p>Bash 单个命令一般都是一行，按下回车开始执行，比较长的命令可以写成多行，只需要在每一行的末尾加上反斜杠即可</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>echo</span> foo <span class=se>\
</span><span class=se></span>bar
foo bar
</code></pre></td></tr></table></div></div><p><code>&&</code> 和 <code>||</code> 用于连接两个命令，前者的含义是如果第一个命令执行成功，执行第二个命令；后者的含义是如果第一个命令执行失败，执行第二个命令，第一个命令执行成功就不会执行第二个命令了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ mkdir foo <span class=o>&amp;&amp;</span> ls foo
$ mkdir foo <span class=o>||</span> mkdir bar
mkdir: 无法创建目录 “foo”: 文件已存在
$ ls 
foo bar
</code></pre></td></tr></table></div></div><p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。</p><p>还有一些实用的快捷键</p><ul><li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部。</li><li><code>Ctrl + C</code>：中止当前正在执行的命令。</li><li><code>Shift + PageUp</code>：向上滚动。</li><li><code>Shift + PageDown</code>：向下滚动。</li><li><code>Ctrl + U</code>：从光标位置删除到行首。</li><li><code>Ctrl + K</code>：从光标位置删除到行尾。</li><li><code>↑</code>，<code>↓</code>：浏览已执行命令的历史记录。</li><li><code>Tab</code>：补全未完全输入的命令或路径</li></ul><a class=post-dummy-target id=3-模式扩展></a><h2>3. 模式扩展</h2><p>用户输入的命令中有时包括一些特殊的字符，Shell 会先对这些字符进行替换，然后才开始执行，这个过程叫做模式扩展。Shell 提供 8 种模式扩展。</p><ol><li><p><code>~</code>：用户主目录</p></li><li><p><code>?</code>：单个字符，但不包括空字符</p></li><li><p><code>*</code>：任意数量的任意字符，包括 0 个</p></li><li><p><code>[...]</code>：匹配方括号中出现的任意字符，如果前面加了 <code>^</code> 或 <code>!</code> 表示匹配方括号中没有出现的字符</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=c1># 只存在文件 a.txt</span>
$ ls <span class=o>[</span>ab<span class=o>]</span>.txt
a.txt
   
<span class=c1># 存在 aaa、bbb、aba 三个文件</span>
$ ls ?<span class=o>[</span>!a<span class=o>]</span>?
aba bbb
</code></pre></td></tr></table></div></div><p><code>[start-end]</code>：匹配一个连续的范围，同样，实用 <code>!</code> 可以匹配不属于该范围的字符</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=c1># 存在文件 a.txt、b.txt 和 c.txt</span>
$ ls <span class=o>[</span>a-c<span class=o>]</span>.txt
a.txt
b.txt
c.txt
</code></pre></td></tr></table></div></div></li><li><p><code>{...}</code>：匹配大括号中的所有字符</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>echo</span> d<span class=o>{</span>a,e,i,u,o<span class=o>}</span>g
dag deg dig dug dog
</code></pre></td></tr></table></div></div><p><code>{start...end}</code>：扩展成一个连续序列</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>echo</span> <span class=o>{</span>1..4<span class=o>}</span>
<span class=m>1</span> <span class=m>2</span> <span class=m>3</span> <span class=m>4</span>
</code></pre></td></tr></table></div></div></li><li><p><code>$</code>：将 <code>$</code> 开头的变量替换为变量的值</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>echo</span> <span class=nv>$SHELL</span>
/bin/bash
</code></pre></td></tr></table></div></div></li><li><p><code>$(...)</code>：扩展成另一个命令的运行结果，该命令所有输出都作为返回值</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>echo</span> <span class=k>$(</span>date<span class=k>)</span>
Tue Jan <span class=m>28</span> 00:01:13 CST <span class=m>2020</span>
</code></pre></td></tr></table></div></div></li><li><p><code>$((...))</code>：扩展成整数运算的结果</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>echo</span> <span class=k>$((</span><span class=m>2</span> <span class=o>+</span> <span class=m>2</span><span class=k>))</span>
<span class=m>4</span>
</code></pre></td></tr></table></div></div></li></ol><p>模式扩展先于正则表达式出现，可以看作原始的正则表达式，但没有正则表达式灵活。</p><a class=post-dummy-target id=4-变量></a><h2>4. 变量</h2><p>用<code>env</code>命令显示所有环境变量，<code>echo</code>命令查看单个环境变量的值</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ env
$ <span class=nb>echo</span> <span class=nv>$PATH</span>
</code></pre></td></tr></table></div></div><p>BASH 的变量名区分大小写，由于环境变量一般使用全大写，用户自定义变量一般也使用全大写。</p><a class=post-dummy-target id=41-创建变量></a><h3>4.1 创建变量</h3><p>变量声明语法如下，等号两边不可有空格</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=nv>variable</span><span class=o>=</span>value
</code></pre></td></tr></table></div></div><p>如果变量的值中有空格，使用引号包围</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=nv>myvar</span><span class=o>=</span><span class=s2>&#34;hello world&#34;</span>
</code></pre></td></tr></table></div></div><p>BASH 没有数据类型的概念，所有变量都是字符串。</p><p>下面是一些自定义变量的例子。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=nv>a</span><span class=o>=</span>z                     <span class=c1># 变量 a 赋值为字符串 z</span>
<span class=nv>b</span><span class=o>=</span><span class=s2>&#34;a string&#34;</span>            <span class=c1># 变量值包含空格，就必须放在引号里面</span>
<span class=nv>c</span><span class=o>=</span><span class=s2>&#34;</span><span class=s2>a string and </span><span class=nv>$b</span><span class=s2>&#34;</span>     <span class=c1># 变量值可以引用其他变量的值</span>
<span class=nv>d</span><span class=o>=</span><span class=s2>&#34;\t\ta string\n&#34;</span>      <span class=c1># 变量值可以使用转义字符，echo 输出要加 -e 参数</span>
<span class=nv>e</span><span class=o>=</span><span class=k>$(</span>ls -l foo.txt<span class=k>)</span>      <span class=c1># 变量值可以是命令的执行结果</span>
<span class=nv>f</span><span class=o>=</span><span class=k>$((</span><span class=m>5</span> <span class=o>*</span> <span class=m>7</span><span class=k>))</span>            <span class=c1># 变量值可以是数学运算的结果</span>
</code></pre></td></tr></table></div></div><p>变量可以重复赋值，后面的赋值会覆盖前面的赋值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nv>foo</span><span class=o>=</span><span class=m>1</span>
$ <span class=nv>foo</span><span class=o>=</span><span class=m>2</span>
$ <span class=nb>echo</span> <span class=nv>$foo</span>
<span class=m>2</span>
</code></pre></td></tr></table></div></div><p>上面例子中，变量<code>foo</code>的第二次赋值会覆盖第一次赋值。</p><a class=post-dummy-target id=42-读取变量></a><h3>4.2 读取变量</h3><p>读取变量的时候，直接在变量名前加上<code>$</code>就可以了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nv>foo</span><span class=o>=</span>bar
$ <span class=nb>echo</span> <span class=nv>$foo</span>
bar
</code></pre></td></tr></table></div></div><p>如果变量不存在，Bash 不会报错，而会输出空字符。</p><p>读取变量的时候，变量名也可以使用花括号<code>{}</code>包围，比如<code>$a</code>也可以写成<code>${a}</code>。这种写法可以用于变量名与其他字符连用的情况。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nv>a</span><span class=o>=</span>foo
$ <span class=nb>echo</span> <span class=nv>$a_file</span>

$ <span class=nb>echo</span> <span class=si>${</span><span class=nv>a</span><span class=si>}</span>_file
foo_file
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=43-删除变量></a><h3>4.3 删除变量</h3><p><code>unset</code>命令用来删除一个变量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=nb>unset</span> NAME
</code></pre></td></tr></table></div></div><p>这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使<code>unset</code>命令删除了变量，还是可以读取这个变量，值为空字符串。</p><p>所以，删除一个变量，也可以将这个变量设成空字符串。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nv>foo</span><span class=o>=</span><span class=s1>&#39;&#39;</span>
$ <span class=nv>foo</span><span class=o>=</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=44-输出变量></a><h3>4.4 输出变量</h3><p>用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用<code>export</code>命令。这样输出的变量，对于子 Shell 来说就是环境变量。</p><p><code>export</code>命令用来向子 Shell 输出变量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=nv>NAME</span><span class=o>=</span>foo
<span class=nb>export</span> NAME
</code></pre></td></tr></table></div></div><p>上面命令输出了变量<code>NAME</code>。变量的赋值和输出也可以在一个步骤中完成。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=nb>export</span> <span class=nv>NAME</span><span class=o>=</span>value
</code></pre></td></tr></table></div></div><p>上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量<code>$NAME</code>。</p><p>子 Shell 如果修改继承的变量，不会影响父 Shell。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=c1># 输出变量 $foo</span>
$ <span class=nb>export</span> <span class=nv>foo</span><span class=o>=</span>bar

<span class=c1># 新建子 Shell</span>
$ bash

<span class=c1># 读取 $foo</span>
$ <span class=nb>echo</span> <span class=nv>$foo</span>
bar

<span class=c1># 修改继承的变量</span>
$ <span class=nv>foo</span><span class=o>=</span>baz

<span class=c1># 退出子 Shell</span>
$ <span class=nb>exit</span>

<span class=c1># 读取 $foo</span>
$ <span class=nb>echo</span> <span class=nv>$foo</span>
bar
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=5-脚本></a><h2>5. 脚本</h2><p>脚本（script）就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。</p><p>Bash 脚本使用 <code>#</code> 声明注释</p><a class=post-dummy-target id=51-shebang行></a><h3>5.1 Shebang行</h3><p>脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以<code>#!</code>字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。</p><p><code>#!</code>后面就是脚本解释器的位置，Bash 脚本的解释器一般是<code>/bin/sh</code>或<code>/bin/bash</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/bin/sh
</span><span class=cp></span><span class=c1># 或者</span>
<span class=c1>#!/bin/bash</span>
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=52-执行权限和路径></a><h3>5.2 执行权限和路径</h3><p>指定了 Shebang 行的脚本，需要赋予执行权限才可以直接执行。</p><p>权限的设定有两种格式，一种是字母格式，（r, w, x）分别表示读、写、执行，（u, g, o）分别表示脚本所有者、同组用户、其它用户，（+, -, =）分别表示增加权限、取消权限和设置唯一权限。所有的权限设定命令都是这些参数的组合，举例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=c1># 给所有用户执行权限</span>
$ chmod +x script.sh

<span class=c1># 只给脚本拥有者读权限和执行权限</span>
$ chmod u+rx script.sh
</code></pre></td></tr></table></div></div><p>权限还可以以数字方式设定，我们令 r=4, w=2, x=1，权限的组合就是这些操作权重的组合，权限授予的用户就是数字的位置，举例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=c1># 给脚本所有者全部权限，给同组和其它用户读权限和执行权限</span>
$ chmod <span class=m>755</span> script.sh
</code></pre></td></tr></table></div></div><a class=post-dummy-target id=53-脚本参数></a><h3>5.3 脚本参数</h3><p>调用脚本的时候，脚本文件名后面可以带有参数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>$ script.sh word1 word2 word3
</code></pre></td></tr></table></div></div><p>脚本文件内部，可以使用特殊变量，引用这些参数。</p><ul><li><code>$0</code>：脚本文件名，即<code>script.sh</code>。</li><li><code>$1</code>~<code>$9</code>：对应脚本的第一个参数到第九个参数。</li><li><code>$#</code>：参数的总数。</li><li><code>$@</code>：全部的参数，参数之间使用空格分隔。</li><li><code>$*</code>：全部的参数，参数之间使用变量<code>$IFS</code>值的第一个字符分隔，默认为空格，但是可以自定义。</li></ul><p>如果脚本的参数多于9个，那么第10个参数可以用<code>${10}</code>的形式引用，以此类推。</p><p>用户可以输入任意数量的参数，利用<code>for</code>循环，可以读取每一个参数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/bin/bash
</span><span class=cp></span>
<span class=k>for</span> i in <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span><span class=p>;</span> <span class=k>do</span>
  <span class=nb>echo</span> <span class=nv>$i</span>
<span class=k>done</span>
</code></pre></td></tr></table></div></div><p>注1，如果命令是<code>command -o foo bar</code>，那么<code>-o</code>是<code>$1</code>，<code>foo</code>是<code>$2</code>，<code>bar</code>是<code>$3</code>。</p><p>注2，如果命令是<code>./script.sh "a b"</code>，即多个参数放在双引号里面，视为一个参数。</p><a class=post-dummy-target id=54-命令执行></a><h3>5.4 命令执行</h3><p><code>exit</code>命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>exit</span>
</code></pre></td></tr></table></div></div><p>上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。</p><p><code>exit</code>命令后面可以跟参数，该参数就是退出状态。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=c1># 退出值为0（成功）</span>
$ <span class=nb>exit</span> <span class=m>0</span>

<span class=c1># 退出值为1（失败）</span>
$ <span class=nb>exit</span> <span class=m>1</span>
</code></pre></td></tr></table></div></div><p>可以使用 <code>$?</code> 判断上一条命令的执行结果控制脚本的执行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=nb>cd</span> <span class=nv>$some_directory</span>
<span class=k>if</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=nv>$?</span><span class=s2>&#34;</span> <span class=o>=</span> <span class=s2>&#34;0&#34;</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
  rm *
<span class=k>else</span>
  <span class=nb>echo</span> <span class=s2>&#34;无法切换目录！&#34;</span> 1&gt;<span class=p>&amp;</span><span class=m>2</span>
  <span class=nb>exit</span> <span class=m>1</span>
<span class=k>fi</span>
</code></pre></td></tr></table></div></div><p>使用 <code>if</code> 命令可以直接判断</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=k>if</span> <span class=nb>cd</span> <span class=nv>$some_directory</span><span class=p>;</span> <span class=k>then</span>
  rm *
<span class=k>else</span>
  <span class=nb>echo</span> <span class=s2>&#34;Could not change directory! Aborting.&#34;</span> 1&gt;<span class=p>&amp;</span><span class=m>2</span>
  <span class=nb>exit</span> <span class=m>1</span>
<span class=k>fi</span>
</code></pre></td></tr></table></div></div><p>最简便的方法是使用逻辑连接符</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=c1># 第一步执行成功，才会执行第二步</span>
<span class=nb>cd</span> <span class=nv>$some_directory</span> <span class=o>&amp;&amp;</span> rm *

<span class=c1># 第一步执行失败，才会执行第二步</span>
<span class=nb>cd</span> <span class=nv>$some_directory</span> <span class=o>||</span> <span class=nb>exit</span> <span class=m>1</span>
</code></pre></td></tr></table></div></div><p><code>source</code>命令用于执行一个脚本，通常用于重新加载一个配置文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>source</span> .bashrc
</code></pre></td></tr></table></div></div><p><code>source</code>命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，<code>source</code>命令执行脚本时，不需要<code>export</code>变量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/bin/bash
</span><span class=cp></span><span class=c1># test.sh</span>
<span class=nb>echo</span> <span class=nv>$foo</span>
</code></pre></td></tr></table></div></div><p><code>source</code>有一个简写形式，可以使用一个点（<code>.</code>）来表示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ . script.sh
</code></pre></td></tr></table></div></div><p>注意，要区分 <code>. script.sh</code> 和 <code>./script.sh</code></p><a class=post-dummy-target id=55-别名></a><h3>5.5 别名</h3><p><code>alias</code>命令用来为一个命令指定别名，这样更便于记忆。下面是<code>alias</code>的格式。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=nb>alias</span> <span class=nv>NAME</span><span class=o>=</span>DEFINITION
</code></pre></td></tr></table></div></div><p>上面命令中，<code>NAME</code>是别名的名称，<code>DEFINITION</code>是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。</p><p>一个常见的例子是为<code>grep</code>命令起一个<code>search</code>的别名。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=nb>alias</span> <span class=nv>search</span><span class=o>=</span>grep
</code></pre></td></tr></table></div></div><p><code>alias</code>也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个<code>today</code>的命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>alias</span> <span class=nv>today</span><span class=o>=</span><span class=s1>&#39;date +&#34;%A, %B %-d, %Y&#34;&#39;</span>
$ today
星期一, 一月 6, <span class=m>2020</span>
</code></pre></td></tr></table></div></div><p>有时为了防止误删除文件，可以指定<code>rm</code>命令的别名。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ <span class=nb>alias</span> <span class=nv>rm</span><span class=o>=</span><span class=s1>&#39;rm -i&#39;</span>
</code></pre></td></tr></table></div></div><p>上面命令指定<code>rm</code>命令是<code>rm -i</code>，每次删除文件之前，都会让用户确认。</p><a class=post-dummy-target id=6-用户输入></a><h2>6. 用户输入</h2><p>有时，脚本需要在执行过程中，由用户提供一部分数据，这时可以使用<code>read</code>命令。它将用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。</p><p><code>read</code>命令的格式如下。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=nb>read</span> <span class=o>[</span>-options<span class=o>]</span> <span class=o>[</span>variable...<span class=o>]</span>
</code></pre></td></tr></table></div></div><p>上面语法中，<code>options</code>是参数选项，<code>variable</code>是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量<code>REPLY</code>会包含用户输入的一整行数据。</p><p>下面是一个例子<code>demo.sh</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/bin/bash
</span><span class=cp></span>
<span class=nb>echo</span> -n <span class=s2>&#34;输入一些文本 &gt; &#34;</span>
<span class=nb>read</span> text
<span class=nb>echo</span> <span class=s2>&#34;</span><span class=s2>你的输入：</span><span class=nv>$text</span><span class=s2>&#34;</span>
</code></pre></td></tr></table></div></div><p>上面例子中，先显示一行提示文本，然后会等待用户输入文本。用户输入的文本，存入变量<code>text</code>，在下一行显示出来。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ bash demo.sh
输入一些文本 &gt; 你好，世界
你的输入：你好，世界
</code></pre></td></tr></table></div></div><p><code>read</code>可以接受用户输入的多个值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/bin/bash
</span><span class=cp></span><span class=nb>echo</span> Please, enter your firstname and lastname
<span class=nb>read</span> FN LN
<span class=nb>echo</span> <span class=s2>&#34;</span><span class=s2>Hi! </span><span class=nv>$LN</span><span class=s2>, </span><span class=nv>$FN</span><span class=s2> !</span><span class=s2>&#34;</span>
</code></pre></td></tr></table></div></div><p>上面例子中，<code>read</code>根据用户的输入，同时为两个变量赋值。</p><p>如果用户的输入项少于<code>read</code>命令给出的变量数目，那么额外的变量值为空。如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。</p><p>如果<code>read</code>命令之后没有定义变量名，那么环境变量<code>REPLY</code>会包含所有的输入。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/bin/bash
</span><span class=cp></span><span class=c1># read-single: read multiple values into default variable</span>
<span class=nb>echo</span> -n <span class=s2>&#34;Enter one or more values &gt; &#34;</span>
<span class=nb>read</span>
<span class=nb>echo</span> <span class=s2>&#34;</span><span class=s2>REPLY = &#39;</span><span class=nv>$REPLY</span><span class=s2>&#39;</span><span class=s2>&#34;</span>
</code></pre></td></tr></table></div></div><p>上面脚本的运行结果如下。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>$ read-single
Enter one or more values &gt; a b c d
<span class=nv>REPLY</span> <span class=o>=</span> <span class=s1>&#39;a b c d&#39;</span>
</code></pre></td></tr></table></div></div></div><div class=post-copyright id=post-footer><p class=copyright-item><span>Author:&nbsp;</span>
<span>xushun</span></p><p class=copyright-item><span>Updated on:&nbsp;</span>
<span>2020-08-18</span></p><p class=copyright-item><span>Share on:&nbsp;</span>
<span><a href="//twitter.com/share?url=https%3a%2f%2fxushun1221.github.io%2f2020%2fbash-script-grammer-1%2f&text=Bash%e8%84%9a%e6%9c%ac%e8%af%ad%e6%b3%951&via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-fw"></i></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fxushun1221.github.io%2f2020%2fbash-script-grammer-1%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook-square fa-fw"></i></a><a href="//reddit.com/submit?url=https%3a%2f%2fxushun1221.github.io%2f2020%2fbash-script-grammer-1%2f&title=Bash%e8%84%9a%e6%9c%ac%e8%af%ad%e6%b3%951" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-fw"></i></a></span></p><p class=copyright-item></p><p class=copyright-item></p></div><br><div class=post-info-more><section><span class=tag><a href=https://xushun1221.github.io/tags/linux/><i class="fas fa-tag fa-fw"></i>&nbsp;linux</a>&nbsp;</span></section><section><span><a href=javascript:window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=https://xushun1221.github.io>Home</a></span></section></div><div class=post-nav><a href=https://xushun1221.github.io/2020/operate-system-6-file-management/ class=prev rel=prev title=操作系统6-文件管理><i class="fas fa-angle-left fa-fw"></i>操作系统6-文件管理</a>
<a href=https://xushun1221.github.io/2020/http-method/ class=next rel=next title=计算机网络-HTTP方法>计算机网络-HTTP方法<i class="fas fa-angle-right fa-fw"></i></a></div><div class=post-comment></div></article></div></main><footer class=footer><div class=copyright><div class=copyright-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xushun1221.github.io/about/ target=_blank>xushun</a> | </span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreffer">Hugo</a> & <a href=https://github.com/dillonzq/LoveIt target=_blank rel="external nofollow noopener noreffer">LoveIt</a></div></div></footer></div><a href=# class=dynamic-to-top id=dynamic-to-top data-scroll><span>&nbsp;</span>
</a><script src=/js/lib/jquery/jquery.slim.min.js></script><script src=/js/lib/lazysizes/lazysizes.min.js></script><script src=/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js></script><script>window.scroll=new SmoothScroll('[data-scroll]',{speed:300,speedAsDuration:true});</script><link rel=stylesheet href=/css/lib/katex/katex.min.css><script src=/js/lib/katex/katex.min.js></script><script defer src=/js/lib/katex/auto-render.min.js></script><link rel=stylesheet href=/css/lib/katex/copy-tex.min.css><script defer src=/js/lib/katex/copy-tex.min.js></script><script defer src=/js/lib/katex/mhchem.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:true},{left:"\\(",right:"\\)",display:false},{left:"\\[",right:"\\]",display:true},{left:"$",right:"$",display:false},]});});</script><script src=/js/blog.min.js></script></body></html>