<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on XuShun's Blog</title><link>https://xushun1221.github.io/posts/</link><description>Recent content in Posts on XuShun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 10 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://xushun1221.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>【MySQL】22 - MVCC和undo log</title><link>https://xushun1221.github.io/2022/mysql22-mvcc%E5%92%8Cundo-log/</link><pubDate>Thu, 10 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql22-mvcc%E5%92%8Cundo-log/</guid><description>已提交读和可重复读的实现原理 之前几篇已经分析了未提交读和串行化的实现原理，未提交读相当于没有做任何的并发控制，串行化完全使用共享锁、排他锁、</description></item><item><title>【MySQL】21 - InnoDB间隙锁：解决幻读</title><link>https://xushun1221.github.io/2022/mysql21-innodb%E9%97%B4%E9%9A%99%E9%94%81%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB/</link><pubDate>Wed, 09 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql21-innodb%E9%97%B4%E9%9A%99%E9%94%81%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB/</guid><description>串行化隔离级别下，如何解决虚读（幻读）问题？ 答：间隙锁（gap lock）！ 本章内容是，串行化隔离级别的实现原理，即间隙锁解决幻读问题。 幻读问</description></item><item><title>【MySQL】18 - MySQL事务</title><link>https://xushun1221.github.io/2022/mysql18-mysql%E4%BA%8B%E5%8A%A1/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql18-mysql%E4%BA%8B%E5%8A%A1/</guid><description>事务的核心概念 一个事务是由一条或者多条对数据库操作的SQL语句所组成的一个不可分割的单元（原子性），只有当事务中的所有操作都正常执行完了，整</description></item><item><title>【MySQL】19 - 事务并发问题&amp;隔离级别</title><link>https://xushun1221.github.io/2022/mysql19-%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql19-%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid><description>事务并发存在的问题 事务处理不经隔离，并发执行事务时通常会发生以下的问题： 脏读（Dirty Read）：一个事务读取了另一个事务未提交的数据。例</description></item><item><title>【MySQL】20 - 表级锁、行级锁、排他锁、共享锁</title><link>https://xushun1221.github.io/2022/mysql20-%E8%A1%A8%E7%BA%A7%E9%94%81%E8%A1%8C%E7%BA%A7%E9%94%81%E6%8E%92%E4%BB%96%E9%94%81%E5%85%B1%E4%BA%AB%E9%94%81/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql20-%E8%A1%A8%E7%BA%A7%E9%94%81%E8%A1%8C%E7%BA%A7%E9%94%81%E6%8E%92%E4%BB%96%E9%94%81%E5%85%B1%E4%BA%AB%E9%94%81/</guid><description>表级锁、行级锁（粒度） 表级锁：对整张表加锁。开销小，加锁快，不会出现死锁；锁粒度大，发生锁冲突的概率高，并发度低； 行级锁：对某行记录加锁。开</description></item><item><title>【MySQL】17 - sql和索引优化：慢查询日志</title><link>https://xushun1221.github.io/2022/mysql17-sql%E5%92%8C%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</link><pubDate>Mon, 07 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql17-sql%E5%92%8C%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</guid><description>如何发现和分析sql和索引优化问题呢？ 第一，可以用EXPLAIN语句分析一下需要优化的sql，能看出一些问题，比如是不是没有加索引、索引有没</description></item><item><title>【MySQL】14 - MyISAM主键和二级索引树</title><link>https://xushun1221.github.io/2022/mysql14-myisam%E4%B8%BB%E9%94%AE%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E6%A0%91/</link><pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql14-myisam%E4%B8%BB%E9%94%AE%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E6%A0%91/</guid><description>MyISAM存储引擎采用B+索引树，数据和索引存储在两个文件中（.MYD .MYI）。 MyISAM 主键索引 和InnoDB不同的是，MyISAM主键索引树</description></item><item><title>【MySQL】15 - 哈希索引</title><link>https://xushun1221.github.io/2022/mysql15-%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/</link><pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql15-%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/</guid><description>哈希索引 用于搜索的数据结构常见的就是，平衡树和哈希表。存储引擎也是，InnoDB和MyISAM引擎支持B+树索引，而MEMORY引擎（基于内</description></item><item><title>【MySQL】16 - InnoDB自适应哈希索引</title><link>https://xushun1221.github.io/2022/mysql16-innodb%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/</link><pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql16-innodb%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/</guid><description>自适应哈希索引 - 提高二级索引查询性能 InnoDB中，使用二级索引树进行查询时，如果查询字段在二级索引树上，就直接完成搜索，否则需要根据搜索到</description></item><item><title>【MySQL】12 - B树索引：索引的底层原理</title><link>https://xushun1221.github.io/2022/mysql12-b%E6%A0%91%E7%B4%A2%E5%BC%95%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 05 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql12-b%E6%A0%91%E7%B4%A2%E5%BC%95%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</guid><description>MySQL索引的实现原理 MySQL支持两种索引，一种是B-树索引，一种是哈希索引，大家知道，B-树和哈希表在数据查询时的效率是非常高的。 这里</description></item><item><title>【MySQL】13 - InnoDB主键和二级索引树</title><link>https://xushun1221.github.io/2022/mysql13-innodb%E4%B8%BB%E9%94%AE%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E6%A0%91/</link><pubDate>Sat, 05 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql13-innodb%E4%B8%BB%E9%94%AE%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E6%A0%91/</guid><description>InnoDB存储引擎采用B+索引树，数据和索引存储在同一个文件中（.ibd）。 InnoDB 主键索引 InnoDB的主键索引树，非叶子节点存储索引key，</description></item><item><title>【MySQL】10 - 存储引擎</title><link>https://xushun1221.github.io/2022/mysql10-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link><pubDate>Fri, 04 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql10-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid><description>MySQL 存储引擎 表的结构、数据、索引的存储方式，由存储引擎直接决定。 MySQL的一个特点就是，支持插件式的存储引擎，可以更换不同的存储引擎。 查看m</description></item><item><title>【MySQL】11 - 索引</title><link>https://xushun1221.github.io/2022/mysql11-%E7%B4%A2%E5%BC%95/</link><pubDate>Fri, 04 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql11-%E7%B4%A2%E5%BC%95/</guid><description>MySQL 索引 当表中的数据量到达几十万甚至上百万的时候，SQL查询所花费的时间会很长，导致业务超时出错，此时就需要用索引来加速SQL查询。 索引解决的</description></item><item><title>【MySQL】09 - 连接查询详解</title><link>https://xushun1221.github.io/2022/mysql09-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E8%AF%A6%E8%A7%A3/</link><pubDate>Wed, 02 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql09-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E8%AF%A6%E8%A7%A3/</guid><description>连接查询 连接查询就是在一次sql查询中查询多张相关联的表。 为什么不使用多个sql进行查询？因为效率低，当mysql client每次发送sql</description></item><item><title>【算法】背包问题总结</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid><description>0-1背包 经典题目：2. 01背包问题 相关题目： LeetCode.416 LeetCode.1049 LeetCode.494 LeetCode.474 解法1：二维dp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35</description></item><item><title>【MySQL】07 - LIMIT分页查询</title><link>https://xushun1221.github.io/2022/mysql07-limit%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</link><pubDate>Mon, 17 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql07-limit%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</guid><description>分页查询 分页查询的基础语法： SELECT * FROM user LIMIT 2;，user表中的前两行 SELECT * FROM user LIMIT 1,3;，从user表中第1行开始取三行 SELECT * FROM user LIMIT 3 OFFSET 1;，同上 查</description></item><item><title>【MySQL】08 - 初识排序和分组 ORDER、GROUP BY</title><link>https://xushun1221.github.io/2022/mysql08-%E5%88%9D%E8%AF%86%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E7%BB%84-ordergroup-by/</link><pubDate>Mon, 17 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql08-%E5%88%9D%E8%AF%86%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E7%BB%84-ordergroup-by/</guid><description>ORDER BY 排序 使用方法： SELECT * FROM user ORDER BY name ASC;，升序 SELECT * FROM user ORDER BY age DESC;，降序 SELECT * FROM user ORDER BY name,age,sex;，多个排序字段，前面的相同</description></item><item><title>【MySQL】06 - 单表查询常用操作</title><link>https://xushun1221.github.io/2022/mysql06-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link><pubDate>Fri, 14 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql06-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid><description>常见的一些单表查询的操作 带IN子查询 [NOT]IN(元素1,元素2,...) SELECT * FROM user WHERE id IN(1,2,3,4,5,6,7); SELECT * FROM user WHERE id NOT IN(1,2,3,4,5,6,7); 括号中的列表也可以是另一个sql语</description></item><item><title>【MySQL】04 - 范式设计</title><link>https://xushun1221.github.io/2022/mysql04-%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/</link><pubDate>Thu, 13 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql04-%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/</guid><description>关系型数据库范式设计 范式设计使用简洁的表述，描述了在数据库设计时需要遵循的一些原则。 使用数据库范式可以带来许多好处，最重要的有三点： 减少数据</description></item><item><title>【MySQL】05 - 基础CRUD操作</title><link>https://xushun1221.github.io/2022/mysql05-%E5%9F%BA%E7%A1%80crud%E6%93%8D%E4%BD%9C/</link><pubDate>Thu, 13 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql05-%E5%9F%BA%E7%A1%80crud%E6%93%8D%E4%BD%9C/</guid><description>结构化查询语句 SQL SQL是结构化查询语言（Structure Query Language），它是关系型数据库的通用语言。 SQL主要可以划分为以下3个类别</description></item><item><title>【MySQL】02 - 数据类型、运算符、完整性约束</title><link>https://xushun1221.github.io/2022/mysql02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/</link><pubDate>Wed, 12 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/</guid><description>数据类型 MySQL数据类型定义了数据的大小范围，因此使用时选择合适的类型，不仅会降低表占用的磁盘空间，间接减少了磁盘I/O的次数，提高了表的</description></item><item><title>【MySQL】03 - 表设计原则</title><link>https://xushun1221.github.io/2022/mysql03-%E8%A1%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link><pubDate>Wed, 12 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql03-%E8%A1%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid><description>关系型数据库表设计 项目需求分析完成后，需要对库表进行设计，定义库表的结构：有哪些实体需要抽象成表、表中都有哪些字段、每个字段用什么类型、表与</description></item><item><title>CentOS7使用Clash方法</title><link>https://xushun1221.github.io/2022/centos7%E4%BD%BF%E7%94%A8clash%E6%96%B9%E6%B3%95/</link><pubDate>Tue, 11 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/centos7%E4%BD%BF%E7%94%A8clash%E6%96%B9%E6%B3%95/</guid><description>安装使用步骤 用户目录下创建clash文件夹 clash-releases下载Clash的二进制文件到~/clash文件夹，下载这个就行clas</description></item><item><title>【MySQL】01 - 安装配置</title><link>https://xushun1221.github.io/2022/mysql01-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</link><pubDate>Tue, 11 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/mysql01-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</guid><description>使用MySQL5.7 安装CentOS7 之前一直用Ubuntu，这次用CentOS试试。 下载好镜像文件CentOS-7-x86_64-DVD-</description></item><item><title>【重写muduo】22 - 总结</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo22-%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 06 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo22-%E6%80%BB%E7%BB%93/</guid><description>muduo库的核心部分终于重写完了，我们来总结一下各个核心组件的功能和联系。 Channel Channel是对sockfd和其感兴趣的事件以及对应的回调函</description></item><item><title>【重写muduo】21 - 编译安装脚本&amp;测试代码</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo21-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</link><pubDate>Sun, 02 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo21-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</guid><description>编译安装脚本 我们的项目使用cmake管理，需要编译为一个.so动态库，动态库安装到系统/usr/lib目录下，头文件拷贝到/usr/incl</description></item><item><title>【重写muduo】20 - TcpServer终章</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo20-tcpserver%E7%BB%88%E7%AB%A0/</link><pubDate>Fri, 30 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo20-tcpserver%E7%BB%88%E7%AB%A0/</guid><description>写完TcpConnection之后，我们就可以来实现TcpServer的完整版本了。 TcpConnection主要做的事情就是，处理新到来的</description></item><item><title>【重写muduo】18 - Buffer缓冲区</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo18-buffer%E7%BC%93%E5%86%B2%E5%8C%BA/</link><pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo18-buffer%E7%BC%93%E5%86%B2%E5%8C%BA/</guid><description>在实现TcpConnection之前，需要实现底层的缓冲区Buffer，具体的实现细节在注释里非常详细的说明了。不再赘述。 源码 Buffer.hh 1 2 3 4 5 6</description></item><item><title>【重写muduo】19 - TcpConnection</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo19-tcpconnection/</link><pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo19-tcpconnection/</guid><description>TcpConnection管理一个socket及其对应的channel、tcp连接状态、一对输入输出缓冲区、设置channel的各种回调函数</description></item><item><title>【重写muduo】15 - Socket类</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo15-socket%E7%B1%BB/</link><pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo15-socket%E7%B1%BB/</guid><description>Socket类封装了网络套接字相关的文件描述符和相关方法。 源码 Socket.hh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #ifndef __SOCKET_HH_#define __SOCKET_HH_ #include &amp;#34;noncopyable.hh&amp;#34; class InetAddress;</description></item><item><title>【重写muduo】16 - Acceptor</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo16-acceptor/</link><pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo16-acceptor/</guid><description>对listenfd和accept函数的封装。 Acceptor运行在mainloop中，负责接收新用户的连接。 源码 Acceptor.hh 1 2 3 4 5 6 7 8 9 10 11 12 13</description></item><item><title>【重写muduo】17 - TcpServer服务器类</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo17-tcpserver%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B1%BB/</link><pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo17-tcpserver%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B1%BB/</guid><description>到这里，muduo中和TcpServer相关的组件基本都写好了，我们先把TcpServer写个大概。 因为TcpConnection的内容还没</description></item><item><title>【重写muduo】12 - Thread</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo12-thread/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo12-thread/</guid><description>muduo库中使用了POSIX线程库，而我们使用c++11标准的线程库对线程类Thread进行封装。 源码 Thread.hh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</description></item><item><title>【重写muduo】13 - EventLoopThread</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo13-eventloopthread/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo13-eventloopthread/</guid><description>上一篇我们封装了Thread类，EventLoopThread类将一个EventLoop和一个Thread封装在一起，实现一个线程运行一个事</description></item><item><title>【重写muduo】14 - EventLoopThreadPool池</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo14-eventloopthreadpool%E6%B1%A0/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo14-eventloopthreadpool%E6%B1%A0/</guid><description>muduo中除了用于处理新用户连接的主事件循环mainloop(baseloop)外，还有进行已连接用户读写事件操作的subloop，用户可</description></item><item><title>【重写muduo】11 - EventLoop事件循环</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo11-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link><pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo11-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid><description>EventLoop事件循环类，主要是封装Poller、回调函数执行逻辑、mainloop和subloop之间的通信方法。 mainloop 与 subloop 通信方式 mud</description></item><item><title>【重写muduo】10 - CurrentThread</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo10-currentthread/</link><pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo10-currentthread/</guid><description>获得线程的唯一标识 muduo库使用的模型是：one loop per thread，每个EventLoop都是在一个单独的线程中运行的，需要控制一些和线程相</description></item><item><title>【重写muduo】08 - Poller抽象类</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo08-poller%E6%8A%BD%E8%B1%A1%E7%B1%BB/</link><pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo08-poller%E6%8A%BD%E8%B1%A1%E7%B1%BB/</guid><description>muduo中，使用Poller抽象类来抽象不同的IO复用方法，muduo支持poll和epoll两种IO复用。 在Poller实现中，我们使用</description></item><item><title>【重写muduo】09 - EPollPoller事件分发器</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo09-epollpoller%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%99%A8/</link><pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo09-epollpoller%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%99%A8/</guid><description>通过继承Poller抽象类来实现对epoll多路复用的的封装。 分析几个关键成员变量： Poller::ChannelMap Poller::channels_：用于存储所有注册到</description></item><item><title>【重写muduo】07 - Channel通道</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo07-channel%E9%80%9A%E9%81%93/</link><pubDate>Sat, 17 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo07-channel%E9%80%9A%E9%81%93/</guid><description>muduo库里面，TcpServer的事件循环EventLoop中，主要包含两大模块，一个是Channel列表，另一个是Poller。 Cha</description></item><item><title>【重写muduo】06 - InetAddress地址类</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo06-inetaddress%E5%9C%B0%E5%9D%80%E7%B1%BB/</link><pubDate>Fri, 16 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo06-inetaddress%E5%9C%B0%E5%9D%80%E7%B1%BB/</guid><description>这里没什么好写的，就是把sockaddr_in以及相关的函数进行封装，我们仅支持ipv4。 源码 InetAddress.hh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22</description></item><item><title>【重写muduo】04 - Logger日志系统</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo04-logger%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link><pubDate>Thu, 15 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo04-logger%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid><description>日志系统，我们使用和muduo库不同的实现，日志直接输出到控制台。 单例模式 我们使用单例模式来实现Logger类。 使用static Logger&amp;amp; insta</description></item><item><title>【重写muduo】05 - Timestamp时间戳</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo05-timestamp%E6%97%B6%E9%97%B4%E6%88%B3/</link><pubDate>Thu, 15 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo05-timestamp%E6%97%B6%E9%97%B4%E6%88%B3/</guid><description>时间戳类，我们只实现时间戳的核心功能，返回当前时间戳以及时间戳转格式化字符串。 使用c++11标准的chrono库来获取微秒级时间戳，使用c库</description></item><item><title>C++中的默认继承方式</title><link>https://xushun1221.github.io/2022/c-%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</guid><description>C++中的默认继承方式有两种情况。（与基类是class还是struct无关） 派生类是class的情况下，默认继承基类的方式是private；</description></item><item><title>【重写muduo】02 - CMake构建项目</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo02-cmake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo02-cmake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/</guid><description>在~/mymuduo/下构建该项目，使用CMake来编译生成项目。 CMakeLists.txt文件内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 cmake_minimum_required(VERSION 2.5)project(mymuduo)# my</description></item><item><title>【重写muduo】03 - noncopyable接口类</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo03-noncopyable%E6%8E%A5%E5%8F%A3%E7%B1%BB/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo03-noncopyable%E6%8E%A5%E5%8F%A3%E7%B1%BB/</guid><description>理解源码 在原muduo库中(noncopyable.h)有这样一个类： 1 2 3 4 5 6 7 8 9 10 class noncopyable { public: noncopyable(const noncopyable&amp;amp;) = delete; void operator=(const noncopyable&amp;amp;) = delete; protected: noncopyable() = default; ~noncopyable() = default; }; 这个类的</description></item><item><title>【C++高级】03 - 绑定器、函数对象、lambda</title><link>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A703-%E7%BB%91%E5%AE%9A%E5%99%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1lambda/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A703-%E7%BB%91%E5%AE%9A%E5%99%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1lambda/</guid><description>绑定器和函数对象都是c++11从boost库中引入的机制。 bind1st bind2nd 绑定器 在c++ STL中提供了两个绑定器： bind1st：将operator()</description></item><item><title>【C++高级】04 - c++11总结和c++多线程</title><link>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A704-c-11%E6%80%BB%E7%BB%93%E5%92%8Cc-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A704-c-11%E6%80%BB%E7%BB%93%E5%92%8Cc-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>c++11标准内容总结 关键字和语法 auto：可以根据右值推导出右值的类型，确定左边变量的类型； nullptr：原来使用的#define NULL 0是</description></item><item><title>【C++高级】02 - 智能指针</title><link>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A702-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A702-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid><description>智能指针介绍 裸指针，很强大，但是在使用时有很多的坑： 忘记释放资源，导致资源泄露； 同一资源释放多次，释放野指针，导致程序崩溃； 虽然编写了释放资</description></item><item><title>【C++高级】01 - 对象优化&amp;右值引用优化</title><link>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A701-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96/</link><pubDate>Thu, 08 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A701-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96/</guid><description>对象使用中调用了哪些函数？（构造、析构、拷贝、赋值） 对象函数调用过程 - 示例1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32</description></item><item><title>【重写muduo】01 - 安装和使用 muduo</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo01-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-muduo/</link><pubDate>Wed, 07 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo01-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-muduo/</guid><description>安装 muduo 先把muduo和boost的源码下载下来（muduo需要依赖boost）。 boost 源码库编译安装 先解压： 1 2 3 4 5 6 7 xushun@xushun-virtual-machine:~/Downloads$ tar -zxvf boost_1_69_0.tar.gz ... xushun@xushun-virtual-machine:~/Downloads$ cd boost_1_69_0/ xushun@xushun-virtual-machine:~/Downloads/boost_1_69_0$ ls boost</description></item><item><title>【C++基础】08 - STL组件</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8008-stl%E7%BB%84%E4%BB%B6/</link><pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8008-stl%E7%BB%84%E4%BB%B6/</guid><description>Standard Template libaray 标准模板库 学习内容： 标准容器 顺序容器 vector deque list 容器适配器 stack queue priority_queue 关联容器 无需关联容器 unordered_set unordered_multiset unordered_map unordered_multimap 有序关联容器 set multiset map multimap 近容器 数组 string bitset 迭代器 iterator const_iterator reverse_iterator const_reverse_iterator</description></item><item><title>【C++基础】07 - 多重继承问题</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8007-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 26 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8007-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/</guid><description>多（重）继承：一个派生类有多个基类class C: public A, public B {};。 虚基类、虚继承、虚基类表 virtual两个用法： 修饰成员方法（虚函数）； 修饰继</description></item><item><title>【C++基础】06 - 继承与多态</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8006-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8006-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</guid><description>继承的本质和原理 继承的本质：代码的复用 类和类之间的关系： 组合：a part of 继承：a kind of 三种继承方式下，派生类对基类成员的访问限定情况： 继承方式 基类</description></item><item><title>【C++基础】05 - 运算符重载、迭代器iterator、operator new</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8005-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%BF%AD%E4%BB%A3%E5%99%A8iteratoroperator-new/</link><pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8005-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%BF%AD%E4%BB%A3%E5%99%A8iteratoroperator-new/</guid><description>运算符重载的意义在于，使得对象的运算表现得和编译器内置的类型一样。例如： 1 2 3 4 template&amp;lt;typename T&amp;gt; T sum(T a, T b) { return a + b; // a.+(b); } 如果T是内置类型，a + b可以直</description></item><item><title>【C++基础】04 - 模板编程、分配器allocator</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8004-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B%E5%88%86%E9%85%8D%E5%99%A8allocator/</link><pubDate>Thu, 11 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8004-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B%E5%88%86%E9%85%8D%E5%99%A8allocator/</guid><description>函数模板 相关的概念： 函数模板：不进行编译，因为调用前不知道类型 模板的实例化：函数调用点进行实例化 模板函数：需要编译的代码 模板类型参数：typ</description></item><item><title>【C++基础】03 - OOP基础知识总结</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8003-oop%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8003-oop%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid><description>本篇总结C++OOP的基础知识。 类、对象、this指针 类和对象简单介绍 类，是实体的抽象类型。 使用OOP解决问题首先要在问题中找到实体，从实体</description></item><item><title>【C++基础】02 - C++基础知识总结</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8002-c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 04 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8002-c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid><description>本篇总结C++OOP之外的基础知识。 形参带默认值的函数 默认参数应该从右向左给出，调用时从左向右给出参数，如未指定某个参数则从此向右的参数使用</description></item><item><title>【C++基础】01 - 地址空间、函数调用、编译链接</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8001-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8001-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</guid><description>虚拟地址空间 这里讨论的虚拟地址空间，是在x86-32位-Linux环境下的。 任何编程语言的程序代码编译为可执行文件（存放在磁盘上）时，都会生</description></item><item><title>【算法】Next Permutaion 问题</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95next-permutaion-%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95next-permutaion-%E9%97%AE%E9%A2%98/</guid><description>问题描述 给定一个数字或字符序列，要求找到它的下一个按字典序升序排列的序列。 相关题目： LeetCode31.下一个排列 LeetCode556.</description></item><item><title>【Linux网络编程】10 - HTTPServer</title><link>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B10-httpserver/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B10-httpserver/</guid><description>通信流程分析 获取 http协议的第一行。 从首行中拆分 GET、文件名、协议版本。 获取用户请求的文件名。 判断文件是否存在。 stat() 判断是文件还是目录。 是</description></item><item><title>【Linux网络编程】09 - libevent</title><link>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B09-libevent/</link><pubDate>Sun, 19 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B09-libevent/</guid><description>libevent库是开源的、精简的、跨平台的、专注于网络通信的库。 安装libevent 这里使用libevent-2.1.8版本。 libeve</description></item><item><title>【Linux网络编程】07 - UDP-Socket编程</title><link>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B07-udp-socket%E7%BC%96%E7%A8%8B/</link><pubDate>Sat, 18 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B07-udp-socket%E7%BC%96%E7%A8%8B/</guid><description>UDP实现的C/S模型 recvfrom 从对端接收数据。（UDP） 函数原型： 1 2 3 4 5 #include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/socket.h&amp;gt; ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); 返回值： 失败，-1，errno 成功，</description></item><item><title>【Linux网络编程】08 - 本地套接字</title><link>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B08-%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97/</link><pubDate>Sat, 18 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B08-%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97/</guid><description>本地套接字 Unix Domain Socket socket API原本是为网络通讯设计的，但后来在socket的框架上发展出一种IPC机制，就是UNIX Domain Socket。虽然网络soc</description></item><item><title>【Linux网络编程】06 - 线程池</title><link>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B06-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link><pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B06-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid><description>线程池 为什么要使用线程池？ 回顾之前写的多线程服务器，主线程使用监听套接字循环accept客户端连接，一旦有新的客户端连接，就创建一个新的线程</description></item><item><title>【Linux网络编程】05 - epoll - Reactor 模型</title><link>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B05-epoll-reactor-%E6%A8%A1%E5%9E%8B/</link><pubDate>Tue, 14 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B05-epoll-reactor-%E6%A8%A1%E5%9E%8B/</guid><description>epoll - Reactor 反应堆模型 常规模型和Reactor模型的比较 常规模型（epoll - ET - 非阻塞IO轮询） select() bind() listen()初始化监听套接字listen</description></item><item><title>【Linux网络编程】04 - epoll - ET触发模型</title><link>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B04-epoll-et%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 13 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B04-epoll-et%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%9E%8B/</guid><description>epoll事件触发模型 - LT &amp;amp; ET epoll事件有两种模型： Edge Triggered (ET)：边沿触发模型，只有数据到来时才会导致epoll_wait返回，无论缓冲</description></item><item><title>【Linux网络编程】03 - 多路IO转接服务器</title><link>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B03-%E5%A4%9A%E8%B7%AFio%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Sat, 11 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B03-%E5%A4%9A%E8%B7%AFio%E8%BD%AC%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>多路IO转接服务器 我们之前写的服务器程序的逻辑是，主线程循环调用accept()，进行阻塞监听客户端的连接，当有连接到来时，主线程获得acc</description></item><item><title>【Linux网络编程】02 - 多进程-多线程 并发服务器</title><link>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B02-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B02-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>多进程并发服务器 父进程创建监听socket监听客户端连接，每次accept一个连接，就fork创建一个子进程来处理这个连接，然后父进程继续监</description></item><item><title>【Linux网络编程】01 - Socket编程</title><link>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B01-socket%E7%BC%96%E7%A8%8B/</link><pubDate>Wed, 08 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B01-socket%E7%BC%96%E7%A8%8B/</guid><description>网络套接字 socket Socket本身有插座的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。 既然是</description></item><item><title>【Linux系统编程】12 - 线程同步</title><link>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B12-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</link><pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B12-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</guid><description>同步 什么是同步 所谓同步，即同时起步，协调一致。不同的对象，对同步的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；</description></item><item><title>【Linux系统编程】11 - 守护进程、线程</title><link>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B11-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B11-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</guid><description>进程组和会话 进程组 - 概念和特性 进程组，也称之为作业。BSD 于 1980 年前后向 Unix 中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程</description></item><item><title>【VSCode】用户代码片段 - 自动生成代码框架</title><link>https://xushun1221.github.io/2022/vscode%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/vscode%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6/</guid><description>前言 最近写了好多C程序，每次新建一个C文件都要写头文件和main函数，有点烦，想着VSCode能不能自动填写这些东西，还真可以，好耶。 使用 User</description></item><item><title>【Linux系统编程】10 - 信号</title><link>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B10-%E4%BF%A1%E5%8F%B7/</link><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B10-%E4%BF%A1%E5%8F%B7/</guid><description>信号的概念 信号在我们的生活中随处可见，如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪…… 他们都有共性： 简单； 不能携带大量</description></item><item><title>【Linux系统编程】09 - 进程间通信</title><link>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B09-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</link><pubDate>Thu, 26 May 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B09-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</guid><description>IPC - Inter Process Communication Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和</description></item><item><title>【Linux系统编程】08 - 进程</title><link>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B08-%E8%BF%9B%E7%A8%8B/</link><pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B08-%E8%BF%9B%E7%A8%8B/</guid><description>进程相关概念 程序和进程 程序：非活动的，只占用磁盘空间； 进程：运行起来的程序，占用内存、CPU等系统资源。 并发 在操作系统中，一个时间段中有多个</description></item><item><title>【Linux系统编程】07 - 文件系统编程</title><link>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B07-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</link><pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B07-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</guid><description>Inode和dentry Inode的本质是一个结构体，存储文件的属性信息。如：权限、类型、大小、时间、用户、盘块位置等等。也叫作文件属性管理</description></item><item><title>【Linux系统编程】06 - 文件IO</title><link>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B06-%E6%96%87%E4%BB%B6io/</link><pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B06-%E6%96%87%E4%BB%B6io/</guid><description>系统调用和系统函数 系统调用，是由操作系统实现并提供给外部应用程序的编程接口，是应用程序同操作系统之间数据交互的桥梁。 系统函数又是什么？例如，</description></item><item><title>【Linux系统编程】04 - gdb调试器的使用</title><link>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B04-gdb%E8%B0%83%E8%AF%95%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B04-gdb%E8%B0%83%E8%AF%95%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>参考这里一起看gdb介绍 gdb使用前提 使用gdb调试器进行调试的前提条件，是对文件进行编译时添加-g选项，为可执行文件添加调试信息，这样会使</description></item><item><title>【Linux系统编程】05 - Makefile的使用</title><link>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B05-makefile%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Fri, 13 May 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B05-makefile%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>Makefile基础 Makefile是用来管理项目的脚本。 Makefile的命名只有两种方式：makefile，Makefile。 Makef</description></item><item><title>【Linux系统编程】03 - gcc编译器 静态库和动态库</title><link>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B03-gcc%E7%BC%96%E8%AF%91%E5%99%A8-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</link><pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B03-gcc%E7%BC%96%E8%AF%91%E5%99%A8-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</guid><description>gcc编译器可以参考gcc编译器 gdb调试器可以参考gdb调试器 gcc编译的四步骤 源文件（hello.c）编译为可执行文件（a.out）步骤</description></item><item><title>【Linux系统编程】02 - vim的使用</title><link>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B02-vim%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B02-vim%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>vim的三种模式 vim有三种模式： 命令模式 文本模式 末行模式 三种模式的切换： vi filename，使用vim打开文件，文件不存在会创建。此时会进</description></item><item><title>【Linux系统编程】01 - Linux系统知识和基础操作</title><link>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B01-linux%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%92%8C%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</link><pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B01-linux%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%92%8C%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</guid><description>终端 一切输入输出设备的总称，键盘、鼠标、显示器&amp;hellip; Linux系统中的终端Terminal，是虚拟终端。 shell 在终端中输入命令会被执行</description></item><item><title>【算法】有序表 - 实现结构总结</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9C%89%E5%BA%8F%E8%A1%A8-%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9C%89%E5%BA%8F%E8%A1%A8-%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</guid><description>有序表的类型 红黑树 - Red Black Tree AVL - Adelson-Velsky and Landis 自平衡的搜索二叉树 SBT - Size Balanced Tree 节点大小平衡树 上述有序表的查找时间复杂度都为：$O\left(logn\ri</description></item><item><title>【算法】动态规划 - 进阶</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%BF%9B%E9%98%B6/</link><pubDate>Fri, 29 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%BF%9B%E9%98%B6/</guid><description>如何评价尝试方法 两个方面： 单个可变参数的维度（绝大多数的题目0维度即可，如int类型）； 可变参数的个数。 相关题目 题目1：纸牌博弈-预测赢家 （</description></item><item><title>【算法】暴力递归->记忆化搜索->动态规划</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>三者关系 找到某个解决问题的尝试方法 暴力递归就是不经过优化的暴力尝试 记忆化搜索的动态规划，在暴力递归基础上优化，无需规定每个状态的依赖关系 严格</description></item><item><title>【算法】位运算相关题目</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</link><pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</guid><description>待补充吧。。。 题目1：不适用比较判断返回较大的数 题目描述：给定两个32位有符号整型a b，返回其中较大的数，不能使用比较判断方法。</description></item><item><title>【算法】资源限制类的大数据问题 - 技巧总结</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</guid><description>资源限制类的大数据问题的解题技巧 哈希函数可以把数据按照种类均匀分流 布隆过滤器用于集合的建立和查询，并可以节省大量空间 一致性哈希解决数据服务器</description></item><item><title>【算法】一致性哈希算法</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</guid><description>待补充。。。</description></item><item><title>【算法】二叉树的Morris遍历</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84morris%E9%81%8D%E5%8E%86/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84morris%E9%81%8D%E5%8E%86/</guid><description>Morris遍历是什么 一种遍历二叉树的方式，且时间复杂度为$O\left(n\right)$，空间复杂度为$O\left(1\right)$</description></item><item><title>【算法】树形DP问题套路</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%A0%91%E5%BD%A2dp%E9%97%AE%E9%A2%98%E5%A5%97%E8%B7%AF/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%A0%91%E5%BD%A2dp%E9%97%AE%E9%A2%98%E5%A5%97%E8%B7%AF/</guid><description>树形DP套路 使用前提 如果题目求解目标是S规则，则求解流程可以定成，以每一个结点为头节点的子树在S规则下的每一个答案，并且答案一定在其中。 步骤</description></item><item><title>【算法】滑动窗口&amp;单调栈</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%95%E8%B0%83%E6%A0%88/</link><pubDate>Sat, 16 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%95%E8%B0%83%E6%A0%88/</guid><description>滑动窗口是什么 一个数组arr，一个左边界L，一个右边界R，滑动窗口就是L R控制的范围，L始终小于等于R，R向右移动时窗口内增加一个元素，L向</description></item><item><title>【算法】Manacher算法 - 原理及实现</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95manacher%E7%AE%97%E6%B3%95-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link><pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95manacher%E7%AE%97%E6%B3%95-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid><description>最长回文子串 LeetCode5 问题描述：给你一个字符串 s，找到 s 中最长的回文子串（回文是前后部分对称的字符串，且子串要求连续）。 经典算法 中心扩散法：遍历字符</description></item><item><title>【算法】KMP算法 - 原理及实现</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95kmp%E7%AE%97%E6%B3%95-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link><pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95kmp%E7%AE%97%E6%B3%95-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid><description>字符串匹配算法 LeetCode28 问题描述：给你两个字符串haystack和needle，请你在haystack字符串中找出needle字符串出现的第一个位置</description></item><item><title>【算法】并查集</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%B9%B6%E6%9F%A5%E9%9B%86/</link><pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid><description>前言 考虑这样一个经典问题LeetCode200：给你一个由 1（陆地）和 0（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，</description></item><item><title>【算法】位图与布隆过滤器 - 原理及实现</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link><pubDate>Tue, 12 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid><description>前言 考虑如下问题：假设你是网管，你有一个文件，其中存储了100亿个违反法律的url（每个url最多64字节），你不想让用户访问这些网站，如何</description></item><item><title>【算法】哈希函数与哈希表的实现原理</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Tue, 12 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>哈希函数 哈希函数的特征 输入域：无穷，输出域：有穷 确定性：对于同一个哈希函数，相同的输入必然会有相同的输出 哈希碰撞：由于输出域是有限的，在很小</description></item><item><title>【算法】暴力递归（回溯）</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF/</guid><description>暴力递归 暴力递归就是尝试： 把问题转化为规模缩小了的同类问题的子问题 有明确的不需要继续进行递归的条件（base case） 有当得到了子问题的结果</description></item><item><title>【算法】贪心算法</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid><description>贪心算法定义 在某个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的做法叫贪心算法。也就是说，不从整体最优上考</description></item><item><title>【算法】前缀树</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%89%8D%E7%BC%80%E6%A0%91/</link><pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%89%8D%E7%BC%80%E6%A0%91/</guid><description>前缀树的定义 前缀树（Trie，字典树）是N叉树的一种特殊形式。通常来说，一个前缀树是用来存储字符串的。前缀树的每一个节点代表一个字符串（前缀</description></item><item><title>C++字符串操作相关</title><link>https://xushun1221.github.io/2022/c-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3/</link><pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3/</guid><description>int 和 string 互相转换 1 2 3 4 5 #include &amp;lt;string&amp;gt;using namespace std; int a = stoi(&amp;#34;123&amp;#34;); string s = to_string(123); 按字符分割字符串 使用C库函数strtok： 1 2 char* strtok( char* str, const char* delim ); // 线程不安全 char *strtok_r(char *str, const char *delim, char **saveptr); //</description></item><item><title>【算法】图</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%9B%BE/</link><pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%9B%BE/</guid><description>图的定义 图大体可以由邻接表和邻接矩阵两种形式来表示。 可以用自己习惯的结构将图的算法全部实现一遍，当遇到图相关的问题，可以将数据描述转换为自己</description></item><item><title>C++输入输出</title><link>https://xushun1221.github.io/2022/c-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</link><pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</guid><description>基本输入 cin &amp;gt;&amp;gt;会自动过滤掉：空格、回车、TAB等不可见字符（会被吃掉，不会保留在输入流中），可以用于string和数组 cin.g</description></item><item><title>【算法】二叉树</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>二叉树定义 1 2 3 4 5 6 7 8 struct TreeNode { int val; TreeNode *left; TreeNode *right; // TreeNode() : val(0), left(nullptr), right(nullptr) {} // TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} // TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; 递归遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</description></item><item><title>【算法】链表</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E9%93%BE%E8%A1%A8/</guid><description>链表定义 1 2 3 4 5 6 7 8 9 10 11 12 // 单链表 struct ListNode { int val; ListNode *next; }; // 双链表 struct ListNode { int val; ListNode *next; ListNode *front; }; 链表题目之方法论 笔试：不用太在乎空间复杂度，一切为了时间</description></item><item><title>CS144 Lab Assignment lab-4</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-4/</link><pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-4/</guid><description>前言 前后经过半个多月终于把关于TCP的几个lab写完了，★,°:.☆(￣▽￣)/$:.°★ 。 lab4的难点在于对于TCP各个状态的理解、如何</description></item><item><title>CS144 Lab Assignment lab-3</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-3/</link><pubDate>Thu, 17 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-3/</guid><description>the TCP sender 本次实验是TCP的sender，需要完成的主要功能有： 跟踪接收方的接收窗口，正确处理接收方返回的确认号ackno和窗口大小window</description></item><item><title>CS144 Lab Assignment lab-2</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-2/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-2/</guid><description>build 首先把origin/lab2-startercode合并到本地仓库，cmake构建时，有可能会报错： CMake Error: The following variables are used in this project, but they are set to NOTFOUND. 这是因</description></item><item><title>CS144 Lab Assignment lab-1</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-1/</link><pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-1/</guid><description>stitching substrings into a byte stream 本次实验是要实现一个流重组器，能够将TCPReceiver接收到的乱序的、重复的TCP段重新组装成一个正确的、按序的、无重复的字</description></item><item><title>CS144 Lab Assignment lab-0</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-0/</link><pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-0/</guid><description>前言 最近重新学习了一下计算机网络的知识，想着搞点东西做一做，然后就看到了这个Stanford的CS144网络课，它有一系列的网络实验，主要是</description></item><item><title>【算法】桶排序</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%A1%B6%E6%8E%92%E5%BA%8F/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%A1%B6%E6%8E%92%E5%BA%8F/</guid><description>桶排序 使用桶排序思想的算法主要有计数排序和基数排序两种。桶排序思想的排序都是不基于比较的排序方法。时间复杂度为$O\left(n\right</description></item><item><title>Ubuntu&amp;Windows下终端挂代理方法（QV2ray）</title><link>https://xushun1221.github.io/2022/ubuntuwindows%E4%B8%8B%E7%BB%88%E7%AB%AF%E6%8C%82%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95qv2ray/</link><pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/ubuntuwindows%E4%B8%8B%E7%BB%88%E7%AB%AF%E6%8C%82%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95qv2ray/</guid><description>问题 费力巴拉的在Ubuntu上装好了QV2ray（通过snap安装），发现shell还是不能用git clone，研究了一下，明白了。 Ubun</description></item><item><title>Ubuntu虚拟机无法和win10互相复制粘贴及拖拽</title><link>https://xushun1221.github.io/2022/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E5%92%8Cwin10%E4%BA%92%E7%9B%B8%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%8F%8A%E6%8B%96%E6%8B%BD/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E5%92%8Cwin10%E4%BA%92%E7%9B%B8%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%8F%8A%E6%8B%96%E6%8B%BD/</guid><description>问题 Ubuntu虚拟机无法和win10系统互相复制粘贴以及拖拽文件。安装vmware-tools无用。 解决方法 不要安装vmware-tool</description></item><item><title>【算法】堆排序</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F/</link><pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F/</guid><description>堆排序 原理：利用大根堆（小根堆）结构来进行排序。 实现1 这种实现方法，在建立最大堆时，从后向前对每个有孩子的结点进行了一次向下调整算法，建堆时</description></item><item><title>【算法】快速排序</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>问题1：partition1.0 问题描述：给定一个数组和一个数x，将数组中小于x的数放在数组左边，大于等于x的数放在数组右边，要求空间复杂度</description></item><item><title>Coding之小技巧</title><link>https://xushun1221.github.io/2022/coding%E4%B9%8B%E5%B0%8F%E6%8A%80%E5%B7%A7/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/coding%E4%B9%8B%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid><description>前言 记录一些Coding的技巧。 取数组下标中点 常规的取下标中点方法：mid = (left + right) / 2，这种方法在数组很大的时候，可能会溢出，所以用这种方法</description></item><item><title>Ubuntu下切换gccg++版本</title><link>https://xushun1221.github.io/2022/ubuntu%E4%B8%8B%E5%88%87%E6%8D%A2gccg-%E7%89%88%E6%9C%AC/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/ubuntu%E4%B8%8B%E5%88%87%E6%8D%A2gccg-%E7%89%88%E6%9C%AC/</guid><description>前言 我的Ubuntu18.04安装的build-essential默认的gcc/g++版本为7.5，现在需要8版本的，切换版本的操作如下。 操</description></item><item><title>【算法】归并排序</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid><description>归并排序 直接代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int mid, int right) { if (left == right) return; vector&amp;lt;int&amp;gt; temp(right - left + 1); int l = left, r = mid + 1, i = 0; while (l &amp;lt;= mid</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【5】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%915/</link><pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%915/</guid><description>前言 学了这么多，写一个简单的项目来总结一下。 写源码 源码 编译 编译 调试 点击Run and Debug按钮，新建launch.json文件，然后按F5即可</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【3】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%913/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%913/</guid><description>安装VSCode 直接官网下载最新版本的deb包，地址：https://code.visualstudio.com； 在下载deb包的目录下打开</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【4】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%914/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%914/</guid><description>CMake是啥 一个跨平台的安装编译工具，可以使用简单的语句来描述所有平台的编译安装过程； 是大部分C++开源项目的标配； CMake语法特性 基本</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【2】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%912/</link><pubDate>Sun, 13 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%912/</guid><description>GDB调试器介绍 GDB是什么 GDB(GNU Debugger)是一个用来调试C/C++程序的功能强大的调试器，是Linux系统开发C/C++最常用的调试器</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【1】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%911/</link><pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%911/</guid><description>安装Linux系统 这里用的是虚拟机 Ubuntu 18.04 LTS 安装过程略。 安装GCC、GDB、CMake 安装GCC，GDB 1 2 3 sudo apt update sudo apt install build-essential gdb 安装CMake 1 sudo</description></item><item><title>【算法】二分查找</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid><description>前言 二分查找算法，思想比较简单，但是实现上有许多细节需要考虑，尤其是在边界条件的判断上，很容易出错。最近看了一个关于二分查找的总结，用另一种</description></item><item><title>【算法】C++对数器</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95c-%E5%AF%B9%E6%95%B0%E5%99%A8/</link><pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95c-%E5%AF%B9%E6%95%B0%E5%99%A8/</guid><description>对数器是什么 对数器是用来测试算法正确性的一种方式，在找不到合适的在线OJ时，我们也可以编写一个对数器来测试自己编写的算法的正确性。原理是用一</description></item><item><title>image test</title><link>https://xushun1221.github.io/2022/image-test/</link><pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/image-test/</guid><description>image test 图片</description></item><item><title>【算法】位运算之异或运算</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</guid><description>什么是异或 逻辑运算符异或（exclusive or），XOR或EOR（编程语言中多用^），对两个运算元的一种逻辑析取类型，异或算符的值为真当且</description></item><item><title>blog post test</title><link>https://xushun1221.github.io/2022/blog-post-test/</link><pubDate>Mon, 17 Jan 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/blog-post-test/</guid><description/></item><item><title>Markdown基本语法</title><link>https://xushun1221.github.io/2022/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 17 Jan 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid><description>更新注意事项 hugo搭建blog，使用markdown中代码块时，需要使用LF换行模式，否则会出错； 表格不能光有表头。 1. 标题 在单词短句之前添</description></item></channel></rss>