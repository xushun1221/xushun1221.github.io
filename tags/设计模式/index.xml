<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on XuShun's Blog</title><link>https://xushun1221.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on XuShun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 15 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://xushun1221.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>【设计模式】04 - 装饰器模式</title><link>https://xushun1221.github.io/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F04-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F04-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>装饰器模式 Decorator 装饰器模式也是一种结构型模式，该模式的主要特点就是增加现有类的功能。 如果要增加现有类的功能，简单的方法就是通过子类来实现，重写接</description></item><item><title>【设计模式】05 - 适配器模式</title><link>https://xushun1221.github.io/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F05-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F05-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>适配器模式 Adapter 适配器模式也是一种结构型模式，主要的功能是让不兼容的接口能够在一起工作。 在项目开发中往往会使用到一些第三方的代码库，它们的接口设</description></item><item><title>【设计模式】06 - 观察者模式</title><link>https://xushun1221.github.io/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F06-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F06-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>行为型模式，主要关注对象之间的通信，观察者模式是一种行为型设计模式。 观察者模式 Obverser 观察者模式，也叫做观察者-监听者模式，或者发布-订阅模式。 观</description></item><item><title>【设计模式】03 - 代理模式</title><link>https://xushun1221.github.io/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F03-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 11 Jan 2023 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F03-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid><description>代理模式、装饰器模式、适配器模式等，不同于创建型的模式，它们属于结构型模式，主要关注类和对象的组合，功能的使用。 代理模式 Proxy Pattern 代理模式是这样一</description></item><item><title>【设计模式】01 - 单例模式</title><link>https://xushun1221.github.io/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F01-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 10 Jan 2023 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F01-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>单例模式 单例模式，是一种创建型的设计模式，主要用来管理对象的创建方式。使用单例模式的类，无论创建多少次对象，永远只会存在一个该类型的对象实例</description></item><item><title>【设计模式】02 - 工厂模式</title><link>https://xushun1221.github.io/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F02-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 10 Jan 2023 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2023/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F02-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>工厂模式 工厂模式，也是一种创建型的设计模式，主要是封装了对象的创建。 在程序中有很多类的情况下，我们在new对象时需要记住很多的类名，而且在类</description></item></channel></rss>