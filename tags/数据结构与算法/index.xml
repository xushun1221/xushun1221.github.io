<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数据结构与算法 on Shuzang's Blog</title><link>https://shuzang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link><description>Recent content in 数据结构与算法 on Shuzang's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 18 Sep 2020 20:37:00 +0800</lastBuildDate><atom:link href="https://shuzang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>算法-时间复杂度和空间复杂度</title><link>https://shuzang.github.io/2020/algorithm-time-and-space-complexity/</link><pubDate>Fri, 18 Sep 2020 20:37:00 +0800</pubDate><guid>https://shuzang.github.io/2020/algorithm-time-and-space-complexity/</guid><description>&lt;p>时间和空间复杂度的分析是编制程序的一个基本能力，不过平时基本都是脑子里简单的估计，本篇文章打算回忆一下大 O 表示法和具体的时间复杂度的推导过程。&lt;/p></description></item><item><title>算法-字符串类问题</title><link>https://shuzang.github.io/2020/algorithm-stings/</link><pubDate>Mon, 24 Aug 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/algorithm-stings/</guid><description>做 Leetcode 每日一题的时候遇到了子串判断类的问题，想起一直没仔细的去看过 KMP 等字符串常用的算法，所以这里学习一下。 1. 重复的子字符串 这就是今天遇到的题目</description></item><item><title>算法-背包问题</title><link>https://shuzang.github.io/2020/algorithm-knapsack-problem/</link><pubDate>Thu, 06 Aug 2020 10:22:00 +0800</pubDate><guid>https://shuzang.github.io/2020/algorithm-knapsack-problem/</guid><description>&lt;p>奇安信的笔试遇到了完全背包问题，结果写的时候按 0-1 背包写的贪心，最后没 AC，因此本篇对所有的背包问题做一次整理。&lt;/p></description></item><item><title>算法-分支限界</title><link>https://shuzang.github.io/2020/algorithm-branch-and-bound/</link><pubDate>Thu, 23 Jul 2020 10:07:00 +0800</pubDate><guid>https://shuzang.github.io/2020/algorithm-branch-and-bound/</guid><description>&lt;p>分支限界和回溯都是有效搜索解空间树的方法，不同的是，分支限界使用广度优先或最小耗费/最大效益优先的方式。&lt;/p></description></item><item><title>算法-回溯</title><link>https://shuzang.github.io/2020/algorithm-backtracking/</link><pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/algorithm-backtracking/</guid><description>在真实的世界中，很多问题是不存在快速解法的，只能穷尽搜索，因此一个高效的搜索技术非常重要。回溯（Backtracking）和分支限界（Bra</description></item><item><title>算法-贪心</title><link>https://shuzang.github.io/2020/algorithm-greedu/</link><pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/algorithm-greedu/</guid><description>&lt;p>贪心是一种策略，是一种总是寻求当前最优的策略。因为贪心只关心局部的最优，因此不是总能得到全局的最优解，所以我们选择贪心解决问题时必须保证状态的独立性，即当前最优值只与当前状态有关，不会影响以后的状态。&lt;/p></description></item><item><title>算法-动态规划</title><link>https://shuzang.github.io/2020/algorithm-dynamic-programming/</link><pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/algorithm-dynamic-programming/</guid><description>&lt;p>动态规划策略通常用于求解最优化问题。在这类问题中，可能会有许多可行解，每个解对应一个值，我们希望找到具有最优值的那个解，也就是最优解。当题目中涉及「最大」「最小」等词时，很有可能就是这类问题，要考虑是否可用动态规划求解。&lt;/p></description></item><item><title>算法-分治</title><link>https://shuzang.github.io/2020/algorithm-divide-and-conquer/</link><pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/algorithm-divide-and-conquer/</guid><description>分治，字面意思就是分而治之，意思就是把一个复杂的问题分成两个或更多个相同或相似的子问题，解决子问题后再进行合并。典型的如归并排序和快排，都是</description></item><item><title>算法-递归</title><link>https://shuzang.github.io/2020/algorithm-recursive/</link><pubDate>Sun, 12 Apr 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/algorithm-recursive/</guid><description>&lt;p>首先简单阐述一下递归、分治、动态规划和贪心这几个东西的区别和联系。&lt;/p>
&lt;ol>
&lt;li>递归是一种编程技巧，一种解决问题的思维方式；&lt;/li>
&lt;li>分治和动态规划是建立在递归基础上的，解决更具体问题的两类算法思想（实现动态规划大都不是递归的，但是过程和思想是）；&lt;/li>
&lt;li>贪心是动态规划的一个子集，可以更高效解决一部分更特殊的问题。&lt;/li>
&lt;/ol></description></item><item><title>算法-排序</title><link>https://shuzang.github.io/2020/algorithm-sort/</link><pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/algorithm-sort/</guid><description>排序算法分为内部排序（待排序记录存放在内存中进行的排序过程）和外部排序（由于待排序记录数量大，以致内存一次不能容纳全部记录，在排序过程中需要</description></item><item><title>算法-搜索</title><link>https://shuzang.github.io/2020/algorithm-search/</link><pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/algorithm-search/</guid><description>&lt;p>搜索是最常用的算法之一，但线性的搜索进行介绍没有太大的意义，本文介绍搜索中一种广为使用的方法：二分查找。&lt;/p></description></item><item><title>算法-数组类问题</title><link>https://shuzang.github.io/2020/algorithm-array/</link><pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/algorithm-array/</guid><description>数组的访问时间为 $O(1)$，这是它最大的优势，但限于数组固定的大小，平常使用最多的是动态数组。在 Golang 中，其实就是[切片]^(slice)，动</description></item><item><title>数据结构-并查集</title><link>https://shuzang.github.io/2020/data-structure-union-find-set/</link><pubDate>Wed, 18 Mar 2020 18:44:00 +0800</pubDate><guid>https://shuzang.github.io/2020/data-structure-union-find-set/</guid><description>&lt;p>并查集是一种特别而实用的结构，主要作用是进行不相交集合的合并和判断两个元素是否在同一集合，时间复杂度为常数级。常见用途包括 Kruskal 算法和求最近公共祖先，本篇文章介绍该数据结构。&lt;/p></description></item><item><title>数据结构-B树与红黑树</title><link>https://shuzang.github.io/2020/data-structure-b-tree-and-red-black-tree/</link><pubDate>Wed, 18 Mar 2020 09:21:00 +0800</pubDate><guid>https://shuzang.github.io/2020/data-structure-b-tree-and-red-black-tree/</guid><description>&lt;p>本篇介绍B树（B-树），B+树和红黑树，参考自陈小玉，《趣学数据结构》。&lt;/p></description></item><item><title>数据结构-图</title><link>https://shuzang.github.io/2020/data-structure-graph/</link><pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/data-structure-graph/</guid><description>链表是一种一对一的关系，树是一种一对多的关系，图则是一种多对多的关系。实际上，我们可以将链表和树都看作图的一部分。 1. 图的定义 用 V(Vertex) 表示顶点的集</description></item><item><title>数据结构-堆</title><link>https://shuzang.github.io/2020/data-structure-heap/</link><pubDate>Wed, 11 Mar 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/data-structure-heap/</guid><description>&lt;p>普通的队列是一种先进先出的数据结构，在此基础上，还有一种叫做 &lt;strong>优先队列&lt;/strong> 的结构。顾名思义，优先队列就是具有优先级的队列，其中，元素被赋予优先级，具有最高优先级的元素将最先被访问。&lt;/p></description></item><item><title>数据结构-二叉搜索树</title><link>https://shuzang.github.io/2020/data-structure-binary-search-tree/</link><pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/data-structure-binary-search-tree/</guid><description>二叉搜索树是二叉树的一种特殊形式，由于它对查找的良好特性，使用较为广泛，本篇文章我们对其进行介绍，同时也包括二叉搜索树的各种进阶，比如二叉平</description></item><item><title>数据结构-二叉树</title><link>https://shuzang.github.io/2020/data-structure-tree-and-binary-tree/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/data-structure-tree-and-binary-tree/</guid><description>树是反映事物之间层次关系的一种结构，比如家谱树、硬盘目录结构树等。 使用树的原因是这种层次结构在管理上有更高的效率，以查找为例，顺序查找的时间</description></item><item><title>数据结构-队列与栈</title><link>https://shuzang.github.io/2020/data-structure-queue-and-stack/</link><pubDate>Sat, 22 Feb 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/data-structure-queue-and-stack/</guid><description>&lt;p>队列与栈是最常使用的两种数据结构，其中，队列的核心特征是先入先出，栈的核心特征是后入先出，只要符合这两个特征，就属于队列（栈），不因实现形式的不同（数组或链表）而有差别，可以根据具体情况选择使用起来更方便的实现形式。&lt;/p>
&lt;p>在本文中，我们对队列与栈的核心功能，循环队列这种特殊结构，以及队列和栈的主要应用，尤其是广度优先搜索和深度优先搜索进行介绍。&lt;/p></description></item><item><title>数据结构-链表</title><link>https://shuzang.github.io/2020/data-structure-linkedlist/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>https://shuzang.github.io/2020/data-structure-linkedlist/</guid><description>链表是一种最为基础的数据结构，由一系列结点组成，每个结点不仅包含值，还包含指向下一个结点（有时也包括上一个结点）的指针。相比于数组，在链表中</description></item></channel></rss>