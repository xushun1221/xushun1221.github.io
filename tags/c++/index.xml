<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on XuShun's Blog</title><link>https://xushun1221.github.io/tags/c++/</link><description>Recent content in C++ on XuShun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 02 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://xushun1221.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>【ChatServer】15 - 客户端</title><link>https://xushun1221.github.io/2022/chatserver15-%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><pubDate>Fri, 02 Dec 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/chatserver15-%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description>简单实现一个基于控制台的客户端，功能比较简单，直接使用系统API和c++11的线程库（pthread底层），不用muduo库了，一个线程读消</description></item><item><title>【ChatServer】11 - 一对一聊天&amp;离线消息</title><link>https://xushun1221.github.io/2022/chatserver11-%E4%B8%80%E5%AF%B9%E4%B8%80%E8%81%8A%E5%A4%A9%E7%A6%BB%E7%BA%BF%E6%B6%88%E6%81%AF/</link><pubDate>Wed, 30 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/chatserver11-%E4%B8%80%E5%AF%B9%E4%B8%80%E8%81%8A%E5%A4%A9%E7%A6%BB%E7%BA%BF%E6%B6%88%E6%81%AF/</guid><description>一对一聊天消息类型为：PEER_CHAT_MSG。 发送的消息类似于：{&amp;quot;msg_type&amp;quot;:PEER_CHAT_MSG,</description></item><item><title>【ChatServer】12 - 服务器异常中止处理</title><link>https://xushun1221.github.io/2022/chatserver12-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%AD%A2%E5%A4%84%E7%90%86/</link><pubDate>Wed, 30 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/chatserver12-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%AD%A2%E5%A4%84%E7%90%86/</guid><description>之前测试功能时，如果服务器异常中止，那么当前的在线用户的在线状态并不会被更改为离线（没有机会更改数据库状态），如果下次服务器启动，用户就无法</description></item><item><title>【ChatServer】13 - 添加好友业务</title><link>https://xushun1221.github.io/2022/chatserver13-%E6%B7%BB%E5%8A%A0%E5%A5%BD%E5%8F%8B%E4%B8%9A%E5%8A%A1/</link><pubDate>Wed, 30 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/chatserver13-%E6%B7%BB%E5%8A%A0%E5%A5%BD%E5%8F%8B%E4%B8%9A%E5%8A%A1/</guid><description>业务逻辑是这样滴，系统中的所有人都可以互发消息，无需好友身份。添加好友也无需对方同意，好友的功能类似于通讯录，客户端登录时，服务器会将该用户</description></item><item><title>【ChatServer】14 - 群组业务</title><link>https://xushun1221.github.io/2022/chatserver14-%E7%BE%A4%E7%BB%84%E4%B8%9A%E5%8A%A1/</link><pubDate>Wed, 30 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/chatserver14-%E7%BE%A4%E7%BB%84%E4%B8%9A%E5%8A%A1/</guid><description>涉及群组的功能有三个，创建群、加入群、群聊。分别对应CREATE_GROUP_MSG, JOIN_GROUP_MSG, GROUP_CHAT_MSG三类消息。 涉及到两张表a</description></item><item><title>【ChatServer】07 - MySQL接口封装</title><link>https://xushun1221.github.io/2022/chatserver07-mysql%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/</link><pubDate>Mon, 28 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/chatserver07-mysql%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/</guid><description>先检查一下mysql编程库有没有： 1 2 3 4 5 6 [xushun@localhost ~]$ sudo find /usr -name libmysqlclient* [sudo] password for xushun: /usr/lib64/mysql/libmysqlclient.so.20 /usr/lib64/mysql/libmysqlclient.so.20.3.27 /usr/lib64/mysql/libmysqlclient.a /usr/lib64/mysql/libmysqlclient.so 没有的话安装一个mysql开发包。 封装mysql接口 mysql开</description></item><item><title>【ChatServer】08 - 数据层代码框架设计</title><link>https://xushun1221.github.io/2022/chatserver08-%E6%95%B0%E6%8D%AE%E5%B1%82%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 28 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/chatserver08-%E6%95%B0%E6%8D%AE%E5%B1%82%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1/</guid><description>使用ORM类来映射数据库中的表。如，User类映射数据库中的user表，UserModel类来封装对user表的数据操作。 这样业务层的代码就</description></item><item><title>【ChatServer】09 - 用户注册和登录业务</title><link>https://xushun1221.github.io/2022/chatserver09-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E5%92%8C%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1/</link><pubDate>Mon, 28 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/chatserver09-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E5%92%8C%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1/</guid><description>用户注册业务 用户注册业务在ChatService中完成registr方法即可。 客户端发送REG_MSG类型的消息，并附上name, passw</description></item><item><title>【ChatServer】10 - 客户端异常退出处理</title><link>https://xushun1221.github.io/2022/chatserver10-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA%E5%A4%84%E7%90%86/</link><pubDate>Mon, 28 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/chatserver10-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA%E5%A4%84%E7%90%86/</guid><description>客户端异常退出，客户端没有向服务器发送下线消息，而是直接断开连接。这种情况下，我们需要进行在数据库中更改用户的登录状态。 用户连接异常断开，我</description></item><item><title>【ChatServer】06 - 业务模块与网络模块解耦</title><link>https://xushun1221.github.io/2022/chatserver06-%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E8%A7%A3%E8%80%A6/</link><pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/chatserver06-%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E8%A7%A3%E8%80%A6/</guid><description>业务与网络模块解耦 我们使用了muduo网络库搭建服务器框架，可以直接注册回调函数对客户端的消息进行处理，但是这样业务模块就和网络模块耦合了。</description></item><item><title>优秀的第三方JSON库：JSON for Modern C++ by nlohmann</title><link>https://xushun1221.github.io/2022/%E4%BC%98%E7%A7%80%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9json%E5%BA%93json-for-modern-c-by-nlohmann/</link><pubDate>Thu, 17 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E4%BC%98%E7%A7%80%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9json%E5%BA%93json-for-modern-c-by-nlohmann/</guid><description>JSON 是啥 Json是一种轻量级的数据交换格式（也叫数据序列化方式）。Json采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结</description></item><item><title>【ChatServer】01 - 介绍</title><link>https://xushun1221.github.io/2022/chatserver01-%E4%BB%8B%E7%BB%8D/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/chatserver01-%E4%BB%8B%E7%BB%8D/</guid><description>该项目是一个学习项目，项目目标：开发一个C++实现的局域网集群聊天服务器。 技术栈 JSON库：JSON for Modern C++ muduo网络库 nginx源码编译</description></item><item><title>【ChatServer】02 - 各种环境的安装</title><link>https://xushun1221.github.io/2022/chatserver02-%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</link><pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/chatserver02-%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</guid><description>我的开发环境：CentOS7 CentOS7：VMware Workstation 虚拟机 JSON库：JSON for Modern C++，直接使用json.hpp即可 boost+mo</description></item><item><title>CentOS7安装Cmake</title><link>https://xushun1221.github.io/2022/centos7%E5%AE%89%E8%A3%85cmake/</link><pubDate>Thu, 10 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/centos7%E5%AE%89%E8%A3%85cmake/</guid><description>sudo yum install -y gcc gcc-c++ make automake sudo yum install openssl-devel wget https://github.com/Kitware/CMake/releases/download/v3.24.3/cmake-3.24.3.tar.gz tar zxvf cmake-3.24.3.tar.gz cd cmake-3.24.3 ./configure make sudo make install cmake --version</description></item><item><title>CentOS7安装GooleTest测试框架</title><link>https://xushun1221.github.io/2022/centos7%E5%AE%89%E8%A3%85gooletest%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</link><pubDate>Thu, 10 Nov 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/centos7%E5%AE%89%E8%A3%85gooletest%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/</guid><description>操作系统：CentOS7 升级GCC GoogleTest使用c++14，系统原来的gcc(g++)版本为4.8，需要升级。 sudo yum install centos-release-scl sudo yum install dev</description></item><item><title>【算法】背包问题总结</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid><description>0-1背包 经典题目：2. 01背包问题 相关题目： LeetCode.416 LeetCode.1049 LeetCode.494 LeetCode.474 解法1：二维dp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35</description></item><item><title>【重写muduo】22 - 总结</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo22-%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 06 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo22-%E6%80%BB%E7%BB%93/</guid><description>muduo库的核心部分终于重写完了，我们来总结一下各个核心组件的功能和联系。 Channel Channel是对sockfd和其感兴趣的事件以及对应的回调函</description></item><item><title>【重写muduo】21 - 编译安装脚本&amp;测试代码</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo21-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</link><pubDate>Sun, 02 Oct 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo21-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</guid><description>编译安装脚本 我们的项目使用cmake管理，需要编译为一个.so动态库，动态库安装到系统/usr/lib目录下，头文件拷贝到/usr/incl</description></item><item><title>【重写muduo】20 - TcpServer终章</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo20-tcpserver%E7%BB%88%E7%AB%A0/</link><pubDate>Fri, 30 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo20-tcpserver%E7%BB%88%E7%AB%A0/</guid><description>写完TcpConnection之后，我们就可以来实现TcpServer的完整版本了。 TcpConnection主要做的事情就是，处理新到来的</description></item><item><title>【重写muduo】18 - Buffer缓冲区</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo18-buffer%E7%BC%93%E5%86%B2%E5%8C%BA/</link><pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo18-buffer%E7%BC%93%E5%86%B2%E5%8C%BA/</guid><description>在实现TcpConnection之前，需要实现底层的缓冲区Buffer，具体的实现细节在注释里非常详细的说明了。不再赘述。 源码 Buffer.hh 1 2 3 4 5 6</description></item><item><title>【重写muduo】19 - TcpConnection</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo19-tcpconnection/</link><pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo19-tcpconnection/</guid><description>TcpConnection管理一个socket及其对应的channel、tcp连接状态、一对输入输出缓冲区、设置channel的各种回调函数</description></item><item><title>【重写muduo】15 - Socket类</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo15-socket%E7%B1%BB/</link><pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo15-socket%E7%B1%BB/</guid><description>Socket类封装了网络套接字相关的文件描述符和相关方法。 源码 Socket.hh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #ifndef __SOCKET_HH_#define __SOCKET_HH_ #include &amp;#34;noncopyable.hh&amp;#34; class InetAddress;</description></item><item><title>【重写muduo】16 - Acceptor</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo16-acceptor/</link><pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo16-acceptor/</guid><description>对listenfd和accept函数的封装。 Acceptor运行在mainloop中，负责接收新用户的连接。 源码 Acceptor.hh 1 2 3 4 5 6 7 8 9 10 11 12 13</description></item><item><title>【重写muduo】17 - TcpServer服务器类</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo17-tcpserver%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B1%BB/</link><pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo17-tcpserver%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B1%BB/</guid><description>到这里，muduo中和TcpServer相关的组件基本都写好了，我们先把TcpServer写个大概。 因为TcpConnection的内容还没</description></item><item><title>【重写muduo】12 - Thread</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo12-thread/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo12-thread/</guid><description>muduo库中使用了POSIX线程库，而我们使用c++11标准的线程库对线程类Thread进行封装。 源码 Thread.hh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</description></item><item><title>【重写muduo】13 - EventLoopThread</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo13-eventloopthread/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo13-eventloopthread/</guid><description>上一篇我们封装了Thread类，EventLoopThread类将一个EventLoop和一个Thread封装在一起，实现一个线程运行一个事</description></item><item><title>【重写muduo】14 - EventLoopThreadPool池</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo14-eventloopthreadpool%E6%B1%A0/</link><pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo14-eventloopthreadpool%E6%B1%A0/</guid><description>muduo中除了用于处理新用户连接的主事件循环mainloop(baseloop)外，还有进行已连接用户读写事件操作的subloop，用户可</description></item><item><title>【重写muduo】11 - EventLoop事件循环</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo11-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link><pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo11-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid><description>EventLoop事件循环类，主要是封装Poller、回调函数执行逻辑、mainloop和subloop之间的通信方法。 mainloop 与 subloop 通信方式 mud</description></item><item><title>【重写muduo】10 - CurrentThread</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo10-currentthread/</link><pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo10-currentthread/</guid><description>获得线程的唯一标识 muduo库使用的模型是：one loop per thread，每个EventLoop都是在一个单独的线程中运行的，需要控制一些和线程相</description></item><item><title>【重写muduo】08 - Poller抽象类</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo08-poller%E6%8A%BD%E8%B1%A1%E7%B1%BB/</link><pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo08-poller%E6%8A%BD%E8%B1%A1%E7%B1%BB/</guid><description>muduo中，使用Poller抽象类来抽象不同的IO复用方法，muduo支持poll和epoll两种IO复用。 在Poller实现中，我们使用</description></item><item><title>【重写muduo】09 - EPollPoller事件分发器</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo09-epollpoller%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%99%A8/</link><pubDate>Sun, 18 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo09-epollpoller%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%99%A8/</guid><description>通过继承Poller抽象类来实现对epoll多路复用的的封装。 分析几个关键成员变量： Poller::ChannelMap Poller::channels_：用于存储所有注册到</description></item><item><title>【重写muduo】07 - Channel通道</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo07-channel%E9%80%9A%E9%81%93/</link><pubDate>Sat, 17 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo07-channel%E9%80%9A%E9%81%93/</guid><description>muduo库里面，TcpServer的事件循环EventLoop中，主要包含两大模块，一个是Channel列表，另一个是Poller。 Cha</description></item><item><title>【重写muduo】06 - InetAddress地址类</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo06-inetaddress%E5%9C%B0%E5%9D%80%E7%B1%BB/</link><pubDate>Fri, 16 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo06-inetaddress%E5%9C%B0%E5%9D%80%E7%B1%BB/</guid><description>这里没什么好写的，就是把sockaddr_in以及相关的函数进行封装，我们仅支持ipv4。 源码 InetAddress.hh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22</description></item><item><title>【重写muduo】04 - Logger日志系统</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo04-logger%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link><pubDate>Thu, 15 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo04-logger%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid><description>日志系统，我们使用和muduo库不同的实现，日志直接输出到控制台。 单例模式 我们使用单例模式来实现Logger类。 使用static Logger&amp;amp; insta</description></item><item><title>【重写muduo】05 - Timestamp时间戳</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo05-timestamp%E6%97%B6%E9%97%B4%E6%88%B3/</link><pubDate>Thu, 15 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo05-timestamp%E6%97%B6%E9%97%B4%E6%88%B3/</guid><description>时间戳类，我们只实现时间戳的核心功能，返回当前时间戳以及时间戳转格式化字符串。 使用c++11标准的chrono库来获取微秒级时间戳，使用c库</description></item><item><title>C++中的默认继承方式</title><link>https://xushun1221.github.io/2022/c-%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</guid><description>C++中的默认继承方式有两种情况。（与基类是class还是struct无关） 派生类是class的情况下，默认继承基类的方式是private；</description></item><item><title>【重写muduo】02 - CMake构建项目</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo02-cmake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo02-cmake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/</guid><description>在~/mymuduo/下构建该项目，使用CMake来编译生成项目。 CMakeLists.txt文件内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 cmake_minimum_required(VERSION 2.5)project(mymuduo)# my</description></item><item><title>【重写muduo】03 - noncopyable接口类</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo03-noncopyable%E6%8E%A5%E5%8F%A3%E7%B1%BB/</link><pubDate>Wed, 14 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo03-noncopyable%E6%8E%A5%E5%8F%A3%E7%B1%BB/</guid><description>理解源码 在原muduo库中(noncopyable.h)有这样一个类： 1 2 3 4 5 6 7 8 9 10 class noncopyable { public: noncopyable(const noncopyable&amp;amp;) = delete; void operator=(const noncopyable&amp;amp;) = delete; protected: noncopyable() = default; ~noncopyable() = default; }; 这个类的</description></item><item><title>【C++高级】03 - 绑定器、函数对象、lambda</title><link>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A703-%E7%BB%91%E5%AE%9A%E5%99%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1lambda/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A703-%E7%BB%91%E5%AE%9A%E5%99%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1lambda/</guid><description>绑定器和函数对象都是c++11从boost库中引入的机制。 bind1st bind2nd 绑定器 在c++ STL中提供了两个绑定器： bind1st：将operator()</description></item><item><title>【C++高级】04 - c++11总结和c++多线程</title><link>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A704-c-11%E6%80%BB%E7%BB%93%E5%92%8Cc-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link><pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A704-c-11%E6%80%BB%E7%BB%93%E5%92%8Cc-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid><description>c++11标准内容总结 关键字和语法 auto：可以根据右值推导出右值的类型，确定左边变量的类型； nullptr：原来使用的#define NULL 0是</description></item><item><title>【C++高级】02 - 智能指针</title><link>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A702-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A702-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid><description>智能指针介绍 裸指针，很强大，但是在使用时有很多的坑： 忘记释放资源，导致资源泄露； 同一资源释放多次，释放野指针，导致程序崩溃； 虽然编写了释放资</description></item><item><title>【C++高级】01 - 对象优化&amp;右值引用优化</title><link>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A701-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96/</link><pubDate>Thu, 08 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E9%AB%98%E7%BA%A701-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BC%98%E5%8C%96/</guid><description>对象使用中调用了哪些函数？（构造、析构、拷贝、赋值） 对象函数调用过程 - 示例1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32</description></item><item><title>【重写muduo】01 - 安装和使用 muduo</title><link>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo01-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-muduo/</link><pubDate>Wed, 07 Sep 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E9%87%8D%E5%86%99muduo01-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-muduo/</guid><description>安装 muduo 这里是在Ubuntu环境下。 先把muduo和boost的源码下载下来（muduo需要依赖boost）。 boost 源码库编译安装 先解压： 1 2 3 4</description></item><item><title>【C++基础】08 - STL组件</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8008-stl%E7%BB%84%E4%BB%B6/</link><pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8008-stl%E7%BB%84%E4%BB%B6/</guid><description>Standard Template libaray 标准模板库 学习内容： 标准容器 顺序容器 vector deque list 容器适配器 stack queue priority_queue 关联容器 无需关联容器 unordered_set unordered_multiset unordered_map unordered_multimap 有序关联容器 set multiset map multimap 近容器 数组 string bitset 迭代器 iterator const_iterator reverse_iterator const_reverse_iterator</description></item><item><title>【C++基础】07 - 多重继承问题</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8007-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 26 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8007-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/</guid><description>多（重）继承：一个派生类有多个基类class C: public A, public B {};。 虚基类、虚继承、虚基类表 virtual两个用法： 修饰成员方法（虚函数）； 修饰继</description></item><item><title>【C++基础】06 - 继承与多态</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8006-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8006-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</guid><description>继承的本质和原理 继承的本质：代码的复用 类和类之间的关系： 组合：a part of 继承：a kind of 三种继承方式下，派生类对基类成员的访问限定情况： 继承方式 基类</description></item><item><title>【C++基础】05 - 运算符重载、迭代器iterator、operator new</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8005-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%BF%AD%E4%BB%A3%E5%99%A8iteratoroperator-new/</link><pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8005-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%BF%AD%E4%BB%A3%E5%99%A8iteratoroperator-new/</guid><description>运算符重载的意义在于，使得对象的运算表现得和编译器内置的类型一样。例如： 1 2 3 4 template&amp;lt;typename T&amp;gt; T sum(T a, T b) { return a + b; // a.+(b); } 如果T是内置类型，a + b可以直</description></item><item><title>【C++基础】04 - 模板编程、分配器allocator</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8004-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B%E5%88%86%E9%85%8D%E5%99%A8allocator/</link><pubDate>Thu, 11 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8004-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B%E5%88%86%E9%85%8D%E5%99%A8allocator/</guid><description>函数模板 相关的概念： 函数模板：不进行编译，因为调用前不知道类型 模板的实例化：函数调用点进行实例化 模板函数：需要编译的代码 模板类型参数：typ</description></item><item><title>【C++基础】03 - OOP基础知识总结</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8003-oop%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8003-oop%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid><description>本篇总结C++OOP的基础知识。 类、对象、this指针 类和对象简单介绍 类，是实体的抽象类型。 使用OOP解决问题首先要在问题中找到实体，从实体</description></item><item><title>【C++基础】02 - C++基础知识总结</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8002-c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 04 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8002-c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid><description>本篇总结C++OOP之外的基础知识。 形参带默认值的函数 默认参数应该从右向左给出，调用时从左向右给出参数，如未指定某个参数则从此向右的参数使用</description></item><item><title>【C++基础】01 - 地址空间、函数调用、编译链接</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8001-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8001-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</guid><description>虚拟地址空间 这里讨论的虚拟地址空间，是在x86-32位-Linux环境下的。 任何编程语言的程序代码编译为可执行文件（存放在磁盘上）时，都会生</description></item><item><title>【算法】Next Permutaion 问题</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95next-permutaion-%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95next-permutaion-%E9%97%AE%E9%A2%98/</guid><description>问题描述 给定一个数字或字符序列，要求找到它的下一个按字典序升序排列的序列。 相关题目： LeetCode31.下一个排列 LeetCode556.</description></item><item><title>【算法】有序表 - 实现结构总结</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9C%89%E5%BA%8F%E8%A1%A8-%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9C%89%E5%BA%8F%E8%A1%A8-%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</guid><description>有序表的类型 红黑树 - Red Black Tree AVL - Adelson-Velsky and Landis 自平衡的搜索二叉树 SBT - Size Balanced Tree 节点大小平衡树 上述有序表的查找时间复杂度都为：$O\left(logn\ri</description></item><item><title>【算法】动态规划 - 进阶</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%BF%9B%E9%98%B6/</link><pubDate>Fri, 29 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%BF%9B%E9%98%B6/</guid><description>如何评价尝试方法 两个方面： 单个可变参数的维度（绝大多数的题目0维度即可，如int类型）； 可变参数的个数。 相关题目 题目1：纸牌博弈-预测赢家 （</description></item><item><title>【算法】暴力递归->记忆化搜索->动态规划</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>三者关系 找到某个解决问题的尝试方法 暴力递归就是不经过优化的暴力尝试 记忆化搜索的动态规划，在暴力递归基础上优化，无需规定每个状态的依赖关系 严格</description></item><item><title>【算法】位运算相关题目</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</link><pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</guid><description>待补充吧。。。 题目1：不适用比较判断返回较大的数 题目描述：给定两个32位有符号整型a b，返回其中较大的数，不能使用比较判断方法。</description></item><item><title>【算法】资源限制类的大数据问题 - 技巧总结</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</guid><description>资源限制类的大数据问题的解题技巧 哈希函数可以把数据按照种类均匀分流 布隆过滤器用于集合的建立和查询，并可以节省大量空间 一致性哈希解决数据服务器</description></item><item><title>【算法】一致性哈希算法</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</guid><description>待补充。。。</description></item><item><title>【算法】二叉树的Morris遍历</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84morris%E9%81%8D%E5%8E%86/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84morris%E9%81%8D%E5%8E%86/</guid><description>Morris遍历是什么 一种遍历二叉树的方式，且时间复杂度为$O\left(n\right)$，空间复杂度为$O\left(1\right)$</description></item><item><title>【算法】树形DP问题套路</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%A0%91%E5%BD%A2dp%E9%97%AE%E9%A2%98%E5%A5%97%E8%B7%AF/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%A0%91%E5%BD%A2dp%E9%97%AE%E9%A2%98%E5%A5%97%E8%B7%AF/</guid><description>树形DP套路 使用前提 如果题目求解目标是S规则，则求解流程可以定成，以每一个结点为头节点的子树在S规则下的每一个答案，并且答案一定在其中。 步骤</description></item><item><title>【算法】滑动窗口&amp;单调栈</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%95%E8%B0%83%E6%A0%88/</link><pubDate>Sat, 16 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%95%E8%B0%83%E6%A0%88/</guid><description>滑动窗口是什么 一个数组arr，一个左边界L，一个右边界R，滑动窗口就是L R控制的范围，L始终小于等于R，R向右移动时窗口内增加一个元素，L向</description></item><item><title>【算法】Manacher算法 - 原理及实现</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95manacher%E7%AE%97%E6%B3%95-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link><pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95manacher%E7%AE%97%E6%B3%95-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid><description>最长回文子串 LeetCode5 问题描述：给你一个字符串 s，找到 s 中最长的回文子串（回文是前后部分对称的字符串，且子串要求连续）。 经典算法 中心扩散法：遍历字符</description></item><item><title>【算法】KMP算法 - 原理及实现</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95kmp%E7%AE%97%E6%B3%95-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link><pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95kmp%E7%AE%97%E6%B3%95-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid><description>字符串匹配算法 LeetCode28 问题描述：给你两个字符串haystack和needle，请你在haystack字符串中找出needle字符串出现的第一个位置</description></item><item><title>【算法】并查集</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%B9%B6%E6%9F%A5%E9%9B%86/</link><pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid><description>前言 考虑这样一个经典问题LeetCode200：给你一个由 1（陆地）和 0（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，</description></item><item><title>【算法】位图与布隆过滤器 - 原理及实现</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link><pubDate>Tue, 12 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid><description>前言 考虑如下问题：假设你是网管，你有一个文件，其中存储了100亿个违反法律的url（每个url最多64字节），你不想让用户访问这些网站，如何</description></item><item><title>【算法】哈希函数与哈希表的实现原理</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Tue, 12 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>哈希函数 哈希函数的特征 输入域：无穷，输出域：有穷 确定性：对于同一个哈希函数，相同的输入必然会有相同的输出 哈希碰撞：由于输出域是有限的，在很小</description></item><item><title>【算法】暴力递归（回溯）</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF/</guid><description>暴力递归 暴力递归就是尝试： 把问题转化为规模缩小了的同类问题的子问题 有明确的不需要继续进行递归的条件（base case） 有当得到了子问题的结果</description></item><item><title>【算法】贪心算法</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid><description>贪心算法定义 在某个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的做法叫贪心算法。也就是说，不从整体最优上考</description></item><item><title>【算法】前缀树</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%89%8D%E7%BC%80%E6%A0%91/</link><pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%89%8D%E7%BC%80%E6%A0%91/</guid><description>前缀树的定义 前缀树（Trie，字典树）是N叉树的一种特殊形式。通常来说，一个前缀树是用来存储字符串的。前缀树的每一个节点代表一个字符串（前缀</description></item><item><title>C++字符串操作相关</title><link>https://xushun1221.github.io/2022/c-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3/</link><pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3/</guid><description>int 和 string 互相转换 1 2 3 4 5 #include &amp;lt;string&amp;gt;using namespace std; int a = stoi(&amp;#34;123&amp;#34;); string s = to_string(123); 按字符分割字符串 使用C库函数strtok： 1 2 char* strtok( char* str, const char* delim ); // 线程不安全 char *strtok_r(char *str, const char *delim, char **saveptr); //</description></item><item><title>【算法】图</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%9B%BE/</link><pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%9B%BE/</guid><description>图的定义 图大体可以由邻接表和邻接矩阵两种形式来表示。 可以用自己习惯的结构将图的算法全部实现一遍，当遇到图相关的问题，可以将数据描述转换为自己</description></item><item><title>C++输入输出</title><link>https://xushun1221.github.io/2022/c-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</link><pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</guid><description>基本输入 cin &amp;gt;&amp;gt;会自动过滤掉：空格、回车、TAB等不可见字符（会被吃掉，不会保留在输入流中），可以用于string和数组 cin.g</description></item><item><title>【算法】二叉树</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>二叉树定义 1 2 3 4 5 6 7 8 struct TreeNode { int val; TreeNode *left; TreeNode *right; // TreeNode() : val(0), left(nullptr), right(nullptr) {} // TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} // TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; 递归遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</description></item><item><title>【算法】链表</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E9%93%BE%E8%A1%A8/</guid><description>链表定义 1 2 3 4 5 6 7 8 9 10 11 12 // 单链表 struct ListNode { int val; ListNode *next; }; // 双链表 struct ListNode { int val; ListNode *next; ListNode *front; }; 链表题目之方法论 笔试：不用太在乎空间复杂度，一切为了时间</description></item><item><title>CS144 Lab Assignment lab-4</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-4/</link><pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-4/</guid><description>前言 前后经过半个多月终于把关于TCP的几个lab写完了，★,°:.☆(￣▽￣)/$:.°★ 。 lab4的难点在于对于TCP各个状态的理解、如何</description></item><item><title>CS144 Lab Assignment lab-3</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-3/</link><pubDate>Thu, 17 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-3/</guid><description>the TCP sender 本次实验是TCP的sender，需要完成的主要功能有： 跟踪接收方的接收窗口，正确处理接收方返回的确认号ackno和窗口大小window</description></item><item><title>CS144 Lab Assignment lab-2</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-2/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-2/</guid><description>build 首先把origin/lab2-startercode合并到本地仓库，cmake构建时，有可能会报错： CMake Error: The following variables are used in this project, but they are set to NOTFOUND. 这是因</description></item><item><title>CS144 Lab Assignment lab-1</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-1/</link><pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-1/</guid><description>stitching substrings into a byte stream 本次实验是要实现一个流重组器，能够将TCPReceiver接收到的乱序的、重复的TCP段重新组装成一个正确的、按序的、无重复的字</description></item><item><title>CS144 Lab Assignment lab-0</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-0/</link><pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-0/</guid><description>前言 最近重新学习了一下计算机网络的知识，想着搞点东西做一做，然后就看到了这个Stanford的CS144网络课，它有一系列的网络实验，主要是</description></item><item><title>【算法】堆排序</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F/</link><pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F/</guid><description>堆排序 原理：利用大根堆（小根堆）结构来进行排序。 实现1 这种实现方法，在建立最大堆时，从后向前对每个有孩子的结点进行了一次向下调整算法，建堆时</description></item><item><title>Coding之小技巧</title><link>https://xushun1221.github.io/2022/coding%E4%B9%8B%E5%B0%8F%E6%8A%80%E5%B7%A7/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/coding%E4%B9%8B%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid><description>前言 记录一些Coding的技巧。 取数组下标中点 常规的取下标中点方法：mid = (left + right) / 2，这种方法在数组很大的时候，可能会溢出，所以用这种方法</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【5】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%915/</link><pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%915/</guid><description>前言 学了这么多，写一个简单的项目来总结一下。 写源码 源码 编译 编译 调试 点击Run and Debug按钮，新建launch.json文件，然后按F5即可</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【3】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%913/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%913/</guid><description>安装VSCode 直接官网下载最新版本的deb包，地址：https://code.visualstudio.com； 在下载deb包的目录下打开</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【4】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%914/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%914/</guid><description>CMake是啥 一个跨平台的安装编译工具，可以使用简单的语句来描述所有平台的编译安装过程； 是大部分C++开源项目的标配； CMake语法特性 基本</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【2】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%912/</link><pubDate>Sun, 13 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%912/</guid><description>GDB调试器介绍 GDB是什么 GDB(GNU Debugger)是一个用来调试C/C++程序的功能强大的调试器，是Linux系统开发C/C++最常用的调试器</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【1】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%911/</link><pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%911/</guid><description>安装Linux系统 这里用的是虚拟机 Ubuntu 18.04 LTS 安装过程略。 安装GCC、GDB、CMake 安装GCC，GDB 1 2 3 sudo apt update sudo apt install build-essential gdb 安装CMake 1 sudo</description></item><item><title>【算法】二分查找</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid><description>前言 二分查找算法，思想比较简单，但是实现上有许多细节需要考虑，尤其是在边界条件的判断上，很容易出错。最近看了一个关于二分查找的总结，用另一种</description></item></channel></rss>