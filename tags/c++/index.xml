<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on XuShun's Blog</title><link>https://xushun1221.github.io/tags/c++/</link><description>Recent content in C++ on XuShun's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 12 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://xushun1221.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>【C++基础】05 - 运算符重载、迭代器iterator</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8005-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%BF%AD%E4%BB%A3%E5%99%A8iterator/</link><pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8005-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E8%BF%AD%E4%BB%A3%E5%99%A8iterator/</guid><description>运算符重载的意义在于，使得对象的运算表现得和编译器内置的类型一样。例如： 1 2 3 4 template&amp;lt;typename T&amp;gt; T sum(T a, T b) { return a + b; // a.+(b); } 如果T是内置类型，a + b可以直</description></item><item><title>【C++基础】04 - 模板编程、分配器allocator</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8004-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B%E5%88%86%E9%85%8D%E5%99%A8allocator/</link><pubDate>Thu, 11 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8004-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B%E5%88%86%E9%85%8D%E5%99%A8allocator/</guid><description>函数模板 相关的概念： 函数模板：不进行编译，因为调用前不知道类型 模板的实例化：函数调用点进行实例化 模板函数：需要编译的代码 模板类型参数：typ</description></item><item><title>【C++基础】03 - OOP基础知识总结</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8003-oop%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8003-oop%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid><description>本篇总结C++OOP的基础知识。 类、对象、this指针 类和对象简单介绍 类，是实体的抽象类型。 使用OOP解决问题首先要在问题中找到实体，从实体</description></item><item><title>【C++基础】02 - C++基础知识总结</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8002-c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 04 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8002-c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid><description>本篇总结C++OOP之外的基础知识。 形参带默认值的函数 默认参数应该从右向左给出，调用时从左向右给出参数，如未指定某个参数则从此向右的参数使用</description></item><item><title>【C++基础】01 - 地址空间、函数调用、编译链接</title><link>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8001-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%9F%BA%E7%A1%8001-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</guid><description>虚拟地址空间 这里讨论的虚拟地址空间，是在x86-32位-Linux环境下的。 任何编程语言的程序代码编译为可执行文件（存放在磁盘上）时，都会生</description></item><item><title>【算法】Next Permutaion 问题</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95next-permutaion-%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95next-permutaion-%E9%97%AE%E9%A2%98/</guid><description>问题描述 给定一个数字或字符序列，要求找到它的下一个按字典序升序排列的序列。 相关题目： LeetCode31.下一个排列 LeetCode556.</description></item><item><title>【算法】有序表 - 实现结构总结</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9C%89%E5%BA%8F%E8%A1%A8-%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9C%89%E5%BA%8F%E8%A1%A8-%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</guid><description>有序表的类型 红黑树 - Red Black Tree AVL - Adelson-Velsky and Landis 自平衡的搜索二叉树 SBT - Size Balanced Tree 节点大小平衡树 上述有序表的查找时间复杂度都为：$O\left(logn\ri</description></item><item><title>【算法】动态规划 - 进阶</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%BF%9B%E9%98%B6/</link><pubDate>Fri, 29 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%BF%9B%E9%98%B6/</guid><description>如何评价尝试方法 两个方面： 单个可变参数的维度（绝大多数的题目0维度即可，如int类型）； 可变参数的个数。 相关题目 题目1：纸牌博弈-预测赢家 （</description></item><item><title>【算法】暴力递归->记忆化搜索->动态规划</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link><pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid><description>三者关系 找到某个解决问题的尝试方法 暴力递归就是不经过优化的暴力尝试 记忆化搜索的动态规划，在暴力递归基础上优化，无需规定每个状态的依赖关系 严格</description></item><item><title>【算法】位运算相关题目</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</link><pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</guid><description>待补充吧。。。 题目1：不适用比较判断返回较大的数 题目描述：给定两个32位有符号整型a b，返回其中较大的数，不能使用比较判断方法。</description></item><item><title>【算法】资源限制类的大数据问题 - 技巧总结</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%B1%BB%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</guid><description>资源限制类的大数据问题的解题技巧 哈希函数可以把数据按照种类均匀分流 布隆过滤器用于集合的建立和查询，并可以节省大量空间 一致性哈希解决数据服务器</description></item><item><title>【算法】一致性哈希算法</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</guid><description>待补充。。。</description></item><item><title>【算法】二叉树的Morris遍历</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84morris%E9%81%8D%E5%8E%86/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84morris%E9%81%8D%E5%8E%86/</guid><description>Morris遍历是什么 一种遍历二叉树的方式，且时间复杂度为$O\left(n\right)$，空间复杂度为$O\left(1\right)$</description></item><item><title>【算法】树形DP问题套路</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%A0%91%E5%BD%A2dp%E9%97%AE%E9%A2%98%E5%A5%97%E8%B7%AF/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%A0%91%E5%BD%A2dp%E9%97%AE%E9%A2%98%E5%A5%97%E8%B7%AF/</guid><description>树形DP套路 使用前提 如果题目求解目标是S规则，则求解流程可以定成，以每一个结点为头节点的子树在S规则下的每一个答案，并且答案一定在其中。 步骤</description></item><item><title>【算法】滑动窗口&amp;单调栈</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%95%E8%B0%83%E6%A0%88/</link><pubDate>Sat, 16 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%95%E8%B0%83%E6%A0%88/</guid><description>滑动窗口是什么 一个数组arr，一个左边界L，一个右边界R，滑动窗口就是L R控制的范围，L始终小于等于R，R向右移动时窗口内增加一个元素，L向</description></item><item><title>【算法】Manacher算法 - 原理及实现</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95manacher%E7%AE%97%E6%B3%95-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link><pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95manacher%E7%AE%97%E6%B3%95-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid><description>最长回文子串 LeetCode5 问题描述：给你一个字符串 s，找到 s 中最长的回文子串（回文是前后部分对称的字符串，且子串要求连续）。 经典算法 中心扩散法：遍历字符</description></item><item><title>【算法】KMP算法 - 原理及实现</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95kmp%E7%AE%97%E6%B3%95-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link><pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95kmp%E7%AE%97%E6%B3%95-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid><description>字符串匹配算法 LeetCode28 问题描述：给你两个字符串haystack和needle，请你在haystack字符串中找出needle字符串出现的第一个位置</description></item><item><title>【算法】并查集</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%B9%B6%E6%9F%A5%E9%9B%86/</link><pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid><description>前言 考虑这样一个经典问题LeetCode200：给你一个由 1（陆地）和 0（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，</description></item><item><title>【算法】位图与布隆过滤器 - 原理及实现</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link><pubDate>Tue, 12 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BD%8D%E5%9B%BE%E4%B8%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid><description>前言 考虑如下问题：假设你是网管，你有一个文件，其中存储了100亿个违反法律的url（每个url最多64字节），你不想让用户访问这些网站，如何</description></item><item><title>【算法】哈希函数与哈希表的实现原理</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Tue, 12 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>哈希函数 哈希函数的特征 输入域：无穷，输出域：有穷 确定性：对于同一个哈希函数，相同的输入必然会有相同的输出 哈希碰撞：由于输出域是有限的，在很小</description></item><item><title>【算法】暴力递归（回溯）</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF/</link><pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF/</guid><description>暴力递归 暴力递归就是尝试： 把问题转化为规模缩小了的同类问题的子问题 有明确的不需要继续进行递归的条件（base case） 有当得到了子问题的结果</description></item><item><title>【算法】贪心算法</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid><description>贪心算法定义 在某个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的做法叫贪心算法。也就是说，不从整体最优上考</description></item><item><title>【算法】前缀树</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%89%8D%E7%BC%80%E6%A0%91/</link><pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%89%8D%E7%BC%80%E6%A0%91/</guid><description>前缀树的定义 前缀树（Trie，字典树）是N叉树的一种特殊形式。通常来说，一个前缀树是用来存储字符串的。前缀树的每一个节点代表一个字符串（前缀</description></item><item><title>C++字符串操作相关</title><link>https://xushun1221.github.io/2022/c-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3/</link><pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3/</guid><description>int 和 string 互相转换 1 2 3 4 5 #include &amp;lt;string&amp;gt;using namespace std; int a = stoi(&amp;#34;123&amp;#34;); string s = to_string(123); 按字符分割字符串 使用C库函数strtok： 1 2 char* strtok( char* str, const char* delim ); // 线程不安全 char *strtok_r(char *str, const char *delim, char **saveptr); //</description></item><item><title>【算法】图</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%9B%BE/</link><pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%9B%BE/</guid><description>图的定义 图大体可以由邻接表和邻接矩阵两种形式来表示。 可以用自己习惯的结构将图的算法全部实现一遍，当遇到图相关的问题，可以将数据描述转换为自己</description></item><item><title>C++输入输出</title><link>https://xushun1221.github.io/2022/c-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</link><pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/c-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</guid><description>基本输入 cin &amp;gt;&amp;gt;会自动过滤掉：空格、回车、TAB等不可见字符（会被吃掉，不会保留在输入流中），可以用于string和数组 cin.g</description></item><item><title>【算法】二叉树</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>二叉树定义 1 2 3 4 5 6 7 8 struct TreeNode { int val; TreeNode *left; TreeNode *right; // TreeNode() : val(0), left(nullptr), right(nullptr) {} // TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} // TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; 递归遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</description></item><item><title>【算法】链表</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E9%93%BE%E8%A1%A8/</link><pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E9%93%BE%E8%A1%A8/</guid><description>链表定义 1 2 3 4 5 6 7 8 9 10 11 12 // 单链表 struct ListNode { int val; ListNode *next; }; // 双链表 struct ListNode { int val; ListNode *next; ListNode *front; }; 链表题目之方法论 笔试：不用太在乎空间复杂度，一切为了时间</description></item><item><title>CS144 Lab Assignment lab-4</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-4/</link><pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-4/</guid><description>前言 前后经过半个多月终于把关于TCP的几个lab写完了，★,°:.☆(￣▽￣)/$:.°★ 。 lab4的难点在于对于TCP各个状态的理解、如何</description></item><item><title>CS144 Lab Assignment lab-3</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-3/</link><pubDate>Thu, 17 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-3/</guid><description>the TCP sender 本次实验是TCP的sender，需要完成的主要功能有： 跟踪接收方的接收窗口，正确处理接收方返回的确认号ackno和窗口大小window</description></item><item><title>CS144 Lab Assignment lab-2</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-2/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-2/</guid><description>build 首先把origin/lab2-startercode合并到本地仓库，cmake构建时，有可能会报错： CMake Error: The following variables are used in this project, but they are set to NOTFOUND. 这是因</description></item><item><title>CS144 Lab Assignment lab-1</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-1/</link><pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-1/</guid><description>stitching substrings into a byte stream 本次实验是要实现一个流重组器，能够将TCPReceiver接收到的乱序的、重复的TCP段重新组装成一个正确的、按序的、无重复的字</description></item><item><title>CS144 Lab Assignment lab-0</title><link>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-0/</link><pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/cs144-lab-assignment-lab-0/</guid><description>前言 最近重新学习了一下计算机网络的知识，想着搞点东西做一做，然后就看到了这个Stanford的CS144网络课，它有一系列的网络实验，主要是</description></item><item><title>【算法】堆排序</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F/</link><pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E5%A0%86%E6%8E%92%E5%BA%8F/</guid><description>堆排序 原理：利用大根堆（小根堆）结构来进行排序。 实现1 这种实现方法，在建立最大堆时，从后向前对每个有孩子的结点进行了一次向下调整算法，建堆时</description></item><item><title>Coding之小技巧</title><link>https://xushun1221.github.io/2022/coding%E4%B9%8B%E5%B0%8F%E6%8A%80%E5%B7%A7/</link><pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/coding%E4%B9%8B%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid><description>前言 记录一些Coding的技巧。 取数组下标中点 常规的取下标中点方法：mid = (left + right) / 2，这种方法在数组很大的时候，可能会溢出，所以用这种方法</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【5】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%915/</link><pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%915/</guid><description>前言 学了这么多，写一个简单的项目来总结一下。 写源码 源码 编译 编译 调试 点击Run and Debug按钮，新建launch.json文件，然后按F5即可</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【3】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%913/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%913/</guid><description>安装VSCode 直接官网下载最新版本的deb包，地址：https://code.visualstudio.com； 在下载deb包的目录下打开</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【4】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%914/</link><pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%914/</guid><description>CMake是啥 一个跨平台的安装编译工具，可以使用简单的语句来描述所有平台的编译安装过程； 是大部分C++开源项目的标配； CMake语法特性 基本</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【2】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%912/</link><pubDate>Sun, 13 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%912/</guid><description>GDB调试器介绍 GDB是什么 GDB(GNU Debugger)是一个用来调试C/C++程序的功能强大的调试器，是Linux系统开发C/C++最常用的调试器</description></item><item><title>Linux下使用VSCode和CMake进行C++开发【1】</title><link>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%911/</link><pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/linux%E4%B8%8B%E4%BD%BF%E7%94%A8vscode%E5%92%8Ccmake%E8%BF%9B%E8%A1%8Cc-%E5%BC%80%E5%8F%911/</guid><description>安装Linux系统 这里用的是虚拟机 Ubuntu 18.04 LTS 安装过程略。 安装GCC、GDB、CMake 安装GCC，GDB 1 2 3 sudo apt update sudo apt install build-essential gdb 安装CMake 1 sudo</description></item><item><title>【算法】二分查找</title><link>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate><guid>https://xushun1221.github.io/2022/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid><description>前言 二分查找算法，思想比较简单，但是实现上有许多细节需要考虑，尤其是在边界条件的判断上，很容易出错。最近看了一个关于二分查找的总结，用另一种</description></item></channel></rss>